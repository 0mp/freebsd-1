diff --git a/buildos b/buildos
new file mode 100755
index 00000000000..87ab5543055
--- /dev/null
+++ b/buildos
@@ -0,0 +1,15 @@
+#!/bin/sh
+
+. ~/.bashrc
+
+cd ~/freebsd/freebsd
+
+git pull
+
+echo "Build world..."
+sr make -j9 buildworld > /tmp/log_build_world
+
+echo "Build kernel..."
+sr make -j9 buildkernel > /tmp/log_build_kernel
+
+
diff --git a/cddl/contrib/opensolaris/cmd/dtrace/dtrace.c b/cddl/contrib/opensolaris/cmd/dtrace/dtrace.c
index b594ed6aecd..f5e12eec2cb 100644
--- a/cddl/contrib/opensolaris/cmd/dtrace/dtrace.c
+++ b/cddl/contrib/opensolaris/cmd/dtrace/dtrace.c
@@ -31,6 +31,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/wait.h>
+#include <sys/queue.h>
 
 #include <dtrace.h>
 #include <stdlib.h>
@@ -43,6 +44,9 @@
 #include <fcntl.h>
 #include <errno.h>
 #include <signal.h>
+#include <pthread.h>
+#include <fcntl.h>
+#include <assert.h>
 #ifdef illumos
 #include <alloca.h>
 #endif
@@ -56,34 +60,54 @@
 
 #include <libxo/xo.h>
 
-typedef struct dtrace_cmd {
-	void (*dc_func)(struct dtrace_cmd *);	/* function to compile arg */
-	dtrace_probespec_t dc_spec;		/* probe specifier context */
-	char *dc_arg;				/* argument from main argv */
-	const char *dc_name;			/* name for error messages */
-	const char *dc_desc;			/* desc for error messages */
-	dtrace_prog_t *dc_prog;			/* program compiled from arg */
-	char dc_ofile[PATH_MAX];		/* derived output file name */
+#include <dt_impl.h>
+#include <sys/time.h>
+
+typedef struct dtrace_cmd
+{
+	void (*dc_func)(struct dtrace_cmd *); /* function to compile arg */
+	dtrace_probespec_t dc_spec;			  /* probe specifier context */
+	char *dc_arg;						  /* argument from main argv */
+	const char *dc_name;				  /* name for error messages */
+	const char *dc_desc;				  /* desc for error messages */
+	dtrace_prog_t *dc_prog;				  /* program compiled from arg */
+	char dc_ofile[PATH_MAX];			  /* derived output file name */
 } dtrace_cmd_t;
 
-#define	DMODE_VERS	0	/* display version information and exit (-V) */
-#define	DMODE_EXEC	1	/* compile program for enabling (-a/e/E) */
-#define	DMODE_ANON	2	/* compile program for anonymous tracing (-A) */
-#define	DMODE_LINK	3	/* compile program for linking with ELF (-G) */
-#define	DMODE_LIST	4	/* compile program and list probes (-l) */
-#define	DMODE_HEADER	5	/* compile program for headergen (-h) */
+struct dtrace_guest_entry
+{
+	dtrace_bufdesc_t *desc;
+	STAILQ_ENTRY(dtrace_guest_entry)
+	entries;
+} dtrace_guest_entry_t;
+
+struct dtrace_guestq
+{
+	STAILQ_HEAD(, dtrace_guest_entry)
+	head;
+	pthread_mutex_t mtx;
+};
 
-#define	E_SUCCESS	0
-#define	E_ERROR		1
-#define	E_USAGE		2
+#define FRAGMENTSZ 4000
 
-#define OMODE_NONE	0
-#define OMODE_JSON	1
-#define OMODE_XML	2
-#define OMODE_HTML	3
+#define DMODE_VERS 0   /* display version information and exit (-V) */
+#define DMODE_EXEC 1   /* compile program for enabling (-a/e/E) */
+#define DMODE_ANON 2   /* compile program for anonymous tracing (-A) */
+#define DMODE_LINK 3   /* compile program for linking with ELF (-G) */
+#define DMODE_LIST 4   /* compile program and list probes (-l) */
+#define DMODE_HEADER 5 /* compile program for headergen (-h) */
+
+#define E_SUCCESS 0
+#define E_ERROR 1
+#define E_USAGE 2
+
+#define OMODE_NONE 0
+#define OMODE_JSON 1
+#define OMODE_XML 2
+#define OMODE_HTML 3
 
 static const char DTRACE_OPTSTR[] =
-	"3:6:aAb:Bc:CD:ef:FGhHi:I:lL:m:M:n:O:o:p:P:qs:SU:vVwx:X:Z";
+	"3:6:aAb:Bc:CD:ef:FGhHi:I:lL:m:M:n:O:o:p:P:qs:SU:vVwx:X:Y:Z";
 static int g_oformat = OMODE_NONE;
 
 static char **g_argv;
@@ -116,85 +140,95 @@ static int g_grabanon = 0;
 
 static const char *g_ofile = NULL;
 static FILE *g_ofp;
+static FILE *logging_fp;
 static dtrace_hdl_t *g_dtp;
+
+static int done, idx = 0;
+static struct timeval ts;
 #ifdef illumos
 static char *g_etcfile = "/etc/system";
 static const char *g_etcbegin = "* vvvv Added by DTrace";
 static const char *g_etcend = "* ^^^^ Added by DTrace";
 
-static const char *g_etc[] =  {
-"*",
-"* The following forceload directives were added by dtrace(1M) to allow for",
-"* tracing during boot.  If these directives are removed, the system will",
-"* continue to function, but tracing will not occur during boot as desired.",
-"* To remove these directives (and this block comment) automatically, run",
-"* \"dtrace -A\" without additional arguments.  See the \"Anonymous Tracing\"",
-"* chapter of the Solaris Dynamic Tracing Guide for details.",
-"*",
-NULL };
+static const char *g_etc[] = {
+	"*",
+	"* The following forceload directives were added by dtrace(1M) to allow for",
+	"* tracing during boot.  If these directives are removed, the system will",
+	"* continue to function, but tracing will not occur during boot as desired.",
+	"* To remove these directives (and this block comment) automatically, run",
+	"* \"dtrace -A\" without additional arguments.  See the \"Anonymous Tracing\"",
+	"* chapter of the Solaris Dynamic Tracing Guide for details.",
+	"*",
+	NULL};
 #endif
 
 #if !defined(illumos) && defined(NEED_ERRLOC)
 void dt_get_errloc(dtrace_hdl_t *, char **, int *);
 #endif /* !illumos && NEED_ERRLOC */
 
-static int
+extern int
+dt_consume_cpu(dtrace_hdl_t *dtp, FILE *fp, int cpu,
+			   dtrace_bufdesc_t *buf, boolean_t just_one,
+			   dtrace_consumer_t *dc, void *arg);
+
 usage(FILE *fp)
 {
 	static const char predact[] = "[[ predicate ] action ]";
 
-	(void) fprintf(fp, "Usage: %s [-32|-64] [-aACeFGhHlqSvVwZ] "
-	    "[-b bufsz] [-c cmd] [-D name[=def]]\n\t[-g gv_output] [-I path] "
-	    "[-L path] [-o output] [-p pid] [-s script] [-U name]\n\t"
-	    "[-x opt[=val]] [-X a|c|s|t]\n\n"
-	    "\t[-M [ vm1,vm2,vm3,... ]\n"
-	    "\t[-P provider %s]\n"
-	    "\t[-m [ provider: ] module %s]\n"
-	    "\t[-f [[ provider: ] module: ] func %s]\n"
-	    "\t[-n [[[ provider: ] module: ] func: ] name %s]\n"
-	    "\t[-i probe-id %s] [ args ... ]\n\n", g_pname,
-	    predact, predact, predact, predact, predact);
-
-	(void) fprintf(fp, "\tpredicate -> '/' D-expression '/'\n");
-	(void) fprintf(fp, "\t   action -> '{' D-statements '}'\n");
-
-	(void) fprintf(fp, "\n"
-	    "\t-32 generate 32-bit D programs and ELF files\n"
-	    "\t-64 generate 64-bit D programs and ELF files\n\n"
-	    "\t-a  claim anonymous tracing state\n"
-	    "\t-A  generate driver.conf(4) directives for anonymous tracing\n"
-	    "\t-b  set trace buffer size\n"
-	    "\t-c  run specified command and exit upon its completion\n"
-	    "\t-C  run cpp(1) preprocessor on script files\n"
-	    "\t-D  define symbol when invoking preprocessor\n"
-	    "\t-e  exit after compiling request but prior to enabling probes\n"
-	    "\t-f  enable or list probes matching the specified function name\n"
-	    "\t-F  coalesce trace output by function\n"
-	    "\t-G  generate an ELF file containing embedded dtrace program\n"
-	    "\t-g  output GraphViz Dot representation of script actions\n"
-	    "\t-h  generate a header file with definitions for static probes\n"
-	    "\t-H  print included files when invoking preprocessor\n"
-	    "\t-i  enable or list probes matching the specified probe id\n"
-	    "\t-I  add include directory to preprocessor search path\n"
-	    "\t-l  list probes matching specified criteria\n"
-	    "\t-L  add library directory to library search path\n"
-	    "\t-M  specify virtual-machine filters\n"
-	    "\t-m  enable or list probes matching the specified module name\n"
-	    "\t-n  enable or list probes matching the specified probe name\n"
-	    "\t-O  output format json|xml\n"
-	    "\t-o  set output file\n"
-	    "\t-p  grab specified process-ID and cache its symbol tables\n"
-	    "\t-P  enable or list probes matching the specified provider name\n"
-	    "\t-q  set quiet mode (only output explicitly traced data)\n"
-	    "\t-s  enable or list probes according to the specified D script\n"
-	    "\t-S  print D compiler intermediate code\n"
-	    "\t-U  undefine symbol when invoking preprocessor\n"
-	    "\t-v  set verbose mode (report stability attributes, arguments)\n"
-	    "\t-V  report DTrace API version\n"
-	    "\t-w  permit destructive actions\n"
-	    "\t-x  enable or modify compiler and tracing options\n"
-	    "\t-X  specify ISO C conformance settings for preprocessor\n"
-	    "\t-Z  permit probe descriptions that match zero probes\n");
+	(void)fprintf(fp, "Usage: %s [-32|-64] [-aACeFGhHlqSvVwZ] "
+					  "[-b bufsz] [-c cmd] [-D name[=def]]\n\t[-g gv_output] [-I path] "
+					  "[-L path] [-o output] [-p pid] [-s script] [-U name]\n\t"
+					  "[-x opt[=val]] [-X a|c|s|t]\n\n"
+					  "\t[-M [ vm1,vm2,vm3,... ]\n"
+					  "\t[-P provider %s]\n"
+					  "\t[-m [ provider: ] module %s]\n"
+					  "\t[-f [[ provider: ] module: ] func %s]\n"
+					  "\t[-n [[[ provider: ] module: ] func: ] name %s]\n"
+					  "\t[-i probe-id %s] [ args ... ]\n\n",
+				  g_pname,
+				  predact, predact, predact, predact, predact);
+
+	(void)fprintf(fp, "\tpredicate -> '/' D-expression '/'\n");
+	(void)fprintf(fp, "\t   action -> '{' D-statements '}'\n");
+
+	(void)fprintf(fp, "\n"
+					  "\t-32 generate 32-bit D programs and ELF files\n"
+					  "\t-64 generate 64-bit D programs and ELF files\n\n"
+					  "\t-a  claim anonymous tracing state\n"
+					  "\t-A  generate driver.conf(4) directives for anonymous tracing\n"
+					  "\t-b  set trace buffer size\n"
+					  "\t-c  run specified command and exit upon its completion\n"
+					  "\t-C  run cpp(1) preprocessor on script files\n"
+					  "\t-D  define symbol when invoking preprocessor\n"
+					  "\t-e  exit after compiling request but prior to enabling probes\n"
+					  "\t-f  enable or list probes matching the specified function name\n"
+					  "\t-F  coalesce trace output by function\n"
+					  "\t-G  generate an ELF file containing embedded dtrace program\n"
+					  "\t-g  output GraphViz Dot representation of script actions\n"
+					  "\t-h  generate a header file with definitions for static probes\n"
+					  "\t-H  print included files when invoking preprocessor\n"
+					  "\t-i  enable or list probes matching the specified probe id\n"
+					  "\t-I  add include directory to preprocessor search path\n"
+					  "\t-l  list probes matching specified criteria\n"
+					  "\t-L  add library directory to library search path\n"
+					  "\t-M  specify virtual-machine filters\n"
+					  "\t-m  enable or list probes matching the specified module name\n"
+					  "\t-n  enable or list probes matching the specified probe name\n"
+					  "\t-O  output format json|xml\n"
+					  "\t-o  set output file\n"
+					  "\t-p  grab specified process-ID and cache its symbol tables\n"
+					  "\t-P  enable or list probes matching the specified provider name\n"
+					  "\t-q  set quiet mode (only output explicitly traced data)\n"
+					  "\t-s  enable or list probes according to the specified D script\n"
+					  "\t-S  print D compiler intermediate code\n"
+					  "\t-U  undefine symbol when invoking preprocessor\n"
+					  "\t-v  set verbose mode (report stability attributes, arguments)\n"
+					  "\t-V  report DTrace API version\n"
+					  "\t-w  permit destructive actions\n"
+					  "\t-x  enable or modify compiler and tracing options\n"
+					  "\t-X  specify ISO C conformance settings for preprocessor\n"
+					  "\t-Z  permit probe descriptions that match zero probes\n"
+					  "\t-Y send D script to kernel\n");
 
 	return (E_USAGE);
 }
@@ -204,11 +238,11 @@ verror(const char *fmt, va_list ap)
 {
 	int error = errno;
 
-	(void) fprintf(stderr, "%s: ", g_pname);
-	(void) vfprintf(stderr, fmt, ap);
+	(void)fprintf(stderr, "%s: ", g_pname);
+	(void)vfprintf(stderr, fmt, ap);
 
 	if (fmt[strlen(fmt) - 1] != '\n')
-		(void) fprintf(stderr, ": %s\n", strerror(error));
+		(void)fprintf(stderr, ": %s\n", strerror(error));
 }
 
 /*PRINTFLIKE1*/
@@ -246,18 +280,21 @@ dfatal(const char *fmt, ...)
 
 	va_start(ap, fmt);
 
-	(void) fprintf(stderr, "%s: ", g_pname);
+	(void)fprintf(stderr, "%s: ", g_pname);
 	if (fmt != NULL)
-		(void) vfprintf(stderr, fmt, ap);
+		(void)vfprintf(stderr, fmt, ap);
 
 	va_end(ap);
 
-	if (fmt != NULL && fmt[strlen(fmt) - 1] != '\n') {
-		(void) fprintf(stderr, ": %s\n",
-		    dtrace_errmsg(g_dtp, dtrace_errno(g_dtp)));
-	} else if (fmt == NULL) {
-		(void) fprintf(stderr, "%s\n",
-		    dtrace_errmsg(g_dtp, dtrace_errno(g_dtp)));
+	if (fmt != NULL && fmt[strlen(fmt) - 1] != '\n')
+	{
+		(void)fprintf(stderr, ": %s\n",
+					  dtrace_errmsg(g_dtp, dtrace_errno(g_dtp)));
+	}
+	else if (fmt == NULL)
+	{
+		(void)fprintf(stderr, "%s\n",
+					  dtrace_errmsg(g_dtp, dtrace_errno(g_dtp)));
 	}
 #if !defined(illumos) && defined(NEED_ERRLOC)
 	dt_get_errloc(g_dtp, &p_errfile, &errline);
@@ -316,10 +353,12 @@ oprintf(const char *fmt, ...)
 	n = vfprintf(g_ofp, fmt, ap);
 	va_end(ap);
 
-	if (n < 0) {
-		if (errno != EINTR) {
+	if (n < 0)
+	{
+		if (errno != EINTR)
+		{
 			fatal("failed to write to %s",
-			    g_ofile ? g_ofile : "<stdout>");
+				  g_ofile ? g_ofile : "<stdout>");
 		}
 		clearerr(g_ofp);
 	}
@@ -329,7 +368,7 @@ static char **
 make_argv(char *s)
 {
 	const char *ws = "\f\n\r\t\v ";
-	char **argv = malloc(sizeof (char *) * (strlen(s) / 2 + 1));
+	char **argv = malloc(sizeof(char *) * (strlen(s) / 2 + 1));
 	int argc = 0;
 	char *p = s;
 
@@ -354,7 +393,8 @@ dof_prune(const char *fname)
 	char *buf;
 	int msg = 0, fd;
 
-	if ((fd = open(fname, O_RDONLY)) == -1) {
+	if ((fd = open(fname, O_RDONLY)) == -1)
+	{
 		/*
 		 * This is okay only if the file doesn't exist at all.
 		 */
@@ -373,14 +413,15 @@ dof_prune(const char *fname)
 		fatal("failed to read %s", fname);
 
 	buf[sz] = '\0';
-	(void) close(fd);
+	(void)close(fd);
 
 	if ((fd = open(fname, O_WRONLY | O_TRUNC)) == -1)
 		fatal("failed to open %s for writing", fname);
 
 	len = strlen("dof-data-");
 
-	for (mark = 0, i = 0; i < sz; i++) {
+	for (mark = 0, i = 0; i < sz; i++)
+	{
 		if (strncmp(&buf[i], "dof-data-", len) != 0)
 			continue;
 
@@ -390,15 +431,18 @@ dof_prune(const char *fname)
 		if (i != 0 && buf[i - 1] != '\n')
 			continue;
 
-		if (msg++ == 0) {
+		if (msg++ == 0)
+		{
 			error("cleaned up old anonymous "
-			    "enabling in %s\n", fname);
+				  "enabling in %s\n",
+				  fname);
 		}
 
 		/*
 		 * We have a match.  First write out our data up until now.
 		 */
-		if (i != mark) {
+		if (i != mark)
+		{
 			if (write(fd, &buf[mark], i - mark) != i - mark)
 				fatal("failed to write to %s", fname);
 		}
@@ -418,12 +462,13 @@ dof_prune(const char *fname)
 		i = j;
 	}
 
-	if (mark < sz) {
+	if (mark < sz)
+	{
 		if (write(fd, &buf[mark], sz - mark) != sz - mark)
 			fatal("failed to write to %s", fname);
 	}
 
-	(void) close(fd);
+	(void)close(fd);
 	free(buf);
 }
 
@@ -436,27 +481,34 @@ dof_prune(const char *fname)
 static void
 bootdof_add(void)
 {
-	char * const nbargv[] = {
-		"nextboot", "-a",
-		"-e", "dtraceall_load=\"YES\"",
-		"-e", "dtrace_dof_load=\"YES\"",
-		"-e", "dtrace_dof_name=\"/boot/dtrace.dof\"",
-		"-e", "dtrace_dof_type=\"dtrace_dof\"",
+	char *const nbargv[] = {
+		"nextboot",
+		"-a",
+		"-e",
+		"dtraceall_load=\"YES\"",
+		"-e",
+		"dtrace_dof_load=\"YES\"",
+		"-e",
+		"dtrace_dof_name=\"/boot/dtrace.dof\"",
+		"-e",
+		"dtrace_dof_type=\"dtrace_dof\"",
 		NULL,
 	};
 	pid_t child;
 	int err, status;
 
 	err = posix_spawnp(&child, "nextboot", NULL, NULL, nbargv,
-	    NULL);
-	if (err != 0) {
+					   NULL);
+	if (err != 0)
+	{
 		error("failed to execute nextboot: %s", strerror(err));
 		exit(E_ERROR);
 	}
 
 	if (waitpid(child, &status, 0) != child)
 		fatal("waiting for nextboot");
-	if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
+	if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
+	{
 		error("nextboot returned with status %d", status);
 		exit(E_ERROR);
 	}
@@ -484,52 +536,62 @@ etcsystem_prune(void)
 		fatal("failed to read %s", fname);
 
 	buf[sz] = '\0';
-	(void) close(fd);
+	(void)close(fd);
 
 	if ((start = strstr(buf, g_etcbegin)) == NULL)
 		goto out;
 
-	if (strlen(buf) != sz) {
+	if (strlen(buf) != sz)
+	{
 		fatal("embedded nul byte in %s; manual repair of %s "
-		    "required\n", fname, fname);
+			  "required\n",
+			  fname, fname);
 	}
 
-	if (strstr(start + 1, g_etcbegin) != NULL) {
+	if (strstr(start + 1, g_etcbegin) != NULL)
+	{
 		fatal("multiple start sentinels in %s; manual repair of %s "
-		    "required\n", fname, fname);
+			  "required\n",
+			  fname, fname);
 	}
 
-	if ((end = strstr(buf, g_etcend)) == NULL) {
+	if ((end = strstr(buf, g_etcend)) == NULL)
+	{
 		fatal("missing end sentinel in %s; manual repair of %s "
-		    "required\n", fname, fname);
+			  "required\n",
+			  fname, fname);
 	}
 
-	if (start > end) {
+	if (start > end)
+	{
 		fatal("end sentinel preceeds start sentinel in %s; manual "
-		    "repair of %s required\n", fname, fname);
+			  "repair of %s required\n",
+			  fname, fname);
 	}
 
 	end += strlen(g_etcend) + 1;
 	bcopy(end, start, strlen(end) + 1);
 
 	tmpname = alloca(sz = strlen(fname) + 80);
-	(void) snprintf(tmpname, sz, "%s.dtrace.%d", fname, getpid());
+	(void)snprintf(tmpname, sz, "%s.dtrace.%d", fname, getpid());
 
 	if ((fd = open(tmpname,
-	    O_WRONLY | O_CREAT | O_EXCL, sbuf.st_mode)) == -1)
+				   O_WRONLY | O_CREAT | O_EXCL, sbuf.st_mode)) == -1)
 		fatal("failed to create %s", tmpname);
 
-	if (write(fd, buf, strlen(buf)) < strlen(buf)) {
-		(void) unlink(tmpname);
+	if (write(fd, buf, strlen(buf)) < strlen(buf))
+	{
+		(void)unlink(tmpname);
 		fatal("failed to write to %s", tmpname);
 	}
 
-	(void) close(fd);
+	(void)close(fd);
 
-	if (chown(tmpname, sbuf.st_uid, sbuf.st_gid) != 0) {
-		(void) unlink(tmpname);
+	if (chown(tmpname, sbuf.st_uid, sbuf.st_gid) != 0)
+	{
+		(void)unlink(tmpname);
 		fatal("failed to chown(2) %s to uid %d, gid %d", tmpname,
-		    (int)sbuf.st_uid, (int)sbuf.st_gid);
+			  (int)sbuf.st_uid, (int)sbuf.st_gid);
 	}
 
 	if (rename(tmpname, fname) == -1)
@@ -555,9 +617,9 @@ etcsystem_add(void)
 		oprintf("%s\n", g_etc[line]);
 
 	nmods = dtrace_provider_modules(g_dtp, mods,
-	    sizeof (mods) / sizeof (char *) - 1);
+									sizeof(mods) / sizeof(char *) - 1);
 
-	if (nmods >= sizeof (mods) / sizeof (char *))
+	if (nmods >= sizeof(mods) / sizeof(char *))
 		fatal("unexpectedly large number of modules!");
 
 	mods[nmods++] = "dtrace";
@@ -584,31 +646,32 @@ print_probe_info(const dtrace_probeinfo_t *p)
 	oprintf("\n\tProbe Description Attributes\n");
 
 	oprintf("\t\tIdentifier Names: %s\n",
-	    dtrace_stability_name(p->dtp_attr.dtat_name));
+			dtrace_stability_name(p->dtp_attr.dtat_name));
 	oprintf("\t\tData Semantics:   %s\n",
-	    dtrace_stability_name(p->dtp_attr.dtat_data));
+			dtrace_stability_name(p->dtp_attr.dtat_data));
 	oprintf("\t\tDependency Class: %s\n",
-	    dtrace_class_name(p->dtp_attr.dtat_class));
+			dtrace_class_name(p->dtp_attr.dtat_class));
 
 	oprintf("\n\tArgument Attributes\n");
 
 	oprintf("\t\tIdentifier Names: %s\n",
-	    dtrace_stability_name(p->dtp_arga.dtat_name));
+			dtrace_stability_name(p->dtp_arga.dtat_name));
 	oprintf("\t\tData Semantics:   %s\n",
-	    dtrace_stability_name(p->dtp_arga.dtat_data));
+			dtrace_stability_name(p->dtp_arga.dtat_data));
 	oprintf("\t\tDependency Class: %s\n",
-	    dtrace_class_name(p->dtp_arga.dtat_class));
+			dtrace_class_name(p->dtp_arga.dtat_class));
 
 	oprintf("\n\tArgument Types\n");
 
-	for (i = 0; i < p->dtp_argc; i++) {
+	for (i = 0; i < p->dtp_argc; i++)
+	{
 		if (p->dtp_argv[i].dtt_flags & DTT_FL_USER)
 			user = "userland ";
 		else
 			user = "";
 		if (ctf_type_name(p->dtp_argv[i].dtt_ctfp,
-		    p->dtp_argv[i].dtt_type, buf, sizeof (buf)) == NULL)
-			(void) strlcpy(buf, "(unknown)", sizeof (buf));
+						  p->dtp_argv[i].dtt_type, buf, sizeof(buf)) == NULL)
+			(void)strlcpy(buf, "(unknown)", sizeof(buf));
 		oprintf("\t\targs[%d]: %s%s\n", i, user, buf);
 	}
 
@@ -621,7 +684,7 @@ print_probe_info(const dtrace_probeinfo_t *p)
 /*ARGSUSED*/
 static int
 info_stmt(dtrace_hdl_t *dtp, dtrace_prog_t *pgp,
-    dtrace_stmtdesc_t *stp, dtrace_ecbdesc_t **last)
+		  dtrace_stmtdesc_t *stp, dtrace_ecbdesc_t **last)
 {
 	dtrace_ecbdesc_t *edp = stp->dtsd_ecbdesc;
 	dtrace_probedesc_t *pdp = &edp->dted_probe;
@@ -631,7 +694,7 @@ info_stmt(dtrace_hdl_t *dtp, dtrace_prog_t *pgp,
 		return (0);
 
 	oprintf("\n%s:%s:%s:%s\n",
-	    pdp->dtpd_provider, pdp->dtpd_mod, pdp->dtpd_func, pdp->dtpd_name);
+			pdp->dtpd_provider, pdp->dtpd_mod, pdp->dtpd_func, pdp->dtpd_name);
 
 	if (dtrace_probe_info(dtp, pdp, &p) == 0)
 		print_probe_info(&p);
@@ -642,18 +705,20 @@ info_stmt(dtrace_hdl_t *dtp, dtrace_prog_t *pgp,
 
 static bool
 checkmodref(int action_modref, int cumulative_modref,
-	     const dtrace_probedesc_t *dp, FILE *output)
+			const dtrace_probedesc_t *dp, FILE *output)
 {
 
-	if ((cumulative_modref & DTRACE_MODREF_ANY_MOD) == 0) {
+	if ((cumulative_modref & DTRACE_MODREF_ANY_MOD) == 0)
+	{
 		// We don't care about pre-modification behaviour.
 		return (true);
 	}
 
-	if (action_modref & DTRACE_MODREF_ANY_REF) {
+	if (action_modref & DTRACE_MODREF_ANY_REF)
+	{
 		fprintf(output, "ref-after-mod in %s:%s:%s:%s:",
-			dp->dtpd_provider, dp->dtpd_mod, dp->dtpd_func,
-			dp->dtpd_name);
+				dp->dtpd_provider, dp->dtpd_mod, dp->dtpd_func,
+				dp->dtpd_name);
 		if (action_modref & DTRACE_MODREF_GLOBAL_REF)
 			fprintf(output, " global");
 		if (action_modref & DTRACE_MODREF_THREAD_LOCAL_REF)
@@ -685,14 +750,16 @@ exec_prog(const dtrace_cmd_t *dcp)
 
 	// Don't take any action based on unwanted mod/ref behaviour:
 	// checkmodref emits warnings and that's the end of it.
-	(void) dtrace_analyze_program_modref(dcp->dc_prog, checkmodref, stderr);
-	(void) dtrace_dump_actions(dcp->dc_prog);
+	(void)dtrace_analyze_program_modref(dcp->dc_prog, checkmodref, stderr);
+	(void)dtrace_dump_actions(dcp->dc_prog);
 
-	if (g_graphfile) {
+	if (g_graphfile)
+	{
 		FILE *graph_file = fopen(g_graphfile, "w");
-		if (graph_file == NULL) {
+		if (graph_file == NULL)
+		{
 			fprintf(stderr, "Failed to open %s for writing\n",
-				g_graphfile);
+					g_graphfile);
 			return;
 		}
 
@@ -700,41 +767,49 @@ exec_prog(const dtrace_cmd_t *dcp)
 		fclose(graph_file);
 	}
 
-	if (!g_exec) {
+	if (!g_exec)
+	{
 		dtrace_program_info(g_dtp, dcp->dc_prog, &dpi);
-	} else if (dtrace_program_exec(g_dtp, dcp->dc_prog, &dpi) == -1) {
+	}
+	else if (dtrace_program_exec(g_dtp, dcp->dc_prog, &dpi) == -1)
+	{
 		dfatal("failed to enable '%s'", dcp->dc_name);
-	} else {
+	}
+	else
+	{
 		notice("%s '%s' matched %u probe%s\n",
-		    dcp->dc_desc, dcp->dc_name,
-		    dpi.dpi_matches, dpi.dpi_matches == 1 ? "" : "s");
+			   dcp->dc_desc, dcp->dc_name,
+			   dpi.dpi_matches, dpi.dpi_matches == 1 ? "" : "s");
 	}
 
-	if (g_verbose) {
+	if (g_verbose)
+	{
 		oprintf("\nStability attributes for %s %s:\n",
-		    dcp->dc_desc, dcp->dc_name);
+				dcp->dc_desc, dcp->dc_name);
 
 		oprintf("\n\tMinimum Probe Description Attributes\n");
 		oprintf("\t\tIdentifier Names: %s\n",
-		    dtrace_stability_name(dpi.dpi_descattr.dtat_name));
+				dtrace_stability_name(dpi.dpi_descattr.dtat_name));
 		oprintf("\t\tData Semantics:   %s\n",
-		    dtrace_stability_name(dpi.dpi_descattr.dtat_data));
+				dtrace_stability_name(dpi.dpi_descattr.dtat_data));
 		oprintf("\t\tDependency Class: %s\n",
-		    dtrace_class_name(dpi.dpi_descattr.dtat_class));
+				dtrace_class_name(dpi.dpi_descattr.dtat_class));
 
 		oprintf("\n\tMinimum Statement Attributes\n");
 
 		oprintf("\t\tIdentifier Names: %s\n",
-		    dtrace_stability_name(dpi.dpi_stmtattr.dtat_name));
+				dtrace_stability_name(dpi.dpi_stmtattr.dtat_name));
 		oprintf("\t\tData Semantics:   %s\n",
-		    dtrace_stability_name(dpi.dpi_stmtattr.dtat_data));
+				dtrace_stability_name(dpi.dpi_stmtattr.dtat_data));
 		oprintf("\t\tDependency Class: %s\n",
-		    dtrace_class_name(dpi.dpi_stmtattr.dtat_class));
+				dtrace_class_name(dpi.dpi_stmtattr.dtat_class));
 
-		if (!g_exec) {
-			(void) dtrace_stmt_iter(g_dtp, dcp->dc_prog,
-			    (dtrace_stmt_f *)info_stmt, &last);
-		} else
+		if (!g_exec)
+		{
+			(void)dtrace_stmt_iter(g_dtp, dcp->dc_prog,
+								   (dtrace_stmt_f *)info_stmt, &last);
+		}
+		else
 			oprintf("\n");
 	}
 
@@ -791,23 +866,30 @@ link_prog(dtrace_cmd_t *dcp)
 {
 	char *p;
 
-	if (g_cmdc == 1 && g_ofile != NULL) {
-		(void) strlcpy(dcp->dc_ofile, g_ofile, sizeof (dcp->dc_ofile));
-	} else if ((p = strrchr(dcp->dc_arg, '.')) != NULL &&
-	    strcmp(p, ".d") == 0) {
+	if (g_cmdc == 1 && g_ofile != NULL)
+	{
+		(void)strlcpy(dcp->dc_ofile, g_ofile, sizeof(dcp->dc_ofile));
+	}
+	else if ((p = strrchr(dcp->dc_arg, '.')) != NULL &&
+			 strcmp(p, ".d") == 0)
+	{
 		p[0] = '\0'; /* strip .d suffix */
-		(void) snprintf(dcp->dc_ofile, sizeof (dcp->dc_ofile),
-		    "%s.o", basename(dcp->dc_arg));
-	} else if (g_cmdc > 1) {
-		(void) snprintf(dcp->dc_ofile, sizeof (dcp->dc_ofile),
-		    "d.out.%td", dcp - g_cmdv);
-	} else {
-		(void) snprintf(dcp->dc_ofile, sizeof (dcp->dc_ofile),
-		    "d.out");
+		(void)snprintf(dcp->dc_ofile, sizeof(dcp->dc_ofile),
+					   "%s.o", basename(dcp->dc_arg));
+	}
+	else if (g_cmdc > 1)
+	{
+		(void)snprintf(dcp->dc_ofile, sizeof(dcp->dc_ofile),
+					   "d.out.%td", dcp - g_cmdv);
+	}
+	else
+	{
+		(void)snprintf(dcp->dc_ofile, sizeof(dcp->dc_ofile),
+					   "d.out");
 	}
 
 	if (dtrace_program_link(g_dtp, dcp->dc_prog, DTRACE_D_PROBES,
-	    dcp->dc_ofile, g_objc, g_objv) != 0)
+							dcp->dc_ofile, g_objc, g_objv) != 0)
 		dfatal("failed to link %s %s", dcp->dc_desc, dcp->dc_name);
 }
 
@@ -818,7 +900,7 @@ list_probe(dtrace_hdl_t *dtp, const dtrace_probedesc_t *pdp, void *arg)
 	dtrace_probeinfo_t p;
 
 	oprintf("%5d %10s %17s %33s %s\n", pdp->dtpd_id,
-	    pdp->dtpd_provider, pdp->dtpd_mod, pdp->dtpd_func, pdp->dtpd_name);
+			pdp->dtpd_provider, pdp->dtpd_mod, pdp->dtpd_func, pdp->dtpd_name);
 
 	if (g_verbose && dtrace_probe_info(dtp, pdp, &p) == 0)
 		print_probe_info(&p);
@@ -832,18 +914,19 @@ list_probe(dtrace_hdl_t *dtp, const dtrace_probedesc_t *pdp, void *arg)
 /*ARGSUSED*/
 static int
 list_stmt(dtrace_hdl_t *dtp, dtrace_prog_t *pgp,
-    dtrace_stmtdesc_t *stp, dtrace_ecbdesc_t **last)
+		  dtrace_stmtdesc_t *stp, dtrace_ecbdesc_t **last)
 {
 	dtrace_ecbdesc_t *edp = stp->dtsd_ecbdesc;
 
 	if (edp == *last)
 		return (0);
 
-	if (dtrace_probe_iter(g_dtp, &edp->dted_probe, list_probe, NULL) != 0) {
+	if (dtrace_probe_iter(g_dtp, &edp->dted_probe, list_probe, NULL) != 0)
+	{
 		error("failed to match %s:%s:%s:%s: %s\n",
-		    edp->dted_probe.dtpd_provider, edp->dted_probe.dtpd_mod,
-		    edp->dted_probe.dtpd_func, edp->dted_probe.dtpd_name,
-		    dtrace_errmsg(dtp, dtrace_errno(dtp)));
+			  edp->dted_probe.dtpd_provider, edp->dted_probe.dtpd_mod,
+			  edp->dted_probe.dtpd_func, edp->dted_probe.dtpd_name,
+			  dtrace_errmsg(dtp, dtrace_errno(dtp)));
 	}
 
 	*last = edp;
@@ -859,8 +942,8 @@ list_prog(const dtrace_cmd_t *dcp)
 {
 	dtrace_ecbdesc_t *last = NULL;
 
-	(void) dtrace_stmt_iter(g_dtp, dcp->dc_prog,
-	    (dtrace_stmt_f *)list_stmt, &last);
+	(void)dtrace_stmt_iter(g_dtp, dcp->dc_prog,
+						   (dtrace_stmt_f *)list_stmt, &last);
 }
 
 static void
@@ -876,11 +959,11 @@ compile_file(dtrace_cmd_t *dcp)
 	g_argv[0] = dcp->dc_arg;
 
 	if ((dcp->dc_prog = dtrace_program_fcompile(g_dtp, fp,
-	    g_cflags, g_argc, g_argv)) == NULL)
+												g_cflags, g_argc, g_argv)) == NULL)
 		dfatal("failed to compile script %s", dcp->dc_arg);
 
 	g_argv[0] = arg0;
-	(void) fclose(fp);
+	(void)fclose(fp);
 
 	dcp->dc_desc = "script";
 	dcp->dc_name = dcp->dc_arg;
@@ -892,7 +975,7 @@ compile_str(dtrace_cmd_t *dcp)
 	char *p;
 
 	if ((dcp->dc_prog = dtrace_program_strcompile(g_dtp, dcp->dc_arg,
-	    dcp->dc_spec, g_cflags | DTRACE_C_PSPEC, g_argc, g_argv)) == NULL)
+												  dcp->dc_spec, g_cflags | DTRACE_C_PSPEC, g_argc, g_argv)) == NULL)
 		dfatal("invalid probe specifier %s", dcp->dc_arg);
 
 	if ((p = strpbrk(dcp->dc_arg, "{/;")) != NULL)
@@ -915,15 +998,18 @@ prochandler(struct ps_prochandle *P, const char *msg, void *arg)
 	int pid = proc_getpid(P);
 #endif
 
-	if (msg != NULL) {
+	if (msg != NULL)
+	{
 		notice("pid %d: %s\n", pid, msg);
 		return;
 	}
 
 #ifdef illumos
-	switch (Pstate(P)) {
+	switch (Pstate(P))
+	{
 #else
-	switch (proc_state(P)) {
+	switch (proc_state(P))
+	{
 #endif
 	case PS_UNDEAD:
 #ifdef illumos
@@ -935,25 +1021,33 @@ prochandler(struct ps_prochandle *P, const char *msg, void *arg)
 		 * When /proc provides a stable pr_wstat in the status file,
 		 * this code can be improved by examining this new pr_wstat.
 		 */
-		if (prp != NULL && WIFSIGNALED(prp->pr_wstat)) {
+		if (prp != NULL && WIFSIGNALED(prp->pr_wstat))
+		{
 			notice("pid %d terminated by %s\n", pid,
-			    proc_signame(WTERMSIG(prp->pr_wstat),
-			    name, sizeof (name)));
+				   proc_signame(WTERMSIG(prp->pr_wstat),
+								name, sizeof(name)));
 #else
-		if (WIFSIGNALED(wstatus)) {
+		if (WIFSIGNALED(wstatus))
+		{
 			notice("pid %d terminated by %d\n", pid,
-			    WTERMSIG(wstatus));
+				   WTERMSIG(wstatus));
 #endif
 #ifdef illumos
-		} else if (prp != NULL && WEXITSTATUS(prp->pr_wstat) != 0) {
+		}
+		else if (prp != NULL && WEXITSTATUS(prp->pr_wstat) != 0)
+		{
 			notice("pid %d exited with status %d\n",
-			    pid, WEXITSTATUS(prp->pr_wstat));
+				   pid, WEXITSTATUS(prp->pr_wstat));
 #else
-		} else if (WEXITSTATUS(wstatus) != 0) {
+		}
+		else if (WEXITSTATUS(wstatus) != 0)
+		{
 			notice("pid %d exited with status %d\n",
-			    pid, WEXITSTATUS(wstatus));
+				   pid, WEXITSTATUS(wstatus));
 #endif
-		} else {
+		}
+		else
+		{
 			notice("pid %d has exited\n", pid);
 		}
 		g_pslive--;
@@ -995,37 +1089,42 @@ setopthandler(const dtrace_setoptdata_t *data, void *arg)
 	return (DTRACE_HANDLE_OK);
 }
 
-#define	BUFDUMPHDR(hdr) \
-	(void) printf("%s: %s%s\n", g_pname, hdr, strlen(hdr) > 0 ? ":" : "");
-
-#define	BUFDUMPSTR(ptr, field) \
-	(void) printf("%s: %20s => ", g_pname, #field);	\
-	if ((ptr)->field != NULL) {			\
-		const char *c = (ptr)->field;		\
-		(void) printf("\"");			\
-		do {					\
-			if (*c == '\n') {		\
-				(void) printf("\\n");	\
-				continue;		\
-			}				\
-							\
-			(void) printf("%c", *c);	\
-		} while (*c++ != '\0');			\
-		(void) printf("\"\n");			\
-	} else {					\
-		(void) printf("<NULL>\n");		\
-	}
-
-#define	BUFDUMPASSTR(ptr, field, str) \
-	(void) printf("%s: %20s => %s\n", g_pname, #field, str);
-
-#define	BUFDUMP(ptr, field) \
-	(void) printf("%s: %20s => %lld\n", g_pname, #field, \
-	    (long long)(ptr)->field);
-
-#define	BUFDUMPPTR(ptr, field) \
-	(void) printf("%s: %20s => %s\n", g_pname, #field, \
-	    (ptr)->field != NULL ? "<non-NULL>" : "<NULL>");
+#define BUFDUMPHDR(hdr) \
+	(void)printf("%s: %s%s\n", g_pname, hdr, strlen(hdr) > 0 ? ":" : "");
+
+#define BUFDUMPSTR(ptr, field)                     \
+	(void)printf("%s: %20s => ", g_pname, #field); \
+	if ((ptr)->field != NULL)                      \
+	{                                              \
+		const char *c = (ptr)->field;              \
+		(void)printf("\"");                        \
+		do                                         \
+		{                                          \
+			if (*c == '\n')                        \
+			{                                      \
+				(void)printf("\\n");               \
+				continue;                          \
+			}                                      \
+                                                   \
+			(void)printf("%c", *c);                \
+		} while (*c++ != '\0');                    \
+		(void)printf("\"\n");                      \
+	}                                              \
+	else                                           \
+	{                                              \
+		(void)printf("<NULL>\n");                  \
+	}
+
+#define BUFDUMPASSTR(ptr, field, str) \
+	(void)printf("%s: %20s => %s\n", g_pname, #field, str);
+
+#define BUFDUMP(ptr, field)                             \
+	(void)printf("%s: %20s => %lld\n", g_pname, #field, \
+				 (long long)(ptr)->field);
+
+#define BUFDUMPPTR(ptr, field)                        \
+	(void)printf("%s: %20s => %s\n", g_pname, #field, \
+				 (ptr)->field != NULL ? "<non-NULL>" : "<NULL>");
 
 /*ARGSUSED*/
 static int
@@ -1035,26 +1134,31 @@ bufhandler(const dtrace_bufdata_t *bufdata, void *arg)
 	const dtrace_recdesc_t *rec = bufdata->dtbda_recdesc;
 	const dtrace_probedesc_t *pd;
 	uint32_t flags = bufdata->dtbda_flags;
-	char buf[512], *c = buf, *end = c + sizeof (buf);
+	char buf[512], *c = buf, *end = c + sizeof(buf);
 	int i, printed;
 
-	struct {
+	struct
+	{
 		const char *name;
 		uint32_t value;
 	} flagnames[] = {
-	    { "AGGVAL",		DTRACE_BUFDATA_AGGVAL },
-	    { "AGGKEY",		DTRACE_BUFDATA_AGGKEY },
-	    { "AGGFORMAT",	DTRACE_BUFDATA_AGGFORMAT },
-	    { "AGGLAST",	DTRACE_BUFDATA_AGGLAST },
-	    { "???",		UINT32_MAX },
-	    { NULL }
-	};
-
-	if (bufdata->dtbda_probe != NULL) {
+		{"AGGVAL", DTRACE_BUFDATA_AGGVAL},
+		{"AGGKEY", DTRACE_BUFDATA_AGGKEY},
+		{"AGGFORMAT", DTRACE_BUFDATA_AGGFORMAT},
+		{"AGGLAST", DTRACE_BUFDATA_AGGLAST},
+		{"???", UINT32_MAX},
+		{NULL}};
+
+	if (bufdata->dtbda_probe != NULL)
+	{
 		pd = bufdata->dtbda_probe->dtpda_pdesc;
-	} else if (agg != NULL) {
+	}
+	else if (agg != NULL)
+	{
 		pd = agg->dtada_pdesc;
-	} else {
+	}
+	else
+	{
 		pd = NULL;
 	}
 
@@ -1067,26 +1171,28 @@ bufhandler(const dtrace_bufdata_t *bufdata, void *arg)
 	BUFDUMPPTR(bufdata, dtbda_aggdata);
 	BUFDUMPPTR(bufdata, dtbda_recdesc);
 
-	(void) snprintf(c, end - c, "0x%x ", bufdata->dtbda_flags);
+	(void)snprintf(c, end - c, "0x%x ", bufdata->dtbda_flags);
 	c += strlen(c);
 
-	for (i = 0, printed = 0; flagnames[i].name != NULL; i++) {
+	for (i = 0, printed = 0; flagnames[i].name != NULL; i++)
+	{
 		if (!(flags & flagnames[i].value))
 			continue;
 
-		(void) snprintf(c, end - c,
-		    "%s%s", printed++ ? " | " : "(", flagnames[i].name);
+		(void)snprintf(c, end - c,
+					   "%s%s", printed++ ? " | " : "(", flagnames[i].name);
 		c += strlen(c);
 		flags &= ~flagnames[i].value;
 	}
 
 	if (printed)
-		(void) snprintf(c, end - c, ")");
+		(void)snprintf(c, end - c, ")");
 
 	BUFDUMPASSTR(bufdata, dtbda_flags, buf);
 	BUFDUMPHDR("");
 
-	if (pd != NULL) {
+	if (pd != NULL)
+	{
 		BUFDUMPHDR("  dtrace_probedesc");
 		BUFDUMPSTR(pd, dtpd_provider);
 		BUFDUMPSTR(pd, dtpd_mod);
@@ -1095,40 +1201,46 @@ bufhandler(const dtrace_bufdata_t *bufdata, void *arg)
 		BUFDUMPHDR("");
 	}
 
-	if (rec != NULL) {
+	if (rec != NULL)
+	{
 		BUFDUMPHDR("  dtrace_recdesc");
 		BUFDUMP(rec, dtrd_action);
 		BUFDUMP(rec, dtrd_size);
 
-		if (agg != NULL) {
+		if (agg != NULL)
+		{
 			uint8_t *data;
 			int lim = rec->dtrd_size;
 
-			(void) sprintf(buf, "%d (data: ", rec->dtrd_offset);
+			(void)sprintf(buf, "%d (data: ", rec->dtrd_offset);
 			c = buf + strlen(buf);
 
-			if (lim > sizeof (uint64_t))
-				lim = sizeof (uint64_t);
+			if (lim > sizeof(uint64_t))
+				lim = sizeof(uint64_t);
 
 			data = (uint8_t *)agg->dtada_data + rec->dtrd_offset;
 
-			for (i = 0; i < lim; i++) {
-				(void) snprintf(c, end - c, "%s%02x",
-				    i == 0 ? "" : " ", *data++);
+			for (i = 0; i < lim; i++)
+			{
+				(void)snprintf(c, end - c, "%s%02x",
+							   i == 0 ? "" : " ", *data++);
 				c += strlen(c);
 			}
 
-			(void) snprintf(c, end - c,
-			    "%s)", lim < rec->dtrd_size ? " ..." : "");
+			(void)snprintf(c, end - c,
+						   "%s)", lim < rec->dtrd_size ? " ..." : "");
 			BUFDUMPASSTR(rec, dtrd_offset, buf);
-		} else {
+		}
+		else
+		{
 			BUFDUMP(rec, dtrd_offset);
 		}
 
 		BUFDUMPHDR("");
 	}
 
-	if (agg != NULL) {
+	if (agg != NULL)
+	{
 		dtrace_aggdesc_t *desc = agg->dtada_desc;
 
 		BUFDUMPHDR("  dtrace_aggdesc");
@@ -1149,7 +1261,8 @@ chewrec(const dtrace_probedata_t *data, const dtrace_recdesc_t *rec, void *arg)
 	dtrace_actkind_t act;
 	uintptr_t addr;
 
-	if (rec == NULL) {
+	if (rec == NULL)
+	{
 		/*
 		 * We have processed the final record; output the newline if
 		 * we're not in quiet mode.
@@ -1163,11 +1276,13 @@ chewrec(const dtrace_probedata_t *data, const dtrace_recdesc_t *rec, void *arg)
 	act = rec->dtrd_action;
 	addr = (uintptr_t)data->dtpda_data;
 
-	if (act == DTRACEACT_EXIT) {
+	if (act == DTRACEACT_EXIT)
+	{
 		g_status = *((uint32_t *)addr);
 		return (DTRACE_CONSUME_NEXT);
 	}
 
+	// printf("I am consuming this.");
 	return (DTRACE_CONSUME_THIS);
 }
 
@@ -1175,67 +1290,99 @@ chewrec(const dtrace_probedata_t *data, const dtrace_recdesc_t *rec, void *arg)
 static int
 chew(const dtrace_probedata_t *data, void *arg)
 {
+	
+
 	dtrace_probedesc_t *pd = data->dtpda_pdesc;
 	processorid_t cpu = data->dtpda_cpu;
 	static int heading;
-
-	if (g_impatient) {
+	if (idx <= 1000)
+	{
+		gettimeofday(&ts, NULL);
+		printf("Record time: %ld s %ld us \n", ts.tv_sec, ts.tv_usec);
+		fprintf(logging_fp, "%ld s %ld us\n", ts.tv_sec, ts.tv_usec);
+		fflush(logging_fp);
+		idx++;
+	}
+	if (idx == 1000)
+	{
+		printf("FINISHED");
+		fflush(logging_fp);
+		fclose(logging_fp);
+		exit(0);
+	}
+	if (g_impatient)
+	{
 		g_newline = 0;
 		return (DTRACE_CONSUME_ABORT);
 	}
 
-	if (heading == 0) {
-		if (!g_flowindent) {
-			if (!g_quiet) {
+	if (heading == 0)
+	{
+		if (!g_flowindent)
+		{
+			if (!g_quiet)
+			{
 				oprintf("%3s %6s %32s\n",
-				    "CPU", "ID", "FUNCTION:NAME");
+						"CPU", "ID", "FUNCTION:NAME");
 			}
-		} else {
+		}
+		else
+		{
 			oprintf("%3s %-41s\n", "CPU", "FUNCTION");
 		}
 		heading = 1;
 	}
 
-	if (!g_flowindent) {
-		if (!g_quiet) {
-			if (g_oformat) {
+	if (!g_flowindent)
+	{
+		if (!g_quiet)
+		{
+			if (g_oformat)
+			{
 				xo_open_container("probe");
 				xo_emit("{:timestamp/%U} {:cpu/%d} {:id/%d} {:func/%s} {:name/%s}",
-				    data->dtpda_timestamp, cpu,
-				    pd->dtpd_id, pd->dtpd_func,
-				    pd->dtpd_name);
+						data->dtpda_timestamp, cpu,
+						pd->dtpd_id, pd->dtpd_func,
+						pd->dtpd_name);
 				xo_close_container("probe");
 				xo_flush();
-			} else {
+			}
+			else
+			{
 				char name[DTRACE_FUNCNAMELEN + DTRACE_NAMELEN + 2];
 
-				(void) snprintf(name, sizeof (name), "%s:%s",
-				    pd->dtpd_func, pd->dtpd_name);
+				(void)snprintf(name, sizeof(name), "%s:%s",
+							   pd->dtpd_func, pd->dtpd_name);
 
 				oprintf("%3d %6d %32s ", cpu, pd->dtpd_id, name);
 			}
 		}
-	} else {
+	}
+	else
+	{
 		int indent = data->dtpda_indent;
 		char *name;
 		size_t len;
 
-		if (data->dtpda_flow == DTRACEFLOW_NONE) {
+		if (data->dtpda_flow == DTRACEFLOW_NONE)
+		{
 			len = indent + DTRACE_FUNCNAMELEN + DTRACE_NAMELEN + 5;
 			name = alloca(len);
-			(void) snprintf(name, len, "%*s%s%s:%s", indent, "",
-			    data->dtpda_prefix, pd->dtpd_func,
-			    pd->dtpd_name);
-		} else {
+			(void)snprintf(name, len, "%*s%s%s:%s", indent, "",
+						   data->dtpda_prefix, pd->dtpd_func,
+						   pd->dtpd_name);
+		}
+		else
+		{
 			len = indent + DTRACE_FUNCNAMELEN + 5;
 			name = alloca(len);
-			(void) snprintf(name, len, "%*s%s%s", indent, "",
-			    data->dtpda_prefix, pd->dtpd_func);
+			(void)snprintf(name, len, "%*s%s%s", indent, "",
+						   data->dtpda_prefix, pd->dtpd_func);
 		}
 
 		oprintf("%3d %-41s ", cpu, name);
 	}
-
+	printf("\n");
 	return (DTRACE_CONSUME_THIS);
 }
 
@@ -1244,28 +1391,27 @@ go(void)
 {
 	int i;
 
-	struct {
+	struct
+	{
 		char *name;
 		char *optname;
 		dtrace_optval_t val;
 	} bufs[] = {
-		{ "buffer size", "bufsize" },
-		{ "aggregation size", "aggsize" },
-		{ "speculation size", "specsize" },
-		{ "dynamic variable size", "dynvarsize" },
-		{ NULL }
-	}, rates[] = {
-		{ "cleaning rate", "cleanrate" },
-		{ "status rate", "statusrate" },
-		{ NULL }
-	};
-
-	for (i = 0; bufs[i].name != NULL; i++) {
+		{"buffer size", "bufsize"},
+		{"aggregation size", "aggsize"},
+		{"speculation size", "specsize"},
+		{"dynamic variable size", "dynvarsize"},
+		{NULL}},
+	  rates[] = {{"cleaning rate", "cleanrate"}, {"status rate", "statusrate"}, {NULL}};
+
+	for (i = 0; bufs[i].name != NULL; i++)
+	{
 		if (dtrace_getopt(g_dtp, bufs[i].optname, &bufs[i].val) == -1)
 			fatal("couldn't get option %s", bufs[i].optname);
 	}
 
-	for (i = 0; rates[i].name != NULL; i++) {
+	for (i = 0; rates[i].name != NULL; i++)
+	{
 		if (dtrace_getopt(g_dtp, rates[i].optname, &rates[i].val) == -1)
 			fatal("couldn't get option %s", rates[i].optname);
 	}
@@ -1273,41 +1419,46 @@ go(void)
 	if (dtrace_go(g_dtp) == -1)
 		dfatal("could not enable tracing");
 
-	for (i = 0; bufs[i].name != NULL; i++) {
+	for (i = 0; bufs[i].name != NULL; i++)
+	{
 		dtrace_optval_t j = 0, mul = 10;
 		dtrace_optval_t nsize;
 
 		if (bufs[i].val == DTRACEOPT_UNSET)
 			continue;
 
-		(void) dtrace_getopt(g_dtp, bufs[i].optname, &nsize);
+		(void)dtrace_getopt(g_dtp, bufs[i].optname, &nsize);
 
 		if (nsize == DTRACEOPT_UNSET || nsize == 0)
 			continue;
 
-		if (nsize >= bufs[i].val - sizeof (uint64_t))
+		if (nsize >= bufs[i].val - sizeof(uint64_t))
 			continue;
 
 		for (; (INT64_C(1) << mul) <= nsize; j++, mul += 10)
 			continue;
 
-		if (!(nsize & ((INT64_C(1) << (mul - 10)) - 1))) {
+		if (!(nsize & ((INT64_C(1) << (mul - 10)) - 1)))
+		{
 			error("%s lowered to %lld%c\n", bufs[i].name,
-			    (long long)nsize >> (mul - 10), " kmgtpe"[j]);
-		} else {
+				  (long long)nsize >> (mul - 10), " kmgtpe"[j]);
+		}
+		else
+		{
 			error("%s lowered to %lld bytes\n", bufs[i].name,
-			    (long long)nsize);
+				  (long long)nsize);
 		}
 	}
 
-	for (i = 0; rates[i].name != NULL; i++) {
+	for (i = 0; rates[i].name != NULL; i++)
+	{
 		dtrace_optval_t nval;
 		char *dir;
 
 		if (rates[i].val == DTRACEOPT_UNSET)
 			continue;
 
-		(void) dtrace_getopt(g_dtp, rates[i].optname, &nval);
+		(void)dtrace_getopt(g_dtp, rates[i].optname, &nval);
 
 		if (nval == DTRACEOPT_UNSET || nval == 0)
 			continue;
@@ -1317,21 +1468,23 @@ go(void)
 
 		dir = nval > rates[i].val ? "reduced" : "increased";
 
-		if (nval <= NANOSEC && (NANOSEC % nval) == 0) {
+		if (nval <= NANOSEC && (NANOSEC % nval) == 0)
+		{
 			error("%s %s to %lld hz\n", rates[i].name, dir,
-			    (long long)NANOSEC / (long long)nval);
+				  (long long)NANOSEC / (long long)nval);
 			continue;
 		}
 
-		if ((nval % NANOSEC) == 0) {
+		if ((nval % NANOSEC) == 0)
+		{
 			error("%s %s to once every %lld seconds\n",
-			    rates[i].name, dir,
-			    (long long)nval / (long long)NANOSEC);
+				  rates[i].name, dir,
+				  (long long)nval / (long long)NANOSEC);
 			continue;
 		}
 
 		error("%s %s to once every %lld nanoseconds\n",
-		    rates[i].name, dir, (long long)nval);
+			  rates[i].name, dir, (long long)nval);
 	}
 }
 
@@ -1361,26 +1514,26 @@ installsighands(void)
 {
 	struct sigaction act, oact;
 
-	(void) sigemptyset(&act.sa_mask);
+	(void)sigemptyset(&act.sa_mask);
 	act.sa_flags = 0;
 	act.sa_handler = intr;
 
 	if (sigaction(SIGINT, NULL, &oact) == 0 && oact.sa_handler != SIG_IGN)
-		(void) sigaction(SIGINT, &act, NULL);
+		(void)sigaction(SIGINT, &act, NULL);
 
 	if (sigaction(SIGTERM, NULL, &oact) == 0 && oact.sa_handler != SIG_IGN)
-		(void) sigaction(SIGTERM, &act, NULL);
+		(void)sigaction(SIGTERM, &act, NULL);
 
 #ifdef __FreeBSD__
 	if (sigaction(SIGPIPE, NULL, &oact) == 0 && oact.sa_handler != SIG_IGN)
-		(void) sigaction(SIGPIPE, &act, NULL);
+		(void)sigaction(SIGPIPE, &act, NULL);
 
 	if (sigaction(SIGUSR1, NULL, &oact) == 0 && oact.sa_handler != SIG_IGN)
-		(void) sigaction(SIGUSR1, &act, NULL);
+		(void)sigaction(SIGUSR1, &act, NULL);
 
 	act.sa_handler = siginfo;
 	if (sigaction(SIGINFO, NULL, &oact) == 0 && oact.sa_handler != SIG_IGN)
-		(void) sigaction(SIGINFO, &act, NULL);
+		(void)sigaction(SIGINFO, &act, NULL);
 #endif
 }
 
@@ -1403,16 +1556,18 @@ filter_machines(char *filt)
 		return;
 
 	f = list;
-	while ((token = strsep(&f, ",")) != NULL) {
+	while ((token = strsep(&f, ",")) != NULL)
+	{
 		if (out.dtfl_count >= DTRACEFILT_MAX)
 			dfatal("Too many arguments\n");
-	        n = strlcpy((char*) &out.dtfl_entries[out.dtfl_count++],
-		    token, DTRACE_MAXFILTNAME);
+		n = strlcpy((char *)&out.dtfl_entries[out.dtfl_count++],
+					token, DTRACE_MAXFILTNAME);
 		if (n >= DTRACE_MAXFILTNAME)
 			dfatal("Name too long: %s", token);
 	}
 
-	if (out.dtfl_count > 0) {
+	if (out.dtfl_count > 0)
+	{
 		error = dt_filter(g_dtp, &out);
 	}
 
@@ -1422,8 +1577,406 @@ filter_machines(char *filt)
 	free(list);
 }
 
-int
-main(int argc, char *argv[])
+static int dtrace_gtq_empty(struct dtrace_guestq *gtq)
+{
+	return (STAILQ_EMPTY(&gtq->head));
+}
+
+static void dtrace_gtq_enqueue(struct dtrace_guestq *gtq, struct dtrace_guest_entry *trc_entry)
+{
+	STAILQ_INSERT_TAIL(&gtq->head, trc_entry, entries);
+}
+
+struct dtrace_guest_entry *dtrace_gtq_dequeue(struct dtrace_guestq *gtq)
+{
+	struct dtrace_guest_entry *trc_entry;
+	trc_entry = STAILQ_FIRST(&gtq->head);
+	if (trc_entry != NULL)
+	{
+		STAILQ_REMOVE_HEAD(&gtq->head, entries);
+	}
+
+	return (trc_entry);
+}
+
+static void *write_script(void *file_path)
+{
+
+	FILE *fp, *writer_stream;
+	char *d_script, *fifo;
+	long file_size;
+	int fd, sz;
+
+	fifo = "/tmp/fifo";
+
+	if ((fp = fopen((char *)file_path, "r")) == NULL)
+	{
+		printf("Error occudred while opening script file: %s\n", strerror(errno));
+		exit(1);
+	}
+
+	if (fseek(fp, 0L, SEEK_END) == -1)
+	{
+		printf("Error occured in fseek: %s", strerror(errno));
+		exit(1);
+	}
+
+	if ((file_size = ftell(fp)) == -1)
+	{
+		printf("Error occured in ftell: %s", strerror(errno));
+		exit(1);
+	}
+
+	rewind(fp);
+
+	d_script = malloc(file_size + 1);
+	if ((fread(d_script, sizeof(char), file_size, fp)) != file_size)
+	{
+		printf("Error occured while reading script file: %s.\n", strerror(errno));
+		exit(1);
+	}
+	fclose(fp);
+
+	d_script[file_size] = '\0';
+	if ((fd = open(fifo, O_WRONLY)) == -1)
+	{
+		printf("Error occured while opening fifo: %s\n", strerror(errno));
+		exit(1);
+	}
+
+	if ((writer_stream = fdopen(fd, "w")) == NULL)
+	{
+		printf("Failed to open write stream: %s", strerror(errno));
+		exit(1);
+	}
+
+	sz = fwrite(&file_size, sizeof(long), 1, writer_stream);
+	if (sz <= 0)
+	{
+		printf("Failed to write size of script to the named pipe: %s", strerror(errno));
+		exit(1);
+	}
+
+	if (fwrite(d_script, 1, file_size, writer_stream) != file_size)
+	{
+		if (ferror(writer_stream))
+		{
+			printf("Failed to write size of script to the named pipe: %s", strerror(errno));
+			exit(1);
+		}
+	}
+
+	fflush(writer_stream);
+
+	free(d_script);
+	close(fd);
+	fclose(writer_stream);
+	// unlink(fifo);
+}
+
+static void *read_trace_metadata(dtrace_hdl_t *dtp)
+{
+	struct timeval ts1, ts2;
+	dtrace_probedesc_t **pdescs;
+	dtrace_eprobedesc_t **epdescs;
+	dtrace_probedesc_t *probe;
+	dtrace_eprobedesc_t *eprobe;
+	FILE *fp;
+	char *meta_fifo, *buf, *fmt, **formats;
+	int fd, sz, nrecs = 0;
+	size_t epbuf_sz = 0, fmt_len = 0;
+
+	int maxformat, maxnpid, npdesc;
+
+	meta_fifo = "/tmp/meta_fifo";
+	int err = mkfifo(meta_fifo, 0666);
+	if (err)
+	{
+		printf("Failed to mkfifo: %s", strerror(errno));
+		exit(1);
+	}
+
+	if ((fd = open(meta_fifo, O_RDONLY)) == -1)
+	{
+		printf("Failed to open meta pipe for reading: %s. \n", strerror(errno));
+		exit(1);
+	}
+
+	if ((fp = fdopen(fd, "r")) == NULL)
+	{
+		printf("Failed opening meta stream: %s. \n", strerror(errno));
+		exit(1);
+	}
+
+	sz = fread(&maxformat, sizeof(int), 1, fp);
+	assert(sz > 0);
+
+	// gettimeofday(&ts1, NULL);
+	// printf("Start getting metadata: %ld %ld s \n", ts1.tv_sec, ts1.tv_usec);
+
+	dtp->dt_maxformat = dtp->dt_maxstrdata = maxformat;
+
+	if (maxformat > 0)
+	{
+		dtp->dt_formats = calloc(1, maxformat * sizeof(void *));
+		assert(dtp->dt_formats != NULL);
+
+		dtp->dt_strdata = calloc(1, maxformat * sizeof(char *));
+		assert(dtp->dt_strdata != NULL);
+
+		formats = calloc(1, maxformat * sizeof(char *));
+		assert(formats != 0);
+
+		for (int i = 0; i < maxformat; i++)
+		{
+			sz = fread(&fmt_len, sizeof(size_t), 1, fp);
+			assert(sz > 0);
+			printf("FORMAT STRING length: %s. \n", fmt_len);
+			fmt = calloc(1, sizeof(fmt_len + 1));
+			sz = fread(fmt, 1, fmt_len, fp);
+			assert(sz == fmt_len);
+			printf("FORMAT STRING: %s. \n", fmt);
+			formats[i] = fmt;
+		}
+	}
+
+	sz = fread(&maxnpid, sizeof(int), 1, fp);
+	assert(sz > 0);
+	// printf("NPROBES: %d. Aka maximum number of probes. \n", maxnpid);
+
+	dtp->dt_maxprobe = maxnpid;
+	dtp->dt_pdesc = calloc(1, maxnpid * sizeof(dtrace_probedesc_t *));
+	assert(dtp->dt_pdesc != NULL);
+
+	// because you can't have more enabled probes than this and apparently we
+	// malloc for all of them
+	dtp->dt_edesc = calloc(1, maxnpid * sizeof(dtrace_eprobedesc_t *));
+	assert(dtp->dt_edesc != NULL);
+
+	sz = fread(&npdesc, sizeof(int), 1, fp);
+	assert(sz > 0);
+	printf("dtrace: script matched %d probes \n", npdesc);
+
+	if (npdesc > 0)
+	{
+
+		for (int i = 0; i < npdesc; i++)
+		{
+			epbuf_sz = 0;
+			probe = calloc(1, sizeof(dtrace_probedesc_t));
+			// assert(probe != NULL);
+
+			sz = fread(probe, sizeof(dtrace_probedesc_t), 1, fp);
+			// assert(sz > 0);
+			dtp->dt_pdesc[probe->dtpd_id] = probe;
+			// printf("Got probe. \n");
+
+			sz = fread(&epbuf_sz, sizeof(size_t), 1, fp);
+			// assert(sz > 0);
+			// printf("EPROBE buffer size is: %d.\n", epbuf_sz);
+
+			eprobe = calloc(1, epbuf_sz);
+			assert(eprobe != NULL);
+			sz = fread(eprobe, 1, epbuf_sz, fp);
+			// assert(sz == epbuf_sz);
+			dtp->dt_edesc[eprobe->dtepd_epid] = eprobe;
+
+			// an enabled probe can produce more records
+
+			// printf("Number of records: %d. \n", eprobe->dtepd_nrecs);
+			assert(eprobe->dtepd_rec != NULL);
+
+			// only call printf create if we receive format strings
+			// I think
+			if (maxformat > 0)
+			{
+				for (int i = 0; i < eprobe->dtepd_nrecs; i++)
+				{
+					dtrace_recdesc_t *rec = &eprobe->dtepd_rec[i];
+
+					switch (rec->dtrd_action)
+					{
+					case DTRACEACT_DIFEXPR:
+						dtp->dt_strdata[rec->dtrd_format - 1] =
+							formats[rec->dtrd_format - 1];
+						break;
+					case DTRACEACT_PRINTA:
+						dtp->dt_formats[rec->dtrd_format - 1] =
+							dtrace_printa_create(dtp, formats[rec->dtrd_format - 1]);
+						break;
+					default:
+						dtp->dt_formats[rec->dtrd_format - 1] = dtrace_printf_create(dtp, formats
+																							  [rec->dtrd_format - 1]);
+						break;
+					}
+				}
+			}
+		}
+	}
+	// gettimeofday(&ts2, NULL);
+	// printf("Finished getting metadata: %ld s %ld us\n", ts2.tv_sec, ts2.tv_usec);
+	fclose(fp);
+	close(fd);
+}
+
+static void *read_trace_data(void *xgtq)
+{
+	struct dtrace_guestq *gtq;
+	struct dtrace_guest_entry *trc_entry;
+	dtrace_bufdesc_t *buf;
+	FILE *fp;
+	char *trc_fifo;
+	uint64_t size, chunk, sz;
+	uintptr_t dest;
+
+	int fd;
+
+	trc_fifo = "/tmp/trace_fifo";
+	gtq = (struct dtrace_guestq *)xgtq;
+
+	int err = mkfifo(trc_fifo, 0666);
+	if (err)
+	{
+		printf("Failed to mkfifo: %s", strerror(errno));
+		exit(1);
+	}
+
+	if ((fd = open(trc_fifo, O_RDONLY)) == -1)
+	{
+		printf("Failed to open trace pipe for reading: %s. \n", strerror(errno));
+		exit(1);
+	}
+
+	if ((fp = fdopen(fd, "r")) == NULL)
+	{
+		printf("Failed opening trace stream: %s. \n", strerror(errno));
+		exit(1);
+	}
+
+	for (;;)
+	{
+
+		buf = calloc(1, sizeof(dtrace_bufdesc_t));
+		assert(buf != NULL);
+		trc_entry = calloc(1, sizeof(struct dtrace_guest_entry));
+		assert(trc_entry != NULL);
+
+		sz = fread(&buf->dtbd_size, sizeof(uint64_t), 1, fp);
+		// assert(sz > 0);
+		// printf("Size: %d\n", buf->dtbd_size);
+
+		sz = fread(&buf->dtbd_cpu, sizeof(uint32_t), 1, fp);
+		// assert(sz > 0);
+		// printf("Cpu: %d\n", buf->dtbd_errors);
+
+		sz = fread(&buf->dtbd_errors, sizeof(uint32_t), 1, fp);
+		// assert(sz > 0);
+		// printf("Errors: %d\n", buf->dtbd_errors);
+
+		sz = fread(&buf->dtbd_drops, sizeof(uint64_t), 1, fp);
+		// assert(sz > 0);
+		// printf("Drops: %d\n", buf->dtbd_drops);
+
+		sz = fread(&buf->dtbd_oldest, sizeof(uint64_t), 1, fp);
+		// assert(sz > 0);
+		// printf("Oldest: %d\n", buf->dtbd_oldest);
+
+		sz = fread(&buf->dtbd_timestamp, sizeof(uint64_t), 1, fp);
+		// assert(sz > 0);
+		// printf("Timestamp: %d\n", buf->dtbd_timestamp);
+
+		buf->dtbd_data = calloc(1, buf->dtbd_size + 1);
+		// assert(buf->dtbd_data != NULL);
+
+		dest = (uintptr_t)buf->dtbd_data;
+		size = buf->dtbd_size;
+		chunk = (size > FRAGMENTSZ) ? FRAGMENTSZ : size;
+		while (size > 0)
+		{
+			size -= chunk;
+			sz = fread(dest, 1, chunk, fp);
+			// assert(sz == chunk);
+			dest += chunk;
+			chunk = (size > FRAGMENTSZ) ? FRAGMENTSZ : size;
+		}
+
+		trc_entry->desc = buf;
+		pthread_mutex_lock(&gtq->mtx);
+		dtrace_gtq_enqueue(gtq, trc_entry);
+		pthread_mutex_unlock(&gtq->mtx);
+	}
+
+	fclose(fp);
+	close(fd);
+}
+
+static void process_trace_data(struct dtrace_guestq *gtq, dtrace_hdl_t *dtp)
+{
+	dtrace_bufdesc_t *buf;
+	dtrace_consumer_t con;
+	struct dtrace_guest_entry *trc_entry;
+	struct timeval timing;
+
+	// hope we can use the functions defined here
+	con.dc_consume_probe = chew;
+	con.dc_consume_rec = chewrec;
+
+	// we don't get anything from the host's kernel
+	con.dc_put_buf = NULL;
+	con.dc_get_buf = NULL;
+
+	for (;;)
+	{
+		pthread_mutex_lock(&gtq->mtx);
+		while (!dtrace_gtq_empty(gtq))
+		{
+			trc_entry = dtrace_gtq_dequeue(gtq);
+			// printf("Dequeued trace data of size: %d. \n", trc_entry->desc->dtbd_size);
+			buf = trc_entry->desc;
+
+			dt_consume_cpu(dtp, NULL, 0, buf, false, &con, NULL);
+			// timing = time(NULL);
+			// printf("Finished processing one bufdesc: %ld s \n", timing);
+
+			free(trc_entry->desc->dtbd_data);
+			free(trc_entry->desc);
+			free(trc_entry);
+		}
+		pthread_mutex_unlock(&gtq->mtx);
+	}
+}
+
+static int dtrace_guest_start(char *script_file)
+{
+	struct dtrace_guestq *gtq;
+	pthread_t trace_reader;
+	int err;
+
+	gtq = calloc(1, sizeof(struct dtrace_guestq));
+	assert(gtq != NULL);
+
+	write_script(script_file);
+	struct timeval timing;
+	gettimeofday(&timing, NULL);
+	// printf("Sent script: %ld s %ld us ", timing.tv_sec, timing.tv_usec);
+	STAILQ_INIT(&gtq->head);
+	// printf("Guest queue successfully initialised. \n");
+	if ((g_dtp = dtrace_open(DTRACE_VERSION, 0, &err)) == NULL)
+	{
+		fatal("Failed to initialize dtrace: %s\n", dtrace_errmsg(NULL, err));
+	}
+
+	read_trace_metadata(g_dtp);
+	// printf("Successfully read metadata. \n");
+
+	// printf("About to read trace data. \n");
+	pthread_create(&trace_reader, NULL, read_trace_data, (void *)gtq);
+
+	process_trace_data(gtq, g_dtp);
+	// printf("Successfully processed trace data. Exiting .. \n");
+}
+
+int main(int argc, char *argv[])
 {
 	dtrace_bufdesc_t buf;
 	dtrace_status_t status[2];
@@ -1432,13 +1985,22 @@ main(int argc, char *argv[])
 	char *machine_filter;
 	dtrace_consumer_t con;
 
+	printf("Opening log file. \n");
+	if ((logging_fp = fopen("/tmp/log.txt", "w+")) == NULL)
+	{
+		printf("%s \n", strerror(errno));
+		exit(1);
+	}
+	assert(logging_fp != NULL);
+
 	con.dc_consume_probe = chew;
 	con.dc_consume_rec = chewrec;
 	con.dc_get_buf = NULL;
 	con.dc_put_buf = NULL;
 
 	g_ofp = stdout;
-	int done = 0, mode = 0;
+
+	int done = 0, mode = 0, h_mode = 0;
 	int err, i, c;
 	char *p, **v;
 	struct ps_prochandle *P;
@@ -1451,20 +2013,21 @@ main(int argc, char *argv[])
 	if (argc == 1)
 		return (usage(stderr));
 
-	if ((g_argv = malloc(sizeof (char *) * argc)) == NULL ||
-	    (g_cmdv = malloc(sizeof (dtrace_cmd_t) * argc)) == NULL ||
-	    (g_psv = malloc(sizeof (struct ps_prochandle *) * argc)) == NULL)
+	if ((g_argv = malloc(sizeof(char *) * argc)) == NULL ||
+		(g_cmdv = malloc(sizeof(dtrace_cmd_t) * argc)) == NULL ||
+		(g_psv = malloc(sizeof(struct ps_prochandle *) * argc)) == NULL)
 		fatal("failed to allocate memory for arguments");
 
-	g_argv[g_argc++] = argv[0];	/* propagate argv[0] to D as $0/$$0 */
-	argv[0] = g_pname;		/* rewrite argv[0] for getopt errors */
+	g_argv[g_argc++] = argv[0]; /* propagate argv[0] to D as $0/$$0 */
+	argv[0] = g_pname;			/* rewrite argv[0] for getopt errors */
 
-	bzero(status, sizeof (status));
-	bzero(&buf, sizeof (buf));
+	bzero(status, sizeof(status));
+	bzero(&buf, sizeof(buf));
 
 	argc = xo_parse_args(argc, argv);
 
-	if (argc < 0) {
+	if (argc < 0)
+	{
 		fprintf(stderr, "Failed xo_parse_args.\n");
 		return (usage(stderr));
 	}
@@ -1475,14 +2038,18 @@ main(int argc, char *argv[])
 	 * We also accumulate arguments that are not affiliated with getopt
 	 * options into g_argv[], and abort if any invalid options are found.
 	 */
-	for (optind = 1; optind < argc; optind++) {
-		while ((c = getopt(argc, argv, DTRACE_OPTSTR)) != -1) {
-			switch (c) {
+	for (optind = 1; optind < argc; optind++)
+	{
+		while ((c = getopt(argc, argv, DTRACE_OPTSTR)) != -1)
+		{
+			switch (c)
+			{
 			case '3':
-				if (strcmp(optarg, "2") != 0) {
-					(void) fprintf(stderr,
-					    "%s: illegal option -- 3%s\n",
-					    argv[0], optarg);
+				if (strcmp(optarg, "2") != 0)
+				{
+					(void)fprintf(stderr,
+								  "%s: illegal option -- 3%s\n",
+								  argv[0], optarg);
 					return (usage(stderr));
 				}
 				g_oflags &= ~DTRACE_O_LP64;
@@ -1490,10 +2057,11 @@ main(int argc, char *argv[])
 				break;
 
 			case '6':
-				if (strcmp(optarg, "4") != 0) {
-					(void) fprintf(stderr,
-					    "%s: illegal option -- 6%s\n",
-					    argv[0], optarg);
+				if (strcmp(optarg, "4") != 0)
+				{
+					(void)fprintf(stderr,
+								  "%s: illegal option -- 6%s\n",
+								  argv[0], optarg);
 					return (usage(stderr));
 				}
 				g_oflags &= ~DTRACE_O_ILP32;
@@ -1549,6 +2117,9 @@ main(int argc, char *argv[])
 				g_mode = DMODE_VERS;
 				mode++;
 				break;
+			case 'Y':
+				h_mode = 1;
+				break;
 
 			default:
 				if (strchr(DTRACE_OPTSTR, c) == NULL)
@@ -1560,9 +2131,16 @@ main(int argc, char *argv[])
 			g_argv[g_argc++] = argv[optind];
 	}
 
-	if (mode > 1) {
-		(void) fprintf(stderr, "%s: only one of the [-AGhlV] options "
-		    "can be specified at a time\n", g_pname);
+	if (h_mode == 1)
+	{
+		dtrace_guest_start(argv[argc - 1]);
+	}
+
+	if (mode > 1)
+	{
+		(void)fprintf(stderr, "%s: only one of the [-AGhlV] options "
+							  "can be specified at a time\n",
+					  g_pname);
 		return (E_USAGE);
 	}
 
@@ -1576,72 +2154,86 @@ main(int argc, char *argv[])
 	 * we actually process the object files.
 	 */
 	if (g_mode == DMODE_LINK &&
-	    (g_oflags & (DTRACE_O_ILP32 | DTRACE_O_LP64)) == 0 &&
-	    elf_version(EV_CURRENT) != EV_NONE) {
+		(g_oflags & (DTRACE_O_ILP32 | DTRACE_O_LP64)) == 0 &&
+		elf_version(EV_CURRENT) != EV_NONE)
+	{
 		int fd;
 		Elf *elf;
 		GElf_Ehdr ehdr;
 
-		for (i = 1; i < g_argc; i++) {
+		for (i = 1; i < g_argc; i++)
+		{
 			if ((fd = open64(g_argv[i], O_RDONLY)) == -1)
 				break;
 
-			if ((elf = elf_begin(fd, ELF_C_READ, NULL)) == NULL) {
-				(void) close(fd);
+			if ((elf = elf_begin(fd, ELF_C_READ, NULL)) == NULL)
+			{
+				(void)close(fd);
 				break;
 			}
 
 			if (elf_kind(elf) != ELF_K_ELF ||
-			    gelf_getehdr(elf, &ehdr) == NULL) {
-				(void) close(fd);
-				(void) elf_end(elf);
+				gelf_getehdr(elf, &ehdr) == NULL)
+			{
+				(void)close(fd);
+				(void)elf_end(elf);
 				break;
 			}
 
-			(void) close(fd);
-			(void) elf_end(elf);
+			(void)close(fd);
+			(void)elf_end(elf);
 
-			if (ehdr.e_ident[EI_CLASS] == ELFCLASS64) {
-				if (g_oflags & DTRACE_O_ILP32) {
+			if (ehdr.e_ident[EI_CLASS] == ELFCLASS64)
+			{
+				if (g_oflags & DTRACE_O_ILP32)
+				{
 					fatal("can't mix 32-bit and 64-bit "
-					    "object files\n");
+						  "object files\n");
 				}
 				g_oflags |= DTRACE_O_LP64;
-			} else if (ehdr.e_ident[EI_CLASS] == ELFCLASS32) {
-				if (g_oflags & DTRACE_O_LP64) {
+			}
+			else if (ehdr.e_ident[EI_CLASS] == ELFCLASS32)
+			{
+				if (g_oflags & DTRACE_O_LP64)
+				{
 					fatal("can't mix 32-bit and 64-bit "
-					    "object files\n");
+						  "object files\n");
 				}
 				g_oflags |= DTRACE_O_ILP32;
-			} else {
+			}
+			else
+			{
 				break;
 			}
 		}
 	}
 
+	// We let it go up until here then call something to process buffer data
 	/*
 	 * Open libdtrace.  If we are not actually going to be enabling any
 	 * instrumentation attempt to reopen libdtrace using DTRACE_O_NODEV.
 	 */
-	while ((g_dtp = dtrace_open(DTRACE_VERSION, g_oflags, &err)) == NULL) {
-		if (!(g_oflags & DTRACE_O_NODEV) && !g_exec && !g_grabanon) {
+	while ((g_dtp = dtrace_open(DTRACE_VERSION, g_oflags, &err)) == NULL)
+	{
+		if (!(g_oflags & DTRACE_O_NODEV) && !g_exec && !g_grabanon)
+		{
 			g_oflags |= DTRACE_O_NODEV;
 			continue;
 		}
 
 		fatal("failed to initialize dtrace: %s\n",
-		    dtrace_errmsg(NULL, err));
+			  dtrace_errmsg(NULL, err));
 	}
 
 #if defined(__i386__)
 	/* XXX The 32-bit seems to need more buffer space by default -sson */
-	(void) dtrace_setopt(g_dtp, "bufsize", "12m");
-	(void) dtrace_setopt(g_dtp, "aggsize", "12m");
+	(void)dtrace_setopt(g_dtp, "bufsize", "12m");
+	(void)dtrace_setopt(g_dtp, "aggsize", "12m");
 #else
-	(void) dtrace_setopt(g_dtp, "bufsize", "4m");
-	(void) dtrace_setopt(g_dtp, "aggsize", "4m");
+	(void)dtrace_setopt(g_dtp, "bufsize", "4m");
+	(void)dtrace_setopt(g_dtp, "aggsize", "4m");
 #endif
-	(void) dtrace_setopt(g_dtp, "temporal", "yes");
+	(void)dtrace_setopt(g_dtp, "temporal", "yes");
 
 	/*
 	 * If -G is specified, enable -xlink=dynamic and -xunodefs to permit
@@ -1649,9 +2241,10 @@ main(int argc, char *argv[])
 	 * If -A is specified, enable -xlink=primary to permit static linking
 	 * only to kernel symbols that are defined in a primary kernel module.
 	 */
-	if (g_mode == DMODE_LINK) {
-		(void) dtrace_setopt(g_dtp, "linkmode", "dynamic");
-		(void) dtrace_setopt(g_dtp, "unodefs", NULL);
+	if (g_mode == DMODE_LINK)
+	{
+		(void)dtrace_setopt(g_dtp, "linkmode", "dynamic");
+		(void)dtrace_setopt(g_dtp, "unodefs", NULL);
 
 		/*
 		 * Use the remaining arguments as the list of object files
@@ -1664,10 +2257,12 @@ main(int argc, char *argv[])
 		 * We still use g_argv[0], the name of the executable.
 		 */
 		g_argc = 1;
-	} else if (g_mode == DMODE_ANON)
-		(void) dtrace_setopt(g_dtp, "linkmode", "primary");
+	}
+	else if (g_mode == DMODE_ANON)
+		(void)dtrace_setopt(g_dtp, "linkmode", "primary");
 
-	if (machine_filter != NULL) {
+	if (machine_filter != NULL)
+	{
 		filter_machines(machine_filter);
 		free(machine_filter);
 	}
@@ -1678,9 +2273,12 @@ main(int argc, char *argv[])
 	 * We also accumulate any program specifications into our g_cmdv[] at
 	 * this time; these will compiled as part of the fourth processing pass.
 	 */
-	for (optind = 1; optind < argc; optind++) {
-		while ((c = getopt(argc, argv, DTRACE_OPTSTR)) != -1) {
-			switch (c) {
+	for (optind = 1; optind < argc; optind++)
+	{
+		while ((c = getopt(argc, argv, DTRACE_OPTSTR)) != -1)
+		{
+			switch (c)
+			{
 			case 'a':
 				if (dtrace_setopt(g_dtp, "grabanon", 0) != 0)
 					dfatal("failed to set -a");
@@ -1688,7 +2286,7 @@ main(int argc, char *argv[])
 
 			case 'b':
 				if (dtrace_setopt(g_dtp,
-				    "bufsize", optarg) != 0)
+								  "bufsize", optarg) != 0)
 					dfatal("failed to set -b %s", optarg);
 				break;
 
@@ -1823,15 +2421,19 @@ main(int argc, char *argv[])
 		}
 	}
 
-	if (g_ofp == NULL && g_mode != DMODE_EXEC) {
-		(void) fprintf(stderr, "%s: -B not valid in combination"
-		    " with [-AGl] options\n", g_pname);
+	if (g_ofp == NULL && g_mode != DMODE_EXEC)
+	{
+		(void)fprintf(stderr, "%s: -B not valid in combination"
+							  " with [-AGl] options\n",
+					  g_pname);
 		return (E_USAGE);
 	}
 
-	if (g_ofp == NULL && g_ofile != NULL) {
-		(void) fprintf(stderr, "%s: -B not valid in combination"
-		    " with -o option\n", g_pname);
+	if (g_ofp == NULL && g_ofile != NULL)
+	{
+		(void)fprintf(stderr, "%s: -B not valid in combination"
+							  " with -o option\n",
+					  g_pname);
 		return (E_USAGE);
 	}
 
@@ -1840,9 +2442,12 @@ main(int argc, char *argv[])
 	 * grabbing or creating victim processes.  The behavior of these calls
 	 * may been affected by any library options set by the second pass.
 	 */
-	for (optind = 1; optind < argc; optind++) {
-		while ((c = getopt(argc, argv, DTRACE_OPTSTR)) != -1) {
-			switch (c) {
+	for (optind = 1; optind < argc; optind++)
+	{
+		while ((c = getopt(argc, argv, DTRACE_OPTSTR)) != -1)
+		{
+			switch (c)
+			{
 			case 'c':
 				if ((v = make_argv(optarg)) == NULL)
 					fatal("failed to allocate memory");
@@ -1879,7 +2484,8 @@ main(int argc, char *argv[])
 	for (i = 0; i < g_cmdc; i++)
 		g_cmdv[i].dc_func(&g_cmdv[i]);
 
-	if (g_mode != DMODE_LIST) {
+	if (g_mode != DMODE_LIST)
+	{
 		if (dtrace_handle_err(g_dtp, &errhandler, NULL) == -1)
 			dfatal("failed to establish error handler");
 
@@ -1893,17 +2499,17 @@ main(int argc, char *argv[])
 			dfatal("failed to establish setopt handler");
 
 		if (g_ofp == NULL &&
-		    dtrace_handle_buffered(g_dtp, &bufhandler, NULL) == -1)
+			dtrace_handle_buffered(g_dtp, &bufhandler, NULL) == -1)
 			dfatal("failed to establish buffered handler");
 	}
 
-	(void) dtrace_getopt(g_dtp, "flowindent", &opt);
+	(void)dtrace_getopt(g_dtp, "flowindent", &opt);
 	g_flowindent = opt != DTRACEOPT_UNSET;
 
-	(void) dtrace_getopt(g_dtp, "grabanon", &opt);
+	(void)dtrace_getopt(g_dtp, "grabanon", &opt);
 	g_grabanon = opt != DTRACEOPT_UNSET;
 
-	(void) dtrace_getopt(g_dtp, "quiet", &opt);
+	(void)dtrace_getopt(g_dtp, "quiet", &opt);
 	g_quiet = opt != DTRACEOPT_UNSET;
 
 	/*
@@ -1913,7 +2519,8 @@ main(int argc, char *argv[])
 	 * of the switch() and continue on to the data processing loop.  For
 	 * other modes, we will exit dtrace once mode-specific work is done.
 	 */
-	switch (g_mode) {
+	switch (g_mode)
+	{
 	case DMODE_EXEC:
 		if (g_ofile != NULL && (g_ofp = fopen(g_ofile, "a")) == NULL)
 			fatal("failed to open output file '%s'", g_ofile);
@@ -1921,7 +2528,8 @@ main(int argc, char *argv[])
 		for (i = 0; i < g_cmdc; i++)
 			exec_prog(&g_cmdv[i]);
 
-		if (done && !g_grabanon) {
+		if (done && !g_grabanon)
+		{
 			dtrace_close(g_dtp);
 			return (g_status);
 		}
@@ -1944,7 +2552,8 @@ main(int argc, char *argv[])
 		etcsystem_prune(); /* string out any forceload directives */
 #endif
 
-		if (g_cmdc == 0) {
+		if (g_cmdc == 0)
+		{
 			dtrace_close(g_dtp);
 			return (g_status);
 		}
@@ -1952,9 +2561,10 @@ main(int argc, char *argv[])
 		if ((g_ofp = fopen(g_ofile, "a")) == NULL)
 			fatal("failed to open output file '%s'", g_ofile);
 
-		for (i = 0; i < g_cmdc; i++) {
+		for (i = 0; i < g_cmdc; i++)
+		{
 			anon_prog(&g_cmdv[i],
-			    dtrace_dof_create(g_dtp, g_cmdv[i].dc_prog, 0), i);
+					  dtrace_dof_create(g_dtp, g_cmdv[i].dc_prog, 0), i);
 		}
 
 		/*
@@ -1985,9 +2595,11 @@ main(int argc, char *argv[])
 		return (g_status);
 
 	case DMODE_LINK:
-		if (g_cmdc == 0) {
-			(void) fprintf(stderr, "%s: -G requires one or more "
-			    "scripts or enabling options\n", g_pname);
+		if (g_cmdc == 0)
+		{
+			(void)fprintf(stderr, "%s: -G requires one or more "
+								  "scripts or enabling options\n",
+						  g_pname);
 			dtrace_close(g_dtp);
 			return (E_USAGE);
 		}
@@ -1995,14 +2607,15 @@ main(int argc, char *argv[])
 		for (i = 0; i < g_cmdc; i++)
 			link_prog(&g_cmdv[i]);
 
-		if (g_cmdc > 1 && g_ofile != NULL) {
-			char **objv = alloca(g_cmdc * sizeof (char *));
+		if (g_cmdc > 1 && g_ofile != NULL)
+		{
+			char **objv = alloca(g_cmdc * sizeof(char *));
 
 			for (i = 0; i < g_cmdc; i++)
 				objv[i] = g_cmdv[i].dc_ofile;
 
 			if (dtrace_program_link(g_dtp, NULL, DTRACE_D_PROBES,
-			    g_ofile, g_cmdc, objv) != 0)
+									g_ofile, g_cmdc, objv) != 0)
 				dfatal(NULL); /* dtrace_errmsg() only */
 		}
 
@@ -2016,49 +2629,56 @@ main(int argc, char *argv[])
 		installsighands();
 
 		oprintf("%5s %10s %17s %33s %s\n",
-		    "ID", "PROVIDER", "MODULE", "FUNCTION", "NAME");
+				"ID", "PROVIDER", "MODULE", "FUNCTION", "NAME");
 
 		for (i = 0; i < g_cmdc; i++)
 			list_prog(&g_cmdv[i]);
 
 		if (g_cmdc == 0)
-			(void) dtrace_probe_iter(g_dtp, NULL, list_probe, NULL);
+			(void)dtrace_probe_iter(g_dtp, NULL, list_probe, NULL);
 
 		dtrace_close(g_dtp);
 		return (g_status);
 
 	case DMODE_HEADER:
-		if (g_cmdc == 0) {
-			(void) fprintf(stderr, "%s: -h requires one or more "
-			    "scripts or enabling options\n", g_pname);
+		if (g_cmdc == 0)
+		{
+			(void)fprintf(stderr, "%s: -h requires one or more "
+								  "scripts or enabling options\n",
+						  g_pname);
 			dtrace_close(g_dtp);
 			return (E_USAGE);
 		}
 
-		if (g_ofile == NULL) {
+		if (g_ofile == NULL)
+		{
 			char *p;
 
-			if (g_cmdc > 1) {
-				(void) fprintf(stderr, "%s: -h requires an "
-				    "output file if multiple scripts are "
-				    "specified\n", g_pname);
+			if (g_cmdc > 1)
+			{
+				(void)fprintf(stderr, "%s: -h requires an "
+									  "output file if multiple scripts are "
+									  "specified\n",
+							  g_pname);
 				dtrace_close(g_dtp);
 				return (E_USAGE);
 			}
 
 			if ((p = strrchr(g_cmdv[0].dc_arg, '.')) == NULL ||
-			    strcmp(p, ".d") != 0) {
-				(void) fprintf(stderr, "%s: -h requires an "
-				    "output file if no scripts are "
-				    "specified\n", g_pname);
+				strcmp(p, ".d") != 0)
+			{
+				(void)fprintf(stderr, "%s: -h requires an "
+									  "output file if no scripts are "
+									  "specified\n",
+							  g_pname);
 				dtrace_close(g_dtp);
 				return (E_USAGE);
 			}
 
 			p[0] = '\0'; /* strip .d suffix */
 			g_ofile = p = g_cmdv[0].dc_ofile;
-			(void) snprintf(p, sizeof (g_cmdv[0].dc_ofile),
-			    "%s.h", basename(g_cmdv[0].dc_arg));
+			(void)snprintf(p, sizeof(g_cmdv[0].dc_ofile),
+						   "%s.h", basename(g_cmdv[0].dc_arg));
 		}
 
 		if ((g_ofp = fopen(g_ofile, "w")) == NULL)
@@ -2067,18 +2687,20 @@ main(int argc, char *argv[])
 		oprintf("/*\n * Generated by dtrace(1M).\n */\n\n");
 
 		if (dtrace_program_header(g_dtp, g_ofp, g_ofile) != 0 ||
-		    fclose(g_ofp) == EOF)
+			fclose(g_ofp) == EOF)
 			dfatal("failed to create header file %s", g_ofile);
 
 		dtrace_close(g_dtp);
 		return (g_status);
 	}
 
-	(void) dtrace_getopt(g_dtp, "oformat", &opt);
-	if (opt != DTRACEOPT_UNSET) {
+	(void)dtrace_getopt(g_dtp, "oformat", &opt);
+	if (opt != DTRACEOPT_UNSET)
+	{
 		g_oformat = opt;
-		xo_set_flags(NULL, XOF_PRETTY|XOF_FLUSH);
-		switch (g_oformat) {
+		xo_set_flags(NULL, XOF_PRETTY | XOF_FLUSH);
+		switch (g_oformat)
+		{
 		case OMODE_JSON:
 			xo_set_style(NULL, XO_STYLE_JSON);
 			break;
@@ -2094,7 +2716,6 @@ main(int argc, char *argv[])
 		if (g_ofp != NULL)
 			xo_set_file(g_ofp);
 	}
-	
 
 	/*
 	 * If -a and -Z were not specified and no probes have been matched, no
@@ -2109,16 +2730,16 @@ main(int argc, char *argv[])
 	 */
 	go();
 
-	(void) dtrace_getopt(g_dtp, "flowindent", &opt);
+	(void)dtrace_getopt(g_dtp, "flowindent", &opt);
 	g_flowindent = opt != DTRACEOPT_UNSET;
 
-	(void) dtrace_getopt(g_dtp, "grabanon", &opt);
+	(void)dtrace_getopt(g_dtp, "grabanon", &opt);
 	g_grabanon = opt != DTRACEOPT_UNSET;
 
-	(void) dtrace_getopt(g_dtp, "quiet", &opt);
+	(void)dtrace_getopt(g_dtp, "quiet", &opt);
 	g_quiet = opt != DTRACEOPT_UNSET;
 
-	(void) dtrace_getopt(g_dtp, "destructive", &opt);
+	(void)dtrace_getopt(g_dtp, "destructive", &opt);
 	if (opt != DTRACEOPT_UNSET)
 		notice("allowing destructive actions\n");
 
@@ -2134,18 +2755,21 @@ main(int argc, char *argv[])
 
 	g_pslive = g_psc; /* count for prochandler() */
 
-	do {
+	do
+	{
 		if (!g_intr && !done)
 			dtrace_sleep(g_dtp);
 
 #ifdef __FreeBSD__
-		if (g_siginfo) {
+		if (g_siginfo)
+		{
 			(void)dtrace_aggregate_print(g_dtp, g_ofp, NULL);
 			g_siginfo = 0;
 		}
 #endif
 
-		if (g_newline) {
+		if (g_newline)
+		{
 			/*
 			 * Output a newline just to make the output look
 			 * slightly cleaner.  Note that we do this even in
@@ -2155,13 +2779,15 @@ main(int argc, char *argv[])
 			g_newline = 0;
 		}
 
-		if (done || g_intr || (g_psc != 0 && g_pslive == 0)) {
+		if (done || g_intr || (g_psc != 0 && g_pslive == 0))
+		{
 			done = 1;
 			if (dtrace_stop(g_dtp) == -1)
 				dfatal("couldn't stop tracing");
 		}
 
-		switch (dtrace_work(g_dtp, g_ofp, &con, NULL)) {
+		switch (dtrace_work(g_dtp, g_ofp, &con, NULL))
+		{
 		case DTRACE_WORKSTATUS_DONE:
 			done = 1;
 			break;
@@ -2179,9 +2805,10 @@ main(int argc, char *argv[])
 
 	oprintf("\n");
 
-	if (!g_impatient) {
+	if (!g_impatient)
+	{
 		if (dtrace_aggregate_print(g_dtp, g_ofp, NULL) == -1 &&
-		    dtrace_errno(g_dtp) != EINTR)
+			dtrace_errno(g_dtp) != EINTR)
 			dfatal("failed to print aggregations");
 	}
 
diff --git a/cddl/contrib/opensolaris/lib/libdtrace/common/dt_cc.c b/cddl/contrib/opensolaris/lib/libdtrace/common/dt_cc.c
index 8ec5dd61b8e..94844bf5694 100644
--- a/cddl/contrib/opensolaris/lib/libdtrace/common/dt_cc.c
+++ b/cddl/contrib/opensolaris/lib/libdtrace/common/dt_cc.c
@@ -2454,8 +2454,10 @@ dt_compile(dtrace_hdl_t *dtp, int context, dtrace_probespec_t pspec, void *arg,
 	 * will longjmp back to pcb_jmpbuf to abort.  If parsing succeeds,
 	 * we optionally display the parse tree if debugging is enabled.
 	 */
-	if (yyparse() != 0 || yypcb->pcb_root == NULL)
+	if (yyparse() != 0 || yypcb->pcb_root == NULL) {
 		xyerror(D_EMPTY, "empty D program translation unit\n");
+		// xyerror(D_EMPTY, "Error is occuring when parsing.\n");
+	}
 
 	yybegin(YYS_DONE);
 
@@ -2508,7 +2510,10 @@ dt_compile(dtrace_hdl_t *dtp, int context, dtrace_probespec_t pspec, void *arg,
 
 		if ((dnp = yypcb->pcb_root->dn_list) == NULL &&
 		    !(yypcb->pcb_cflags & DTRACE_C_EMPTY))
-			xyerror(D_EMPTY, "empty D program translation unit\n");
+			{
+				xyerror(D_EMPTY, "empty D program translation unit\n");
+				// Error occurs here: xyerror(D_EMPTY, "Error occurs in the parse tree.\n");
+			}
 
 		if ((yypcb->pcb_prog = dt_program_create(dtp)) == NULL)
 			longjmp(yypcb->pcb_jmpbuf, dtrace_errno(dtp));
diff --git a/cddl/contrib/opensolaris/lib/libdtrace/common/dt_consume.c b/cddl/contrib/opensolaris/lib/libdtrace/common/dt_consume.c
index 87d198f9668..d7bcf5863eb 100644
--- a/cddl/contrib/opensolaris/lib/libdtrace/common/dt_consume.c
+++ b/cddl/contrib/opensolaris/lib/libdtrace/common/dt_consume.c
@@ -43,7 +43,6 @@
 #ifndef illumos
 #include <libproc_compat.h>
 #endif
-
 #include <libxo/xo.h>
 
 #define	DT_MASK_LO 0x00000000FFFFFFFFULL
@@ -2744,7 +2743,7 @@ dt_get_buf(dtrace_hdl_t *dtp, int cpu, dtrace_bufdesc_t **bufp)
 	buf->dtbd_size = size;
 	buf->dtbd_cpu = cpu;
 
-#ifdef illumos
+ #ifdef illumos
 	if (dt_ioctl(dtp, DTRACEIOC_BUFSNAP, buf) == -1) {
 #else
 	if (dt_ioctl(dtp, DTRACEIOC_BUFSNAP, &buf) == -1) {
@@ -2754,7 +2753,7 @@ dt_get_buf(dtrace_hdl_t *dtp, int cpu, dtrace_bufdesc_t **bufp)
 		 * CPU was unconfigured -- this is okay.  Any other
 		 * error, however, is unexpected.
 		 */
-		if (errno == ENOENT) {
+	if (errno == ENOENT) {
 			*bufp = NULL;
 			rval = 0;
 		} else
@@ -2905,7 +2904,7 @@ dt_consume_begin(dtrace_hdl_t *dtp, FILE *fp, dtrace_consumer_t *dc, void *arg)
 	begin_dc.dc_consume_probe = dt_consume_begin_probe;
 	begin_dc.dc_consume_rec = dt_consume_begin_record;
 	begin_dc.dc_put_buf = dc->dc_put_buf;
-	begin_dc.dc_get_buf - dc->dc_get_buf;
+	begin_dc.dc_get_buf = dc->dc_get_buf;
 
 	rval = dt_consume_cpu(dtp, fp, cpu, buf, B_FALSE, &begin_dc, &begin);
 
@@ -3042,7 +3041,7 @@ dtrace_consume(dtrace_hdl_t *dtp, FILE *fp, dtrace_consumer_t *dc, void *arg)
 			 */
 			if (dtp->dt_stopped && (i == dtp->dt_endedon))
 				continue;
-
+			// we dequeue from backend
 			if (dc->dc_get_buf(dtp, i, &buf) != 0)
 				return (-1);
 			if (buf == NULL)
diff --git a/cddl/contrib/opensolaris/lib/libdtrace/common/dtrace.h b/cddl/contrib/opensolaris/lib/libdtrace/common/dtrace.h
index 125037cca14..1c2ab68d4fd 100644
--- a/cddl/contrib/opensolaris/lib/libdtrace/common/dtrace.h
+++ b/cddl/contrib/opensolaris/lib/libdtrace/common/dtrace.h
@@ -33,6 +33,7 @@
 #define	_DTRACE_H
 
 #include <sys/dtrace.h>
+#include <sys/queue.h>
 #include <stdarg.h>
 #include <stdbool.h>
 #include <stdio.h>
@@ -110,6 +111,9 @@ typedef struct dtrace_proginfo {
 	uint_t dpi_speculations; /* number of speculations specified in prog */
 } dtrace_proginfo_t;
 
+
+
+
 #define	DTRACE_C_DIFV	0x0001	/* DIF verbose mode: show each compiled DIFO */
 #define	DTRACE_C_EMPTY	0x0002	/* Permit compilation of empty D source files */
 #define	DTRACE_C_ZDEFS	0x0004	/* Permit probe defs that match zero probes */
diff --git a/cddl/lib/libdtrace/Makefile b/cddl/lib/libdtrace/Makefile
index cc01a2ef095..b4eb87561ea 100644
--- a/cddl/lib/libdtrace/Makefile
+++ b/cddl/lib/libdtrace/Makefile
@@ -74,7 +74,7 @@ CFLAGS+=	-I${.OBJDIR} -I${.CURDIR} \
 		-I${OPENSOLARIS_USR_DISTDIR}/head \
 		-I${OPENSOLARIS_USR_DISTDIR}/lib/libctf/common \
 		-I${OPENSOLARIS_USR_DISTDIR}/lib/libdtrace/common \
-		-I${OPENSOLARIS_SYS_DISTDIR}/uts/common
+		-I${OPENSOLARIS_SYS_DISTDIR}/uts/common 
 
 CFLAGS+=	-g
 
@@ -113,7 +113,6 @@ CFLAGS+=	-I${OPENSOLARIS_SYS_DISTDIR}/uts/sparc
 # temporary hack
 CFLAGS+=	-I${OPENSOLARIS_SYS_DISTDIR}/uts/intel
 .endif
-
 .if ${MACHINE_ARCH} == "i386" || ${MACHINE_ARCH} == "amd64"
 SRCS+=		dis_tables.c
 DSRCS+=		regs_x86.d
diff --git a/cddl/usr.sbin/dtrace/Makefile b/cddl/usr.sbin/dtrace/Makefile
index 0809243c235..1fd2046f398 100644
--- a/cddl/usr.sbin/dtrace/Makefile
+++ b/cddl/usr.sbin/dtrace/Makefile
@@ -10,19 +10,24 @@ BINDIR?=	/usr/sbin
 
 WARNS?=		1
 
+LDFLAGS+= -pthread
 CFLAGS+=	-I${SRCTOP}/sys/cddl/compat/opensolaris \
+		-I${SRCTOP}/cddl/contrib/opensolaris/lib/libctf/common \
 		-I${SRCTOP}/cddl/compat/opensolaris/include \
 		-I${OPENSOLARIS_USR_DISTDIR}/head \
 		-I${OPENSOLARIS_USR_DISTDIR}/lib/libdtrace/common \
 		-I${OPENSOLARIS_USR_DISTDIR}/lib/libproc/common \
 		-I${OPENSOLARIS_SYS_DISTDIR}/uts/common \
-		-I${OPENSOLARIS_SYS_DISTDIR}/compat
+		-I${OPENSOLARIS_SYS_DISTDIR}/compat \
+
+#CFLAGS+=-fsanitize=address
+#CFLAGS+=-fno-omit-frame-pointer
 
 # Optional debugging stuff...
 #CFLAGS+=	-DNEED_ERRLOC
 #YFLAGS+=	-d
 
-LIBADD=	dtrace ctf elf proc xo
+LIBADD=	dtrace ctf elf proc xo 
 
 .if ${MK_DTRACE_TESTS} != "no"
 SUBDIR+=	tests
diff --git a/contrib/ddtrace/vm_ddtrace_consumer.c b/contrib/ddtrace/vm_ddtrace_consumer.c
new file mode 100644
index 00000000000..b6071268212
--- /dev/null
+++ b/contrib/ddtrace/vm_ddtrace_consumer.c
@@ -0,0 +1,368 @@
+/*-
+ * Copyright (c) 2019 (Mara Mihali)
+ * All rights reserved.
+ *
+ * This software was developed by BAE Systems, the University of Cambridge
+ * Computer Laboratory, and Memorial University under DARPA/AFRL contract
+ * FA8650-15-C-7558 ("CADETS"), as part of the DARPA Transparent Computing
+ * (TC) research program.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/ioctl.h>
+#include <sys/vtdtr.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/nv.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <err.h>
+#include <unistd.h>
+#include <syslog.h>
+#include <dtrace.h>
+#include <vtdtr.h>
+#include <dl_config.h>
+#include <dlog.h>
+#include <signal.h>
+#include <time.h>
+
+static int daemon_debug;
+#define DAEMON_LOG(params) if (daemon_debug) log params
+
+static char *directory_path = "/var/dtrace_log";
+static char *script_path = "/var/dtrace_log/script.d";
+static char *logging_file_path = "/var/dtrace_log/log_file.txt";
+static char *script;
+FILE *log_fp;
+
+
+static dtrace_hdl_t *g_dtp;
+static int g_intr, g_status = 0;
+
+static void
+log(FILE *fp, char *fmt,...)
+{
+    va_list args;
+    va_start(args,fmt);
+    vfprintf(fp, fmt, args);
+    fflush(fp);
+    va_end(args);
+}
+
+/*ARGSUSED*/
+static void
+intr(int signo)
+{
+    g_intr = 1;
+}
+
+static int
+get_script_events()
+{
+    FILE *script_fp;
+    struct vtdtr_conf *vtdtr_conf;
+    struct vtdtr_event *ev;
+    size_t script_len;
+    int fd, last = 0;
+
+    if ((fd = open("/dev/vtdtr", O_RDWR)) == -1)
+    {
+        DAEMON_LOG((log_fp, "Error opening device driver %s\n", strerror(errno)));
+        return -1;
+    }
+
+    DAEMON_LOG((log_fp, "Subscribing to events.. \n"));
+
+    vtdtr_conf = malloc(sizeof(struct vtdtr_conf));
+    vtdtr_conf->event_flags |= (1 << VTDTR_EV_SCRIPT) | (1 << VTDTR_EV_RECONF);
+    vtdtr_conf->timeout = 0;
+
+    if ((ioctl(fd, VTDTRIOC_CONF, vtdtr_conf)) != 0)
+    {
+        DAEMON_LOG((log_fp, "Failed to subscribe to script event in device driver: %s.\n", strerror(errno)));
+        return -1;
+    }
+
+    DAEMON_LOG((log_fp, "Successfully subscribed to events. \n"));
+
+    DAEMON_LOG((log_fp, "Waiting for script.. \n"));
+
+    if ((script_fp = fopen(script_path, "w+")) == NULL)
+    {
+        DAEMON_LOG((log_fp, "Error opening script file %s: %s \n.", script_path, strerror(errno)));
+        return -1;
+    }
+
+    do
+    {
+        ev = malloc(sizeof(struct vtdtr_event));
+        memset(ev, 0, sizeof(struct vtdtr_event));
+
+        if (read(fd, ev, sizeof(struct vtdtr_event)) < 0)
+        {
+            DAEMON_LOG((log_fp, "Error while reading %s", strerror(errno)));
+            return -1;
+        }
+
+        DAEMON_LOG((log_fp, "Got %s \n", ev->args.d_script.script));
+        int len = strlen(ev->args.d_script.script) + 1;
+        DAEMON_LOG((log_fp, "Length of the script is %d. \n", len - 1));
+        script = malloc(sizeof(char) * len);
+
+        strlcpy(script, ev->args.d_script.script, len);
+        script[len] = '\0';
+        DAEMON_LOG((log_fp, "Copied script %s \n.", script));
+
+        if (fwrite(script, 1, len - 1, script_fp) != len - 1)
+        {
+            DAEMON_LOG((log_fp, "Haven't written the entire script to file - stop. \n"));
+            return -1;
+        }
+
+        if (ferror(script_fp))
+        {
+            DAEMON_LOG((log_fp, "Error occured while writing in the script file. \n"));
+            return -1;
+        }
+
+        last = ev->args.d_script.last;
+
+        free(script);
+        free(ev);
+
+    } while (!last);
+
+    close(fd);
+    fflush(script_fp);
+    fclose(script_fp);
+
+    return 0;
+}
+
+static int
+vm_dtrace_consumer()
+{
+
+    FILE *fp;
+    struct dl_client_config_desc *client_conf;
+    dtrace_prog_t *prog;
+    dtrace_proginfo_t info;
+    nvlist_t *props;
+    size_t packed_len;
+    char **script_argv;
+    char *topic_name;
+    char ddtracearg[13];
+    int dlog, done = 0, err, ret = 0, rc, script_argc;
+
+    topic_name = "cadets-trace";
+
+    if ((fp = fopen(script_path, "r+")) == NULL)
+    {
+        DAEMON_LOG((log_fp, "Failed to open script file: %s", strerror(errno)));
+        ret = -1;
+        return ret;
+    }
+
+    dlog = open("/dev/dlog", O_RDWR);
+    if (dlog == -1)
+    {
+        DAEMON_LOG((log_fp, "Failed to open dlog: %s", strerror(errno)));
+        ret = -1;
+        return ret;
+    }
+
+    props = nvlist_create(0);
+    nvlist_add_string(props, DL_CONF_TOPIC, topic_name);
+
+    client_conf = (struct dl_client_config_desc *)malloc(
+        sizeof(struct dl_client_config_desc));
+    if (client_conf == NULL)
+    {
+
+        DAEMON_LOG((log_fp, "Failed to allocate client config: %s\n",
+                strerror(errno)));
+        ret = -1;
+        return ret;
+    }
+
+    client_conf->dlcc_packed_nvlist = nvlist_pack(props, &packed_len);
+    client_conf->dlcc_packed_nvlist_len = packed_len;
+
+    rc = ioctl(dlog, DLOGIOC_PRODUCER, &client_conf);
+    if (rc != 0)
+    {
+
+        DAEMON_LOG((log_fp, "failed to create DLog producer: %s\n",
+                strerror(errno)));
+        ret = -1;
+        return ret;
+    }
+
+    if ((g_dtp = dtrace_open(DTRACE_VERSION, 0, &err)) == NULL)
+    {
+        DAEMON_LOG((log_fp, "Cannot open dtrace library: %s\n", dtrace_errmsg(g_dtp, err)));
+        ret = -1;
+        goto destroy_dtrace;
+    }
+
+    sprintf(ddtracearg, "%d", dlog);
+    (void)dtrace_setopt(g_dtp, "ddtracearg", ddtracearg);
+
+    if (dtrace_setopt(g_dtp, "aggsize", "4m") != 0)
+    {
+        DAEMON_LOG((log_fp, "Failed to set aggregations size: %s. \n", dtrace_errmsg(g_dtp, dtrace_errno(g_dtp))));
+        goto destroy_dtrace;
+    }
+
+    if (dtrace_setopt(g_dtp, "bufsize", "4m") != 0)
+    {
+        DAEMON_LOG((log_fp, "Failed to set buffers size %s. \n", dtrace_errmsg(g_dtp, dtrace_errno(g_dtp))));
+        goto destroy_dtrace;
+    }
+
+    if (dtrace_setopt(g_dtp, "bufpolicy", "switch") != 0)
+    {
+        DAEMON_LOG((log_fp, "Failed to set bufpolicy to switch %s. \n", dtrace_errmsg(g_dtp, dtrace_errno(g_dtp))));
+        goto destroy_dtrace;
+    }
+
+    if (dtrace_setopt(g_dtp, "ddtracearg", ddtracearg) != 0)
+    {
+        DAEMON_LOG((log_fp, "Failed to set ddtracearg: %s. \n", dtrace_errmsg(g_dtp, dtrace_errno(g_dtp))));
+        goto destroy_dtrace;
+    }
+
+    DAEMON_LOG((log_fp, "Successfully opened DTrace\n"));
+    DAEMON_LOG((log_fp, "About to compile, script is: %s. \n", script));
+
+    if ((prog = dtrace_program_fcompile(g_dtp, fp, 0, 0, NULL)) == NULL)
+    {
+        DAEMON_LOG((log_fp, "Failed to compile the DTrace program: %s\n", dtrace_errmsg(g_dtp, dtrace_errno(g_dtp))));
+        ret = -1;
+        goto destroy_dtrace;
+    }
+    DAEMON_LOG((log_fp, "Dtrace program successfully compiled.\n"));
+
+    if (dtrace_program_exec(g_dtp, prog, &info) == -1)
+    {
+        DAEMON_LOG((log_fp, "Failed to enable probes: %s \n", dtrace_errmsg(g_dtp, dtrace_errno(g_dtp))));
+        ret = -1;
+        goto destroy_dtrace;
+    }
+
+    DAEMON_LOG((log_fp, "Dtrace program successfully executed.\n"));
+
+    struct sigaction act;
+    sigemptyset(&act.sa_mask);
+    act.sa_flags = 0;
+    act.sa_handler = intr;
+    sigaction(SIGINT, &act, NULL);
+    sigaction(SIGTERM, &act, NULL);
+
+    if (dtrace_go(g_dtp) != 0)
+    {
+        DAEMON_LOG((log_fp, "Failed to start instrumentation: %s\n", dtrace_errmsg(g_dtp, dtrace_errno(g_dtp))));
+        ret = -1;
+        goto destroy_dtrace;
+    }
+
+    DAEMON_LOG((log_fp, "DTrace instrumentation started.\n"));
+
+    do
+    {
+        if (!g_intr && !done)
+        {
+            dtrace_sleep(g_dtp);
+        }
+
+        if (g_intr)
+        {
+            done = 1;
+        }
+    } while (!done);
+
+destroy_dtrace:
+    DAEMON_LOG((log_fp, "Closing DTrace...\n"));
+    dtrace_close(g_dtp);
+    return ret;
+}
+
+int main(int argc, char **argv)
+{
+
+    mkdir(directory_path, 0777);
+    if ((log_fp = fopen(logging_file_path, "a+")) == NULL)
+    {
+            printf("Error printing logging file: %s \n", strerror(errno));
+            exit(1);
+    }
+
+    DAEMON_LOG((log_fp, "In vm_ddtrace_consumer.. \n"));
+
+    /* Daemonise first*/
+    if (daemon(0, 0) == -1)
+    {
+        DAEMON_LOG((log_fp, "Failed registering  vm_ddtrace_consumer as a daemon. \n"));
+        DAEMON_LOG((log_fp, "Daemon error is %s\n", strerror(errno)));
+        exit(1);
+    }
+
+    DAEMON_LOG((log_fp, "Successfully daemonised.\n"));
+    DAEMON_LOG((log_fp, "Waiting for scripts..\n"));
+
+    for (;;)
+    {
+        DAEMON_LOG((log_fp, "Listening for D scripts"));
+        
+        if (get_script_events() != 0)
+        {
+            DAEMON_LOG((log_fp, "Error occured while retrieving and assembling the script"));
+            exit(1);
+            break;
+        }
+
+        DAEMON_LOG((log_fp, "Start DTrace consumer.. \n"));
+
+        if ((vm_dtrace_consumer()) != 0)
+        {
+            DAEMON_LOG((log_fp, "Error occured while trying to execute the script. \n"));
+            exit(1);
+            break;
+        }
+        DAEMON_LOG((log_fp, "DTrace consumer finished.. \n"));
+   }
+
+    DAEMON_LOG((log_fp, "Closing log file. \n"));
+    fclose(log_fp);
+
+    return 0;
+}
diff --git a/contrib/dlog/src/dlog_client.c b/contrib/dlog/src/dlog_client.c
index 3b9a5a0227c..5a95ec6a8ee 100644
--- a/contrib/dlog/src/dlog_client.c
+++ b/contrib/dlog/src/dlog_client.c
@@ -226,6 +226,8 @@ dlog_client_open(struct dlog_handle **self,
 	unsigned short portnumber;
 	struct dl_topic *topic;
 	const char *topic_name;
+
+	topic = NULL;
 	
 	DL_ASSERT(config != NULL, ("Client configuration cannot be NULL"));
 	DLOGTR0(PRIO_NORMAL, "Opening the Dlog client...\n");
@@ -237,15 +239,17 @@ dlog_client_open(struct dlog_handle **self,
 		topic_name = nvlist_get_string(props, DL_CONF_TOPIC);
 	}
 
+#if 0
 	/* Lookup the topic in the topic hashmap. */
 	if (dl_topic_hashmap_get(topic_name, &topic) != 0) {
 
 		/* The specified topic was not found in the topic hashmap. */
 		DLOGTR1(PRIO_NORMAL, "Topic %s has not been created\n",
-		    topic_name);
+		    topic_name); 
 		*self = NULL;
 		return -1;
 	}
+#endif
 
 	handle = (struct dlog_handle *) dlog_alloc(sizeof(struct dlog_handle));
 #ifdef _KERNEL
@@ -265,6 +269,7 @@ dlog_client_open(struct dlog_handle **self,
 	/* Associate the topic with this client handle. */
 	handle->dlh_topic = topic;
 
+#if 0
 	if (!nvlist_exists_string(props, DL_CONF_BROKER)) {
 		hostname = DL_DEFAULT_BROKER;
 	} else {
@@ -277,6 +282,7 @@ dlog_client_open(struct dlog_handle **self,
 		portnumber = (unsigned short) nvlist_get_number(props,
 		    DL_CONF_BROKER_PORT);
 	}
+#endif
 
 	/* Increment the SYSCTL count of open handles */
 	dlog_nopen++;
diff --git a/installos b/installos
new file mode 100644
index 00000000000..6630c893b99
--- /dev/null
+++ b/installos
@@ -0,0 +1,34 @@
+#!/bin/sh
+
+. ~/.bashrc
+
+export MOUNT_POINT=/mnt
+
+cd ~/freebsd/freebsd
+
+a="$( df | grep /mnt | wc -l )"
+
+if [ $a \> 0 ];
+then
+	echo "Umounting /dev/da1p2..."
+	sudo umount $MOUNT_POINT
+	echo "Trying to mount again..."
+	sudo mount /dev/da1p2 $MOUNT_POINT
+else
+	echo "Mounting..."
+	sudo mount /dev/da1p2 $MOUNT_POINT
+fi
+
+echo "Installing world..."
+sr make -j9 installworld > /tmp/log_install_world
+
+echo "Installing kernel..."
+sr make -j9 installkernel > /tmp/log_install_kernel
+
+# to add source: -k /home/mm2260/freebsd/freebsd
+echo "Update virtual machine with source..."
+sr sh ~/freebsd/freebsd/vm_test_scripts/vmmake.sh -x -k /home/mm2260/freebsd/freebsd -c CADETS /mnt/mnt/test.img 
+
+
+
+
diff --git a/libexec/rc/rc.conf b/libexec/rc/rc.conf
index 9c979478f5c..323c0c4bd3c 100644
--- a/libexec/rc/rc.conf
+++ b/libexec/rc/rc.conf
@@ -590,7 +590,6 @@ sendmail_rebuild_aliases="NO"	# Run newaliases if necessary (YES/NO).
 ##############################################################
 ###  Miscellaneous administrative options  ###################
 ##############################################################
-
 dlogd_enable="NO"	# Run the Dlog daemon.
 dlogd_program="/usr/sbin/dlogd"	# Path to the DLog daemon.
 dlogd_flags=""		# Which options to pass to the Dlog daemon.
diff --git a/libexec/rc/rc.d/vm_ddtrace_consumer b/libexec/rc/rc.d/vm_ddtrace_consumer
new file mode 100644
index 00000000000..b6275a15cf6
--- /dev/null
+++ b/libexec/rc/rc.d/vm_ddtrace_consumer
@@ -0,0 +1,25 @@
+#!/bin/sh
+#
+#
+# $FreeBSD$
+#
+# Start up for the Virtual DDTrace script reader daemon
+#
+
+# PROVIDE: vm_ddtrace_consumer
+# REQURIE: syslogd
+# BEFORE: DAEMON
+# KEYWORD: nojail shutdown
+
+. /etc/rc.subr
+
+name="vm_ddtrace_consumer"
+rcvar=${name}_enable
+
+desc="VM DDTrace consumer daemon"
+
+command="usr/sbin/${name}"
+
+
+load_rc_config $name
+run_rc_command "$1"
\ No newline at end of file
diff --git a/push b/push
new file mode 100755
index 00000000000..7e21e5e455d
--- /dev/null
+++ b/push
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+git add .
+
+git commit -m "$1"
+
+git push origin mm2260/baseline
diff --git a/sys/amd64/conf/CADETS b/sys/amd64/conf/CADETS
index 615a432b9c9..68e7faa8600 100644
--- a/sys/amd64/conf/CADETS
+++ b/sys/amd64/conf/CADETS
@@ -25,6 +25,7 @@ options	DDTRACE
 options	DLOG
 options METAIO
 
+
 nooptions       INVARIANTS
 nooptions       INVARIANT_SUPPORT
 nooptions       WITNESS
diff --git a/sys/amd64/conf/GENERIC b/sys/amd64/conf/GENERIC
index d7e55ee0cf9..0a8c524736d 100644
--- a/sys/amd64/conf/GENERIC
+++ b/sys/amd64/conf/GENERIC
@@ -359,6 +359,7 @@ device		virtio_blk		# VirtIO Block device
 device		virtio_scsi		# VirtIO SCSI device
 device		virtio_balloon		# VirtIO Memory Balloon device
 device		virtio_dtrace		# VirtIO DTrace frontend
+device      vtdtr
 
 # HyperV drivers and enhancement support
 device		hyperv			# HyperV drivers 
diff --git a/sys/cddl/contrib/opensolaris/uts/common/dtrace/dtrace.c b/sys/cddl/contrib/opensolaris/uts/common/dtrace/dtrace.c
index 28aeeb3db38..44841898716 100644
--- a/sys/cddl/contrib/opensolaris/uts/common/dtrace/dtrace.c
+++ b/sys/cddl/contrib/opensolaris/uts/common/dtrace/dtrace.c
@@ -135,6 +135,7 @@
 #include <sys/rwlock.h>
 #include <sys/sx.h>
 #include <sys/sysctl.h>
+#include <sys/time.h>
 #include <machine/vmm.h>
 #include <dtvirt.h>
 #ifdef VTDTR
@@ -154,6 +155,7 @@
 #include "dtrace_xoroshiro128_plus.h"
 #include "dtrace_uuid.h"
 
+struct timespec tv1, tv2;
 /*
  * DTrace Tunable Variables
  *
@@ -7916,7 +7918,7 @@ dtrace_probe_enter(dtrace_id_t id)
 	 * resulting in unexpected output. If there is an exception to this
 	 * assertion, a new case should be added.
 	 */
-	ASSERT(curthread->t_dtrace_inprobe == 0 ||
+	ASSERT(curthread->t_dtrace_inprobe == 0 ||c
 	    id == dtrace_probeid_error);
 	curthread->t_dtrace_inprobe = 1;
 
@@ -7929,9 +7931,9 @@ dtrace_probe_enter(dtrace_id_t id)
 static void
 dtrace_probe_exit(dtrace_icookie_t cookie)
 {
-
 	curthread->t_dtrace_inprobe = 0;
 	dtrace_interrupt_enable(cookie);
+	
 }
 
 /*
@@ -18826,6 +18828,7 @@ dtrace_ioctl(dev_t dev, int cmd, intptr_t arg, int md, cred_t *cr, int *rv)
 		caddr_t cached;
 		dtrace_buffer_t *buf;
 
+		// this will copy arg to desc - arg userspace and desc kernelspace
 		if (copyin((void *)arg, &desc, sizeof (desc)) != 0)
 			return (EFAULT);
 
diff --git a/sys/cddl/dev/vtdtr/vtdtr.c b/sys/cddl/dev/vtdtr/vtdtr.c
index e362ecac25c..52573764817 100644
--- a/sys/cddl/dev/vtdtr/vtdtr.c
+++ b/sys/cddl/dev/vtdtr/vtdtr.c
@@ -45,11 +45,13 @@ __FBSDID("$FreeBSD$");
 #include <sys/tree.h>
 #include <sys/queue.h>
 #include <sys/dtrace.h>
+#include <sys/vtdtr.h>
 
 #include <machine/bus.h>
 
 #include "vtdtr.h"
 
+// should this have a bigger size??
 #define BITS                8
 #define MAX_BITSHIFT        ((size_t)1 << (sizeof(size_t)*BITS-1))
 #define VTDTR_BITMASK       ((MAX_BITSHIFT - 1) | (MAX_BITSHIFT))
@@ -59,7 +61,8 @@ __FBSDID("$FreeBSD$");
 #define VTDTR_MTX_NAME_SIZE 64
 
 static int debug = 1;
-#define DPRINTF(params) if (debug) printf params
+// TODO(MARA): put if block back
+#define DPRINTF(params) printf params
 
 /*
  * Lets us implement the linked list.
@@ -369,7 +372,7 @@ vtdtr_ioctl(struct cdev *dev __unused, u_long cmd, caddr_t addr,
 		 * We just set the default configuration if no configuration has
 		 * been passed in. Eases programming on the consumer side.
 		 */
-		if (conf == NULL)
+		if (conf == NULL) 
 			goto finalize_conf;
 
 		if (conf->max_size != 0)
@@ -379,7 +382,7 @@ vtdtr_ioctl(struct cdev *dev __unused, u_long cmd, caddr_t addr,
 
 		/*
 		 * There's no timeout by default.
-		 */
+		 */                          
 		timeout = conf->timeout * SBT_1S;
 
 finalize_conf:
diff --git a/sys/cddl/dev/vtdtr/vtdtr.h b/sys/cddl/dev/vtdtr/vtdtr.h
index b37fcddac17..7c4b79f44ff 100644
--- a/sys/cddl/dev/vtdtr/vtdtr.h
+++ b/sys/cddl/dev/vtdtr/vtdtr.h
@@ -3,6 +3,8 @@
 
 #include <sys/vtdtr.h>
 
-void vtdtr_enqueue(struct vtdtr_event *);
+extern void vtdtr_enqueue(struct vtdtr_event *);
 
 #endif
+
+// this has to be surfaced to virtio
diff --git a/sys/conf/files b/sys/conf/files
index 42659bb5315..3122e7f7365 100644
--- a/sys/conf/files
+++ b/sys/conf/files
@@ -317,6 +317,7 @@ cddl/dev/dtmalloc/dtmalloc.c		optional dtmalloc        | dtraceall compile-with
 cddl/dev/profile/profile.c		optional dtrace_profile  | dtraceall compile-with "${CDDL_C}"
 cddl/dev/sdt/sdt.c			optional dtrace_sdt      | dtraceall compile-with "${CDDL_C}"
 cddl/dev/fbt/fbt.c			optional dtrace_fbt      | dtraceall compile-with "${FBT_C}"
+cddl/dev/vtdtr/vtdtr.c			optional vtdtr   | dtraceall compile-with "${CDDL_C}"
 cddl/dev/systrace/systrace.c		optional dtrace_systrace | dtraceall compile-with "${CDDL_C}"
 cddl/dev/prototype.c			optional dtrace_prototype | dtraceall compile-with "${CDDL_C}"
 fs/nfsclient/nfs_clkdtrace.c		optional dtnfscl nfscl   | dtraceall nfscl compile-with "${CDDL_C}"
diff --git a/sys/dev/dlog/dlog.c b/sys/dev/dlog/dlog.c
index 1bf69d8bfa7..48e69869095 100644
--- a/sys/dev/dlog/dlog.c
+++ b/sys/dev/dlog/dlog.c
@@ -493,7 +493,7 @@ dlog_ioctl(struct cdev *dev, u_long cmd, caddr_t addr, int flags,
 
 static void
 dl_client_close(void *arg)
-{
+{ 
 	struct dlog_handle *handle = (struct dlog_handle *) arg;
 
 	//DL_ASSERT(handle != NULL, ("DLog client handle cannot be NULL."));
diff --git a/sys/dev/virtio/dtrace/virtio_dtrace.c b/sys/dev/virtio/dtrace/virtio_dtrace.c
index fac752f5996..038ab33a7ed 100644
--- a/sys/dev/virtio/dtrace/virtio_dtrace.c
+++ b/sys/dev/virtio/dtrace/virtio_dtrace.c
@@ -48,6 +48,9 @@ __FBSDID("$FreeBSD$");
 #include <sys/dtrace.h>
 #include <sys/sema.h>
 #include <sys/conf.h>
+#include <sys/time.h>
+
+#include <cddl/dev/vtdtr/vtdtr.h>
 
 #include <machine/bus.h>
 #include <machine/resource.h>
@@ -59,46 +62,52 @@ __FBSDID("$FreeBSD$");
 #include "virtio_dtrace.h"
 #include "virtio_if.h"
 
-struct vtdtr_probe {
-	uint32_t                vtdprobe_id;
-	LIST_ENTRY(vtdtr_probe) vtdprobe_next;
+struct vtdtr_probe
+{
+	uint32_t vtdprobe_id;
+	LIST_ENTRY(vtdtr_probe)
+	vtdprobe_next;
 };
 
-struct vtdtr_probelist {
-	LIST_HEAD(, vtdtr_probe) head;
-	struct mtx               mtx;
+struct vtdtr_probelist
+{
+	LIST_HEAD(, vtdtr_probe)
+	head;
+	struct mtx mtx;
 };
 
-struct vtdtr_softc {
-	device_t                   vtdtr_dev;
-	struct mtx                 vtdtr_mtx;
-	uint64_t                   vtdtr_features;
+struct vtdtr_softc
+{
+	device_t vtdtr_dev;
+	struct mtx vtdtr_mtx;
+	uint64_t vtdtr_features;
 
 	struct virtio_dtrace_queue vtdtr_txq;
 	struct virtio_dtrace_queue vtdtr_rxq;
-	int                        vtdtr_tx_nseg;
-	int                        vtdtr_rx_nseg;
+	int vtdtr_tx_nseg;
+	int vtdtr_rx_nseg;
 
-	struct cv                  vtdtr_condvar;
-	struct mtx                 vtdtr_condmtx;
+	struct cv vtdtr_condvar;
+	struct mtx vtdtr_condmtx;
 
-	struct vtdtr_ctrlq        *vtdtr_ctrlq;
+	struct vtdtr_ctrlq *vtdtr_ctrlq;
 
-	struct thread             *vtdtr_commtd;
+	struct thread *vtdtr_commtd;
+	struct thread *vtdtr_listd;
 
-	struct sema                vtdtr_exit;
+	struct sema vtdtr_exit;
 
 	/*
-	 * We need to keep track of all the enabled probes in the
+	 * We need to keep track of all the enabsled probes in the
 	 * driver in order to act as a bridge between the guest DTrace
 	 * and host DTrace. The driver is the one asking to install
 	 * or uninstall the probes on the guest, as instructed by host.
 	 */
-	struct vtdtr_probelist    *vtdtr_probelist;
+	struct vtdtr_probelist *vtdtr_probelist;
 
-	int                        vtdtr_shutdown;
-	int                        vtdtr_ready;
-	int                        vtdtr_host_ready;
+	int vtdtr_shutdown;
+	int vtdtr_ready;
+	int vtdtr_host_ready;
 };
 
 static MALLOC_DEFINE(M_VTDTR, "vtdtr", "VirtIO DTrace memory");
@@ -110,14 +119,18 @@ SYSCTL_NODE(_dev, OID_AUTO, vtdtr, CTLFLAG_RD, NULL, NULL);
  */
 static uint32_t num_dtprobes;
 SYSCTL_U32(_dev_vtdtr, OID_AUTO, nprobes, CTLFLAG_RD, &num_dtprobes, 0,
-    "Number of installed probes through virtio-dtrace");
+		   "Number of installed probes through virtio-dtrace");
 
 static uint32_t debug = 1;
 SYSCTL_U32(_dev_vtdtr, OID_AUTO, debug, CTLFLAG_RWTUN, &debug, 0,
-    "Enable debugging of virtio-dtrace");
+		   "Enable debugging of virtio-dtrace");
 
 static int vstate = 0;
 
+
+static struct vtdtr_traceq *tq;
+struct timespec tv1;
+
 static int vtdtr_modevent(module_t, int, void *);
 static void vtdtr_cleanup(void);
 
@@ -132,16 +145,15 @@ static int vtdtr_alloc_virtqueues(struct vtdtr_softc *);
 static void vtdtr_stop(struct vtdtr_softc *);
 static void vtdtr_drain_virtqueues(struct vtdtr_softc *);
 static int vtdtr_queue_populate(struct virtio_dtrace_queue *);
-static int vtdtr_queue_enqueue_ctrl(struct virtio_dtrace_queue *,
-    struct virtio_dtrace_control *, int, int);
 static void vtdtr_queue_requeue_ctrl(struct virtio_dtrace_queue *,
-    struct virtio_dtrace_control *, int, int);
+									 struct virtio_dtrace_control *, int, int);
 static int vtdtr_queue_new_ctrl(struct virtio_dtrace_queue *);
-
+static int vtdtr_queue_enqueue_ctrl(struct virtio_dtrace_queue *,
+									struct virtio_dtrace_control *, int, int);
 static int vtdtr_enable_interrupts(struct vtdtr_softc *);
 static void vtdtr_disable_interrupts(struct vtdtr_softc *);
 static int vtdtr_ctrl_process_event(struct vtdtr_softc *,
-    struct virtio_dtrace_control *);
+									struct virtio_dtrace_control *);
 static void vtdtr_destroy_probelist(struct vtdtr_softc *);
 static void vtdtr_start_taskqueues(struct vtdtr_softc *);
 static void vtdtr_drain_taskqueues(struct vtdtr_softc *);
@@ -155,22 +167,23 @@ static int vtdtr_init_txq(struct vtdtr_softc *, int);
 static int vtdtr_init_rxq(struct vtdtr_softc *, int);
 static void vtdtr_queue_destroy(struct virtio_dtrace_queue *);
 static void vtdtr_fill_desc(struct virtio_dtrace_queue *,
-    struct virtio_dtrace_control *);
+							struct virtio_dtrace_control *);
 static void vtdtr_cq_init(struct vtdtr_ctrlq *);
 static void vtdtr_cq_enqueue(struct vtdtr_ctrlq *,
-    struct vtdtr_ctrl_entry *);
+							 struct vtdtr_ctrl_entry *);
 static void vtdtr_cq_enqueue_front(struct vtdtr_ctrlq *,
-    struct vtdtr_ctrl_entry *);
+								   struct vtdtr_ctrl_entry *);
 static int vtdtr_cq_empty(struct vtdtr_ctrlq *);
 static size_t vtdtr_cq_count(struct vtdtr_ctrlq *);
-static struct vtdtr_ctrl_entry * vtdtr_cq_dequeue(struct vtdtr_ctrlq *);
+static struct vtdtr_ctrl_entry *vtdtr_cq_dequeue(struct vtdtr_ctrlq *);
 static void vtdtr_notify(struct virtio_dtrace_queue *);
 static void vtdtr_poll(struct virtio_dtrace_queue *);
+static void vtdtr_consume_trace(void *);
 static void vtdtr_run(void *);
 static void vtdtr_advertise_prov_priv(void *, const char *, struct uuid *);
 static void vtdtr_destroy_prov_priv(void *, struct uuid *);
 static void vtdtr_advertise_probe_priv(void *, const char *, const char *,
-    const char *, struct uuid *);
+									   const char *, struct uuid *);
 
 static device_method_t vtdtr_methods[] = {
 	/* Device methods. */
@@ -181,25 +194,25 @@ static device_method_t vtdtr_methods[] = {
 	/* VirtIO methods. */
 	DEVMETHOD(virtio_config_change, vtdtr_config_change),
 
-	DEVMETHOD_END
-};
+	DEVMETHOD_END};
 
 static driver_t vtdtr_driver = {
 	"vtdtr",
 	vtdtr_methods,
-	sizeof(struct vtdtr_softc)
-};
+	sizeof(struct vtdtr_softc)};
 static devclass_t vtdtr_devclass;
 
 DRIVER_MODULE(virtio_dtrace, virtio_pci, vtdtr_driver, vtdtr_devclass,
-    vtdtr_modevent, 0);
+			  vtdtr_modevent, 0);
 MODULE_VERSION(virtio_dtrace, 1);
 MODULE_DEPEND(virtio_dtrace, virtio, 1, 1, 1);
 MODULE_DEPEND(virtio_dtrace, dtrace, 1, 1, 1);
 
+// TODO(Mara): check whether we need this
+MODULE_DEPEND(virtio_dtrace, vtdtr, 1, 1, 1);
+
 static struct virtio_feature_desc vtdtr_feature_desc[] = {
-	{ 0, NULL }
-};
+	{0, NULL}};
 
 void (*dtrace_provide_all_probes)(void) = NULL;
 int (*dtrace_probeid_enable)(dtrace_id_t) = NULL;
@@ -213,7 +226,8 @@ vtdtr_modevent(module_t mod, int type, void *unused)
 {
 	int error;
 
-	switch (type) {
+	switch (type)
+	{
 	case MOD_LOAD:
 		error = 0;
 		break;
@@ -255,6 +269,73 @@ vtdtr_probe(device_t dev)
 	return (BUS_PROBE_DEFAULT);
 }
 
+struct vtdtr_traceq *
+virtio_dtrace_device_register()
+{
+	KASSERT(tq != NULL, "trace queue not initialised");
+	return tq;
+}
+
+int vtdtr_tq_empty(struct vtdtr_traceq *tq)
+{
+	return STAILQ_EMPTY(&tq->head);
+}
+
+void vtdtr_tq_enqueue(struct vtdtr_traceq *tq, struct vtdtr_trace_entry *trc_entry)
+{
+	STAILQ_INSERT_TAIL(&tq->head, trc_entry, entries);
+	tq->n_entries++;
+}
+
+void vtdtr_tq_init(struct vtdtr_traceq *tq)
+{
+	STAILQ_INIT(&tq->head);
+	tq->n_entries = 0;
+}
+
+struct vtdtr_trace_entry *vtdtr_tq_dequeue(struct vtdtr_traceq *tq)
+{
+	struct vtdtr_trace_entry *trc_entry;
+	trc_entry = STAILQ_FIRST(&tq->head);
+	if (trc_entry != NULL)
+	{
+		STAILQ_REMOVE_HEAD(&tq->head, entries);
+		tq->n_entries--;
+	}
+
+	return trc_entry;
+}
+
+void vtdtr_tq_print(struct vtdtr_traceq *tq, char *from)
+{
+	printf("%s", from);
+
+	struct vtdtr_trace_entry *trc_entry, *trc_entry_temp;
+
+	if (!STAILQ_EMPTY(&tq->head))
+		STAILQ_FOREACH_SAFE(trc_entry, &tq->head, entries, trc_entry_temp)
+		{
+			printf(" %d \n", trc_entry->uentry.trace.dtbd_size);
+		}
+	else
+		printf("Trace queue is empty. \n");
+}
+
+void vtdtr_cq_print(struct vtdtr_ctrlq *cq, char *from)
+{
+	printf("%s", from);
+
+	struct vtdtr_ctrl_entry *ctrl_entry, *ctrl_entry_temp;
+
+	if (!STAILQ_EMPTY(&cq->head))
+		STAILQ_FOREACH_SAFE(ctrl_entry, &cq->head, entries, ctrl_entry_temp)
+		{
+			printf("%d \n", ctrl_entry->ctrl.uctrl.trace_ev.dtbd_size);
+		}
+	else
+		printf("Control queue is empty. \n");
+}
+
 /*
  * Here we initialize the device. This is largely boilerplate. Here we
  * initialize all of the necessary mutexes, condition variables, threads, the
@@ -283,14 +364,26 @@ vtdtr_attach(device_t dev)
 	vtdtr_destroy_prov = vtdtr_destroy_prov_priv;
 	vtdtr_advertise_probe = vtdtr_advertise_probe_priv;
 	*/
+	tq = malloc(sizeof(struct vtdtr_traceq), M_DEVBUF, M_NOWAIT | M_ZERO);
+
+	if (tq == NULL)
+	{
+		error = ENOMEM;
+		device_printf(dev, "cannot allocate memory for the trace queue");
+		goto fail;
+	}
+	mtx_init(&tq->mtx, "vtdtrtqmtx", NULL, MTX_DEF);
+
+	vtdtr_tq_init(tq);
 
 	sc->vtdtr_ctrlq = malloc(sizeof(struct vtdtr_ctrlq),
-	    M_DEVBUF, M_NOWAIT | M_ZERO);
+							 M_DEVBUF, M_NOWAIT | M_ZERO);
 
-	if (sc->vtdtr_ctrlq == NULL) {
+	if (sc->vtdtr_ctrlq == NULL)
+	{
 		error = ENOMEM;
 		device_printf(dev, "cannot allocate memory"
-		    " for the control queue");
+						   " for the control queue");
 		goto fail;
 	}
 	mtx_init(&sc->vtdtr_ctrlq->mtx, "vtdtrctrlqmtx", NULL, MTX_DEF);
@@ -298,11 +391,12 @@ vtdtr_attach(device_t dev)
 	vtdtr_cq_init(sc->vtdtr_ctrlq);
 
 	sc->vtdtr_probelist = malloc(sizeof(struct vtdtr_probelist),
-	    M_VTDTR, M_NOWAIT | M_ZERO);
-	if (sc->vtdtr_probelist == NULL) {
+								 M_DEVBUF, M_NOWAIT | M_ZERO);
+	if (sc->vtdtr_probelist == NULL)
+	{
 		error = ENOMEM;
 		device_printf(dev, "cannot allocate memory"
-		    " for the probe list");
+						   " for the probe list");
 		goto fail;
 	}
 	LIST_INIT(&sc->vtdtr_probelist->head);
@@ -312,50 +406,64 @@ vtdtr_attach(device_t dev)
 	vtdtr_setup_features(sc);
 
 	error = vtdtr_init_rxq(sc, 0);
-	if (error) {
+	if (error)
+	{
 		device_printf(dev, "cannot initialize RX queue\n");
 		goto fail;
 	}
 
 	error = vtdtr_init_txq(sc, 0);
-	if (error) {
+	if (error)
+	{
 		device_printf(dev, "cannot initialize TX queue\n");
 		goto fail;
 	}
 
 	error = vtdtr_alloc_virtqueues(sc);
-	if (error) {
+	if (error)
+	{
 		device_printf(dev, "cannot allocate virtqueues\n");
 		goto fail;
 	}
 
 	device_printf(dev, "txq = %s, rxq = %s\n",
-	    sc->vtdtr_txq.vtdq_name, sc->vtdtr_rxq.vtdq_name);
+				  sc->vtdtr_txq.vtdq_name, sc->vtdtr_rxq.vtdq_name);
 
 	error = vtdtr_queue_populate(&sc->vtdtr_rxq);
-	if (error) {
+	if (error)
+	{
 		device_printf(dev, "cannot populate %s\n",
-		    sc->vtdtr_rxq.vtdq_name);
+					  sc->vtdtr_rxq.vtdq_name);
 		goto fail;
 	}
 
 	error = virtio_setup_intr(dev, INTR_TYPE_MISC);
-	if (error) {
+	if (error)
+	{
 		device_printf(dev, "cannot set up virtio interrupts\n");
 		goto fail;
 	}
 
+	sc->vtdtr_commtd = malloc(sizeof(struct thread), M_DEVBUF,
+							  M_NOWAIT | M_ZERO);
+	sc->vtdtr_listd = malloc(sizeof(struct thread), M_DEVBUF,
+							 M_NOWAIT | M_ZERO);
 
-
-	sc->vtdtr_commtd = malloc(sizeof(struct thread), M_VTDTR,
-	    M_NOWAIT | M_ZERO);
-
-	if (sc->vtdtr_commtd == NULL) {
+	if (sc->vtdtr_commtd == NULL)
+	{
 		error = ENOMEM;
 		device_printf(dev, "cannot allocate memory"
-		    " for the communicator thread");
+						   " for the communicator thread");
 		goto fail;
 	}
+
+	if (sc->vtdtr_listd == NULL)
+	{
+		error = ENOMEM;
+		device_printf(dev, "cannot allocate memory"
+						   " for the trace listener thread");
+	}
+
 	cv_init(&sc->vtdtr_condvar, "Virtio DTrace CV");
 	mtx_init(&sc->vtdtr_condmtx, "vtdtrcondmtx", NULL, MTX_DEF);
 	sema_init(&sc->vtdtr_exit, 0, "vtdtrexitsema");
@@ -366,7 +474,8 @@ vtdtr_attach(device_t dev)
 	sc->vtdtr_ready = 0;
 	vtdtr_notify_ready(sc);
 	kthread_add(vtdtr_run, sc, NULL, &sc->vtdtr_commtd,
-	    0, 0, NULL, "vtdtr_communicator");
+				0, 0, NULL, "vtdtr_communicator");
+	kthread_add(vtdtr_consume_trace, sc, NULL, &sc->vtdtr_listd, 0, 0, NULL, "vtdtr_trace_data_consumer");
 
 	/*dtrace_vtdtr_enable((void *)sc);*/
 fail:
@@ -382,7 +491,8 @@ vtdtr_cq_destroy(struct vtdtr_ctrlq *cq)
 	struct vtdtr_ctrl_entry *n1, *n2;
 	mtx_lock(&cq->mtx);
 	n1 = STAILQ_FIRST(&cq->head);
-	while (n1 != NULL) {
+	while (n1 != NULL)
+	{
 		n2 = STAILQ_NEXT(n1, entries);
 		free(n1, M_DEVBUF);
 		n1 = n2;
@@ -403,7 +513,7 @@ vtdtr_condvar_destroy(struct vtdtr_softc *sc)
 }
 
 /*
- * Here we free all the used memory in the
+ * Here used memory in the
  * driver, drain all the taskqeueues and
  * destroy all the mutexes.
  */
@@ -411,6 +521,7 @@ static int
 vtdtr_detach(device_t dev)
 {
 	struct vtdtr_softc *sc;
+	;
 
 	sc = device_get_softc(dev);
 
@@ -493,9 +604,9 @@ vtdtr_alloc_virtqueues(struct vtdtr_softc *sc)
 		return (ENOMEM);
 
 	VQ_ALLOC_INFO_INIT(&info[0], sc->vtdtr_rx_nseg, rxq->vtdq_vqintr, sc,
-	    &rxq->vtdq_vq, "%s-control RX", device_get_nameunit(dev));
+					   &rxq->vtdq_vq, "%s-control RX", device_get_nameunit(dev));
 	VQ_ALLOC_INFO_INIT(&info[1], sc->vtdtr_tx_nseg, txq->vtdq_vqintr, sc,
-	    &txq->vtdq_vq, "%s-control TX", device_get_nameunit(dev));
+					   &txq->vtdq_vq, "%s-control TX", device_get_nameunit(dev));
 
 	error = virtio_alloc_virtqueues(dev, 0, 2, info);
 	free(info, M_TEMP);
@@ -521,7 +632,7 @@ vtdtr_stop(struct vtdtr_softc *sc)
  */
 static void
 vtdtr_queue_requeue_ctrl(struct virtio_dtrace_queue *q,
-    struct virtio_dtrace_control *ctrl, int readable, int writable)
+						 struct virtio_dtrace_control *ctrl, int readable, int writable)
 {
 	struct vtdtr_softc *sc;
 	device_t dev;
@@ -533,7 +644,7 @@ vtdtr_queue_requeue_ctrl(struct virtio_dtrace_queue *q,
 	bzero(ctrl, sizeof(struct virtio_dtrace_control));
 	error = vtdtr_queue_enqueue_ctrl(q, ctrl, readable, writable);
 	KASSERT(error == 0, ("%s: cannot requeue control buffer %d",
-	    __func__, error));
+						 __func__, error));
 }
 
 /*
@@ -549,13 +660,15 @@ vtdtr_queue_populate(struct virtio_dtrace_queue *q)
 	vq = q->vtdq_vq;
 	error = ENOSPC;
 
-	for (nbufs = 0; !virtqueue_full(vq); nbufs++) {
+	for (nbufs = 0; !virtqueue_full(vq); nbufs++)
+	{
 		error = vtdtr_queue_new_ctrl(q);
 		if (error)
 			break;
 	}
 
-	if (nbufs > 0) {
+	if (nbufs > 0)
+	{
 		virtqueue_notify(vq);
 		error = 0;
 	}
@@ -576,7 +689,7 @@ vtdtr_queue_new_ctrl(struct virtio_dtrace_queue *q)
 
 	sc = q->vtdq_sc;
 	ctrl = malloc(sizeof(struct virtio_dtrace_control),
-	    M_DEVBUF, M_NOWAIT | M_ZERO);
+				  M_DEVBUF, M_NOWAIT | M_ZERO);
 	if (ctrl == NULL)
 		return (ENOMEM);
 
@@ -595,7 +708,7 @@ vtdtr_queue_new_ctrl(struct virtio_dtrace_queue *q)
  */
 static int
 vtdtr_queue_enqueue_ctrl(struct virtio_dtrace_queue *q,
-    struct virtio_dtrace_control *ctrl, int readable, int writable)
+						 struct virtio_dtrace_control *ctrl, int readable, int writable)
 {
 	struct sglist_seg seg;
 	struct sglist sg;
@@ -607,7 +720,7 @@ vtdtr_queue_enqueue_ctrl(struct virtio_dtrace_queue *q,
 	sglist_init(&sg, 1, &seg);
 	error = sglist_append(&sg, ctrl, sizeof(struct virtio_dtrace_control));
 	KASSERT(error == 0, ("%s: error %d adding control to sglist",
-	    __func__, error));
+						 __func__, error));
 
 	error = virtqueue_enqueue(vq, ctrl, &sg, readable, writable);
 
@@ -620,11 +733,14 @@ vtdtr_queue_enqueue_ctrl(struct virtio_dtrace_queue *q,
  */
 static int
 vtdtr_ctrl_process_event(struct vtdtr_softc *sc,
-    struct virtio_dtrace_control *ctrl)
+						 struct virtio_dtrace_control *ctrl)
 {
 	struct vtdtr_ctrl_pbevent *pb;
 	struct vtdtr_ctrl_provevent *pv;
+	struct timeval tv;
+
 	device_t dev;
+	size_t d_script_length;
 	int retval;
 	int error;
 
@@ -632,49 +748,60 @@ vtdtr_ctrl_process_event(struct vtdtr_softc *sc,
 	retval = 0;
 	error = 0;
 
+	// #ifdef VTDTR
+	struct vtdtr_event *ev;
+	// #endif
+
+	int len;
+
 	/*
 	 * XXX: Double switch statement... meh.
 	 */
-	switch (ctrl->event) {
+	switch (ctrl->event)
+	{
 	case VIRTIO_DTRACE_DEVICE_READY:
-		if (debug)
-			device_printf(dev, "VIRTIO_DTRACE_DEVICE_READY\n");
+		// if (debug)
+			// device_printf(dev, "VIRTIO_DTRACE_DEVICE_READY\n");
 		sc->vtdtr_host_ready = 1;
 		break;
 	case VIRTIO_DTRACE_REGISTER:
-		if (debug)
-			device_printf(dev, "VIRTIO_DTRACE_REGISTER\n");
+		// if (debug)
+			// device_printf(dev, "VIRTIO_DTRACE_REGISTER\n");
 		sc->vtdtr_ready = 0;
 		pv = &ctrl->uctrl.prov_ev;
 		break;
 	case VIRTIO_DTRACE_UNREGISTER:
-		if (debug)
-			device_printf(dev, "VIRTIO_DTRACE_UNREGISTER\n");
+		// if (debug)
+		//	device_printf(dev, "VIRTIO_DTRACE_UNREGISTER\n");
 		sc->vtdtr_ready = 0;
 		pv = &ctrl->uctrl.prov_ev;
 		break;
 	case VIRTIO_DTRACE_DESTROY:
-		if (debug)
-			device_printf(dev, "VIRTIO_DTRACE_DESTROY\n");
+		// if (debug)
+		// 	device_printf(dev, "VIRTIO_DTRACE_DESTROY\n");
 		sc->vtdtr_ready = 0;
 		break;
 	case VIRTIO_DTRACE_PROBE_CREATE:
 		pb = &ctrl->uctrl.probe_ev;
-		if (debug)
-			device_printf(dev, "VIRTIO_DTRACE_PROBE_CREATE: %d\n", pb->probe);
+		// if (debug)
+		// 	device_printf(dev, "VIRTIO_DTRACE_PROBE_CREATE: %d\n", pb->probe);
 		sc->vtdtr_ready = 0;
 		break;
-	case VIRTIO_DTRACE_PROBE_INSTALL: {
+	case VIRTIO_DTRACE_PROBE_INSTALL:
+	{
 		sc->vtdtr_ready = 0;
 		pb = &ctrl->uctrl.probe_ev;
 
-		if (debug)
-			device_printf(dev, "VIRTIO_DTRACE_PROBE_INSTALL: %d\n", pb->probe);
-		if (vstate == 0) {
+		// if (debug)
+		//	device_printf(dev, "VIRTIO_DTRACE_PROBE_INSTALL: %d\n", pb->probe);
+		if (vstate == 0)
+		{
 			error = dtrace_virtstate_create();
-			if (error) {
+			if (error)
+			{
 				device_printf(dev, "%s: error %d creating "
-				    "virtstate", __func__, error);
+								   "virtstate",
+							  __func__, error);
 				break;
 			}
 
@@ -685,17 +812,38 @@ vtdtr_ctrl_process_event(struct vtdtr_softc *sc,
 		KASSERT(vstate == 1, ("vstate must be 1\n"));
 		dtrace_provide_all_probes();
 		error = dtrace_probeid_enable(pb->probe);
-		if (error) {
+		if (error)
+		{
 			device_printf(dev, "%s: error %d enabling"
-			    " probe %d\n", __func__, error, pb->probe);
+							   " probe %d\n",
+						  __func__, error, pb->probe);
 		}
 		break;
 	}
+	case VIRTIO_DTRACE_SCRIPT:
+		sc->vtdtr_ready = 0;
+		ev = malloc(sizeof(struct vtdtr_event), M_TEMP, M_ZERO);
+		KASSERT(ev != NULL, ("Malloc event failed.\n"));
+		d_script_length = strlen(ctrl->uctrl.script_ev.d_script);
+
+		// if (debug)
+		//	device_printf(dev, "Length of the script is %d. \n", d_script_length);
+
+		ev->type = VTDTR_EV_SCRIPT;
+		ev->args.d_script.last = ctrl->uctrl.script_ev.last;
+		if ((strlcpy(ev->args.d_script.script, ctrl->uctrl.script_ev.d_script, d_script_length + 1)) != d_script_length)
+			device_printf(dev, "Error occured when copying script from control event. \n");
+		vtdtr_enqueue(ev);
+
+		// if (debug)
+		// device_printf(dev, "I've enqueued %s.\n",
+		//				  ev->args.d_script.script);
+		break;
 	case VIRTIO_DTRACE_GO:
 		sc->vtdtr_ready = 0;
 
-		if (debug)
-			device_printf(dev, "VIRTIO_DTRACE_GO\n");
+		// if (debug)
+		// 	device_printf(dev, "VIRTIO_DTRACE_GO\n");
 
 		error = dtrace_virtstate_go();
 		if (error)
@@ -707,8 +855,8 @@ vtdtr_ctrl_process_event(struct vtdtr_softc *sc,
 		sc->vtdtr_ready = 0;
 		KASSERT(vstate == 1, ("vstate must exist\n"));
 
-		if (debug)
-			device_printf(dev, "VIRTIO_DTRACE_STOP\n");
+		// if (debug)
+		// 	device_printf(dev, "VIRTIO_DTRACE_STOP\n");
 
 		error = dtrace_virtstate_stop();
 		if (error)
@@ -720,12 +868,13 @@ vtdtr_ctrl_process_event(struct vtdtr_softc *sc,
 		vstate = 0;
 		break;
 	case VIRTIO_DTRACE_EOF:
-		if (debug)
-			device_printf(dev, "VIRTIO_DTRACE_EOF\n");
+		// if (debug)
+		// 	device_printf(dev, "VIRTIO_DTRACE_EOF\n");
 		retval = 1;
 		break;
 	default:
 		device_printf(dev, "WARNING: Wrong control event: %x\n", ctrl->event);
+		break;
 	}
 
 	return (retval);
@@ -744,10 +893,11 @@ vtdtr_destroy_probelist(struct vtdtr_softc *sc)
 	tmp = NULL;
 
 	mtx_lock(&list->mtx);
-	while (!LIST_EMPTY(&list->head)) {
+	while (!LIST_EMPTY(&list->head))
+	{
 		tmp = LIST_FIRST(&list->head);
 		LIST_REMOVE(tmp, vtdprobe_next);
-		free(tmp, M_VTDTR);
+		free(tmp, M_DEVBUF);
 	}
 	mtx_unlock(&list->mtx);
 }
@@ -769,10 +919,10 @@ vtdtr_start_taskqueues(struct vtdtr_softc *sc)
 	txq = &sc->vtdtr_txq;
 
 	error = taskqueue_start_threads(&rxq->vtdq_tq, 1, PI_SOFT,
-	    "%s rxq %d", device_get_nameunit(dev), rxq->vtdq_id);
+									"%s rxq %d", device_get_nameunit(dev), rxq->vtdq_id);
 	if (error)
 		device_printf(dev, "failed to start rx taskq %d\n",
-		    txq->vtdq_id);
+					  txq->vtdq_id);
 }
 
 /*
@@ -797,7 +947,7 @@ static void
 vtdtr_drain_virtqueues(struct vtdtr_softc *sc)
 {
 	struct virtio_dtrace_queue *rxq, *txq;
-	struct virtio_dtrac_control *ctrl;
+	struct virtio_dtrace_control *ctrl;
 	struct virtqueue *vq;
 	uint32_t last;
 
@@ -805,6 +955,8 @@ vtdtr_drain_virtqueues(struct vtdtr_softc *sc)
 	txq = &sc->vtdtr_txq;
 	last = 0;
 
+	// confusion
+
 	vq = rxq->vtdq_vq;
 
 	while ((ctrl = virtqueue_drain(vq, &last)) != NULL)
@@ -838,13 +990,12 @@ vtdtr_enable_interrupts(struct vtdtr_softc *sc)
 	retval = vtdtr_vq_enable_intr(&sc->vtdtr_rxq);
 	retval = vtdtr_vq_enable_intr(&sc->vtdtr_txq);
 	mtx_unlock(&sc->vtdtr_mtx);
-
 }
 
 /*
  * A wrapper function to enable interrupts in a virtqueue
  */
-static int 
+static int
 vtdtr_vq_enable_intr(struct virtio_dtrace_queue *q)
 {
 	struct vtdtr_softc *sc;
@@ -860,7 +1011,7 @@ static void
 vtdtr_vq_disable_intr(struct virtio_dtrace_queue *q)
 {
 	struct vtdtr_softc *sc;
-    sc = q->vtdq_sc;
+	sc = q->vtdq_sc;
 	mtx_assert(&sc->vtdtr_mtx, MA_OWNED);
 	virtqueue_disable_intr(q->vtdq_vq);
 }
@@ -870,9 +1021,9 @@ vtdtr_send_eof(struct virtio_dtrace_queue *q)
 {
 	struct virtio_dtrace_control *ctrl;
 	ctrl = malloc(sizeof(struct virtio_dtrace_control),
-	    M_DEVBUF, M_NOWAIT | M_ZERO);
+				  M_DEVBUF, M_NOWAIT | M_ZERO);
 	KASSERT(ctrl != NULL,
-	    ("%s: no memory to allocate a control message", __func__));
+			("%s: no memory to allocate a control message", __func__));
 	ctrl->event = VIRTIO_DTRACE_EOF;
 	vtdtr_fill_desc(q, ctrl);
 }
@@ -896,9 +1047,10 @@ vtdtr_notify_ready(struct vtdtr_softc *sc)
 	sc->vtdtr_ready = 1;
 
 	ctrl_entry = malloc(sizeof(struct vtdtr_ctrl_entry),
-	    M_DEVBUF, M_NOWAIT | M_ZERO);
+						M_DEVBUF, M_NOWAIT | M_ZERO);
 
-	if (ctrl_entry == NULL) {
+	if (ctrl_entry == NULL)
+	{
 		device_printf(dev, "no memory to allocate a control entry");
 		return;
 	}
@@ -939,10 +1091,11 @@ vtdtr_rxq_tq_intr(void *xrxq, int pending)
 	retval = 0;
 
 	VTDTR_QUEUE_LOCK(rxq);
-	while ((ctrl = virtqueue_dequeue(rxq->vtdq_vq, &len)) != NULL) {
+	while ((ctrl = virtqueue_dequeue(rxq->vtdq_vq, &len)) != NULL)
+	{
 		KASSERT(len == sizeof(struct virtio_dtrace_control),
-		    ("%s: wrong control message length: %u, expected %zu",
-		     __func__, len, sizeof(struct virtio_dtrace_control)));
+				("%s: wrong control message length: %u, expected %zu",
+				 __func__, len, sizeof(struct virtio_dtrace_control)));
 
 		VTDTR_QUEUE_UNLOCK(rxq);
 		retval = vtdtr_ctrl_process_event(sc, ctrl);
@@ -1022,7 +1175,7 @@ vtdtr_init_rxq(struct vtdtr_softc *sc, int id)
 	rxq = &sc->vtdtr_rxq;
 
 	snprintf(rxq->vtdq_name, sizeof(rxq->vtdq_name), "%s-rx%d",
-	    device_get_nameunit(sc->vtdtr_dev), id);
+			 device_get_nameunit(sc->vtdtr_dev), id);
 	mtx_init(&rxq->vtdq_mtx, rxq->vtdq_name, NULL, MTX_DEF);
 
 	rxq->vtdq_sc = sc;
@@ -1030,7 +1183,7 @@ vtdtr_init_rxq(struct vtdtr_softc *sc, int id)
 
 	TASK_INIT(&rxq->vtdq_intrtask, 0, vtdtr_rxq_tq_intr, rxq);
 	rxq->vtdq_tq = taskqueue_create(rxq->vtdq_name, M_NOWAIT,
-	    taskqueue_thread_enqueue, &rxq->vtdq_tq);
+									taskqueue_thread_enqueue, &rxq->vtdq_tq);
 
 	return (rxq->vtdq_tq == NULL ? ENOMEM : 0);
 }
@@ -1053,7 +1206,7 @@ vtdtr_init_txq(struct vtdtr_softc *sc, int id)
 	txq = &sc->vtdtr_txq;
 
 	snprintf(txq->vtdq_name, sizeof(txq->vtdq_name), "%s-tx%d",
-	    device_get_nameunit(sc->vtdtr_dev), id);
+			 device_get_nameunit(sc->vtdtr_dev), id);
 	mtx_init(&txq->vtdq_mtx, txq->vtdq_name, NULL, MTX_DEF);
 
 	txq->vtdq_sc = sc;
@@ -1080,7 +1233,7 @@ vtdtr_queue_destroy(struct virtio_dtrace_queue *q)
  */
 static void
 vtdtr_fill_desc(struct virtio_dtrace_queue *q,
-    struct virtio_dtrace_control *ctrl)
+				struct virtio_dtrace_control *ctrl)
 {
 	VTDTR_QUEUE_LOCK(q);
 	vtdtr_queue_enqueue_ctrl(q, ctrl, 1, 0);
@@ -1097,7 +1250,7 @@ vtdtr_cq_init(struct vtdtr_ctrlq *cq)
 
 static __inline void
 vtdtr_cq_enqueue(struct vtdtr_ctrlq *cq,
-    struct vtdtr_ctrl_entry *ctrl_entry)
+				 struct vtdtr_ctrl_entry *ctrl_entry)
 {
 
 	STAILQ_INSERT_TAIL(&cq->head, ctrl_entry, entries);
@@ -1106,7 +1259,7 @@ vtdtr_cq_enqueue(struct vtdtr_ctrlq *cq,
 
 static __inline void
 vtdtr_cq_enqueue_front(struct vtdtr_ctrlq *cq,
-    struct vtdtr_ctrl_entry *ctrl_entry)
+					   struct vtdtr_ctrl_entry *ctrl_entry)
 {
 
 	STAILQ_INSERT_HEAD(&cq->head, ctrl_entry, entries);
@@ -1132,7 +1285,8 @@ vtdtr_cq_dequeue(struct vtdtr_ctrlq *cq)
 {
 	struct vtdtr_ctrl_entry *ctrl_entry;
 	ctrl_entry = STAILQ_FIRST(&cq->head);
-	if (ctrl_entry != NULL) {
+	if (ctrl_entry != NULL)
+	{
 		STAILQ_REMOVE_HEAD(&cq->head, entries);
 		cq->n_entries--;
 	}
@@ -1165,6 +1319,192 @@ vtdtr_poll(struct virtio_dtrace_queue *q)
 	VTDTR_QUEUE_UNLOCK(q);
 }
 
+static void
+vtdtr_consume_trace(void *xsc)
+{
+	struct vtdtr_ctrlq *cq;
+	struct vtdtr_softc *sc;
+	struct vtdtr_ctrl_entry *ctrl_entry;
+	struct vtdtr_trace_entry *trc_entry;
+	struct virtio_dtrace_control *ctrl;
+	struct virtio_dtrace_trace *trc;
+	struct virtio_dtrace_metadata *mtd;
+	struct vtdtr_ctrl_trcevent *ctrl_trc_ev;
+	struct vtdtr_ctrl_metaevent *ctrl_mtd_ev;
+	struct timeval tv;
+
+	device_t dev;
+	size_t trc_buf_len, epdesc_len, pbdesc_len, fmt_len;
+	size_t cp;
+	int error;
+	
+
+	char *data;
+	uint64_t data_sz, to_send;
+
+	sc = xsc;
+	cq = sc->vtdtr_ctrlq;
+	dev = sc->vtdtr_dev;
+	for (;;)
+	{
+		mtx_lock(&tq->mtx);
+		while (!vtdtr_tq_empty(tq))
+		{
+			// microtime(&tv);
+			// device_printf("Got a metadata/trace event in %ld s. \n", tv.tv_sec);
+			// vtdtr_tq_print(tq, "In virtio_dtrace, before dequeue.");
+			trc_entry = vtdtr_tq_dequeue(tq);
+			// vtdtr_tq_print(tq, "In virtio_dtrace, after dequeue.");
+
+			ctrl_entry = malloc(sizeof(struct vtdtr_ctrl_entry), M_DEVBUF, M_NOWAIT | M_ZERO);
+			KASSERT(ctrl_entry != NULL, "Failed allocating memory for control entry.");
+			memset(ctrl_entry, 0, sizeof(struct vtdtr_ctrl_entry));
+
+			switch (trc_entry->type)
+			{
+			case DDTRACE_TRACE:
+				trc = &trc_entry->uentry.trace;
+				// device_printf(dev, "Trace data size: %zu. \n", trc->dtbd_size);
+				// device_printf(dev, "%s", trc->dtbd_data);
+				KASSERT(trc->dtbd_data != NULL, "Trace data buffer cannot be NULL.");
+
+				ctrl = &ctrl_entry->ctrl;
+				ctrl->event = VIRTIO_DTRACE_TRACE;
+				ctrl_trc_ev = &ctrl->uctrl.trace_ev;
+
+				ctrl_trc_ev->dtbd_size = trc->dtbd_size;
+				ctrl_trc_ev->dtbd_cpu = trc->dtbd_cpu;
+				ctrl_trc_ev->dtbd_errors = trc->dtbd_errors;
+				ctrl_trc_ev->dtbd_drops = trc->dtbd_drops;
+				ctrl_trc_ev->dtbd_oldest = trc->dtbd_oldest;
+				ctrl_trc_ev->dtbd_timestamp = trc->dtbd_timestamp;
+				KASSERT(ctrl_trc_ev->dtbd_size == trc->dtbd_size, "Failed copying into fields");
+
+				data = trc->dtbd_data;
+				data_sz = trc->dtbd_size;
+				KASSERT(data_sz == ctrl_trc_ev->dtbd_size, "Invalid trace buffer size");
+				// device_printf(dev, "Data size is (before anything): %d. \n", data_sz);
+				to_send = (data_sz > FRAGMENTSZ) ? FRAGMENTSZ : data_sz;
+				// device_printf(dev, "Will send: %d", to_send);
+				ctrl_trc_ev->first_chunk = 1;
+				ctrl_trc_ev->last_chunk = (data_sz > FRAGMENTSZ) ? 0 : 1;
+				// device_printf(dev, "Is first chunk: %d?\n", ctrl_trc_ev->first_chunk);
+				// device_printf(dev, "Is last chunk: %d?\n", ctrl_trc_ev->last_chunk);
+				data_sz -= to_send;
+				
+				ctrl_trc_ev->chunk_sz = to_send;
+				// device_printf(dev, "Chunk size is: %d. \n", ctrl_trc_ev->chunk_sz);
+				memcpy(ctrl_trc_ev->dtbd_chunk, data, to_send);
+				//device_printf(dev, "%s", ctrl_trc_ev->dtbd_chunk);
+
+				mtx_lock(&sc->vtdtr_ctrlq->mtx);
+				vtdtr_cq_enqueue(sc->vtdtr_ctrlq, ctrl_entry);
+				mtx_unlock(&sc->vtdtr_ctrlq->mtx);
+
+				mtx_lock(&sc->vtdtr_condmtx);
+				cv_signal(&sc->vtdtr_condvar);
+				mtx_unlock(&sc->vtdtr_condmtx);
+
+				// device_printf(dev, "Data size is (outside for loop): %d. \n", data_sz);
+				while (data_sz > 0)
+				{
+					// device_printf(dev, "Data size is (in for loop): %d. \n", data_sz);
+					data += to_send;
+					ctrl_entry = malloc(sizeof(struct vtdtr_ctrl_entry), M_DEVBUF, M_NOWAIT | M_ZERO);
+					KASSERT(ctrl_entry != NULL, "Failed allocating memory for control entry.");
+					memset(ctrl_entry, 0, sizeof(struct vtdtr_ctrl_entry));
+
+					ctrl = &ctrl_entry->ctrl;
+					ctrl->event = VIRTIO_DTRACE_TRACE;
+					ctrl_trc_ev = &ctrl->uctrl.trace_ev;
+					ctrl_trc_ev->first_chunk = 0;
+					ctrl_trc_ev->last_chunk = (data_sz > FRAGMENTSZ) ? 0 : 1;
+					to_send = (data_sz > FRAGMENTSZ) ? FRAGMENTSZ : data_sz;
+					data_sz -= to_send;
+
+					ctrl_trc_ev->chunk_sz = to_send;
+					memcpy(ctrl_trc_ev->dtbd_chunk, data, to_send);
+				
+					mtx_lock(&sc->vtdtr_ctrlq->mtx);
+					vtdtr_cq_enqueue(sc->vtdtr_ctrlq, ctrl_entry);
+					mtx_unlock(&sc->vtdtr_ctrlq->mtx);
+
+					mtx_lock(&sc->vtdtr_condmtx);
+					cv_signal(&sc->vtdtr_condvar);
+					mtx_unlock(&sc->vtdtr_condmtx);
+				}
+			
+			break;
+		case DDTRACE_METADATA:
+			mtd = &trc_entry->uentry.metadata;
+			ctrl = &ctrl_entry->ctrl;
+			ctrl->event = VIRTIO_DTRACE_METADATA;
+			ctrl_mtd_ev = &ctrl->uctrl.meta_ev;
+			ctrl_mtd_ev->type = mtd->type;
+			switch (mtd->type)
+			{
+			case NFORMAT:
+				ctrl_mtd_ev->umtd.dts_nformats = mtd->umtd.dts_nformats;
+				// device_printf(dev, "Put NFORMAT in control entry: %d. \n", ctrl_mtd_ev->umtd.dts_nformats);
+				break;
+			case FORMAT_STRING:
+				fmt_len = strlen(mtd->umtd.dts_fmtstr);
+				//device_printf(dev, "Format string length is: %d. \n", fmt_len);
+				if (fmt_len < FRAGMENTSZ)
+				{
+					cp = strlcpy(ctrl_mtd_ev->umtd.dts_fmtstr, mtd->umtd.dts_fmtstr, fmt_len + 1);
+					KASSERT(cp == fmt_len, "Error occurred while copying format string");
+					//device_printf(dev, "Successfully added format string to control entry: %s.\n", ctrl_mtd_ev->umtd.dts_fmtstr);
+				}
+				else
+				{
+					device_printf(dev, "Format string doesn't fit in control element");
+				}
+				break;
+			case NPROBES:
+				ctrl_mtd_ev->umtd.dtrace_nprobes = mtd->umtd.dtrace_nprobes;
+				// device_printf(dev, "Number of probes is: %d. \n", ctrl_mtd_ev->umtd.dtrace_nprobes);
+				break;
+			case NPDESC:
+				ctrl_mtd_ev->umtd.dt_npdescs = mtd->umtd.dt_npdescs;
+				//device_printf(dev, "Number of probes descriptions is: %d. \n", ctrl_mtd_ev->umtd.dt_npdescs);
+				break;
+			case PROBE_DESCRIPTION:
+				ctrl_mtd_ev->umtd.dt_pdesc.buf_size = mtd->umtd.dt_pdesc.buf_size;
+				KASSERT(ctrl_mtd_ev->umtd.dt_pdesc.buf_size == sizeof(dtrace_probedesc_t), "Probe description size is invalid");
+				memcpy(ctrl_mtd_ev->umtd.dt_pdesc.buf, mtd->umtd.dt_pdesc.buf, sizeof(dtrace_probedesc_t));
+				break;
+			case EPROBE_DESCRIPTION:
+				ctrl_mtd_ev->umtd.dt_epdesc.buf_size = mtd->umtd.dt_epdesc.buf_size;
+				memcpy(ctrl_mtd_ev->umtd.dt_epdesc.buf,
+					   mtd->umtd.dt_epdesc.buf,
+					   mtd->umtd.dt_epdesc.buf_size);
+				// device_printf(dev, "Eprobe description size: %d", ctrl_mtd_ev->umtd.dt_epdesc.buf_size);
+				break;
+			default:
+				device_printf(dev, "WARNING: Wrong metadata event.");
+				break;
+			}
+			mtx_lock(&sc->vtdtr_ctrlq->mtx);
+			vtdtr_cq_enqueue(sc->vtdtr_ctrlq, ctrl_entry);
+			mtx_unlock(&sc->vtdtr_ctrlq->mtx);
+
+			mtx_lock(&sc->vtdtr_condmtx);
+			cv_signal(&sc->vtdtr_condvar);
+			mtx_unlock(&sc->vtdtr_condmtx);
+			break;
+		default:
+			device_printf(dev, "WARNING: Wrong trace queue event.");
+			break;
+		}
+		
+		vtdtr_notify_ready(sc);
+		free(trc_entry, M_DEVBUF);
+	}
+	mtx_unlock(&tq->mtx);
+}
+}
+
 /*
  * This is the communicator thread. It is responsible for spinning until we shut
  * down and sending messages to the emulated PCI device on the host.
@@ -1190,16 +1530,19 @@ vtdtr_run(void *xsc)
 	vq_size = virtqueue_size(vq);
 
 	ctrls = malloc(sizeof(struct virtio_dtrace_control) *
-	    vq_size, M_VTDTR, M_NOWAIT | M_ZERO);
-	if (ctrls == NULL) {
+					   vq_size,
+				   M_DEVBUF, M_NOWAIT | M_ZERO);
+	if (ctrls == NULL)
+	{
 		panic("No memory for vtdtr_run()");
 	}
 
-	for (;;) {
+	for (;;)
+	{
 		nent = 0;
 		ready_flag = 1;
 		memset(ctrls, 0,
-		    vq_size * sizeof(struct virtio_dtrace_control));
+			   vq_size * sizeof(struct virtio_dtrace_control));
 
 		mtx_lock(&sc->vtdtr_condmtx);
 		/*
@@ -1210,25 +1553,28 @@ vtdtr_run(void *xsc)
 		 * or if we are
 		 * (3) Shutting down
 		 */
+
 		while ((vtdtr_cq_empty(sc->vtdtr_ctrlq) ||
-		    !sc->vtdtr_host_ready)              &&
-		    (!sc->vtdtr_shutdown)) {
+				!sc->vtdtr_host_ready) &&
+			   (!sc->vtdtr_shutdown))
+		{
 			cv_wait(&sc->vtdtr_condvar, &sc->vtdtr_condmtx);
 		}
 		mtx_unlock(&sc->vtdtr_condmtx);
 
 		kthread_suspend_check();
 
-		if (sc->vtdtr_shutdown == 1) {
-			free(ctrls, M_VTDTR);
+		if (sc->vtdtr_shutdown == 1)
+		{
+			free(ctrls, M_DEVBUF);
 			sema_post(&sc->vtdtr_exit);
 			kthread_exit();
 		}
 
 		KASSERT(!virtqueue_full(vq),
-		    ("%s: virtqueue is full", __func__));
+				("%s: virtqueue is full", __func__));
 		KASSERT(!vtdtr_cq_empty(sc->vtdtr_ctrlq),
-		    ("%s: control queue is empty", __func__));
+				("%s: control queue is empty", __func__));
 
 		/*
 		 * Here we drain the control queue until it's either:
@@ -1242,17 +1588,26 @@ vtdtr_run(void *xsc)
 		 */
 		mtx_lock(&sc->vtdtr_ctrlq->mtx);
 		while (!virtqueue_full(vq) &&
-		    !vtdtr_cq_empty(sc->vtdtr_ctrlq)) {
+			   !vtdtr_cq_empty(sc->vtdtr_ctrlq))
+		{
 			ctrl_entry = vtdtr_cq_dequeue(sc->vtdtr_ctrlq);
 			mtx_unlock(&sc->vtdtr_ctrlq->mtx);
 			memcpy(&ctrls[nent], &ctrl_entry->ctrl,
-			    sizeof(struct virtio_dtrace_control));
+				   sizeof(struct virtio_dtrace_control));
 			if (ready_flag &&
-			    ctrls[nent].event != VIRTIO_DTRACE_DEVICE_READY)
+				ctrls[nent].event != VIRTIO_DTRACE_DEVICE_READY)
 				ready_flag = 0;
+			
+			// if(ctrl_entry->ctrl.event == VIRTIO_DTRACE_TRACE)
+			// {
+			// 	nanouptime(&tv1);
+			// 	device_printf(dev, "Time of send %ld s %ld ns\n", tv1.tv_sec, tv1.tv_nsec);
+			// }
 			vtdtr_fill_desc(txq, &ctrls[nent]);
 			free(ctrl_entry, M_DEVBUF);
 			nent++;
+			// check size of control element
+			//
 			mtx_lock(&sc->vtdtr_ctrlq->mtx);
 		}
 
@@ -1261,9 +1616,11 @@ vtdtr_run(void *xsc)
 		 * unless we have filled up the virtqueue. Otherwise, the EOF is
 		 * implicit.
 		 */
-		if (nent) {
+		if (nent)
+		{
 			if (vtdtr_cq_empty(sc->vtdtr_ctrlq) &&
-			   !virtqueue_full(vq)) {
+				!virtqueue_full(vq))
+			{
 				vtdtr_send_eof(txq);
 			}
 
@@ -1287,9 +1644,10 @@ vtdtr_advertise_prov_priv(void *xsc, const char *name, struct uuid *uuid)
 	dev = sc->vtdtr_dev;
 
 	ctrl_entry = malloc(sizeof(struct vtdtr_ctrl_entry),
-	    M_DEVBUF, M_NOWAIT | M_ZERO);
+						M_DEVBUF, M_NOWAIT | M_ZERO);
 
-	if (ctrl_entry == NULL) {
+	if (ctrl_entry == NULL)
+	{
 		device_printf(dev, "no memory to allocate a control entry");
 		return;
 	}
@@ -1320,9 +1678,10 @@ vtdtr_destroy_prov_priv(void *xsc, struct uuid *uuid)
 	dev = sc->vtdtr_dev;
 
 	ctrl_entry = malloc(sizeof(struct vtdtr_ctrl_entry),
-	    M_DEVBUF, M_NOWAIT | M_ZERO);
+						M_DEVBUF, M_NOWAIT | M_ZERO);
 
-	if (ctrl_entry == NULL) {
+	if (ctrl_entry == NULL)
+	{
 		device_printf(dev, "no memory to allocate a control entry");
 		return;
 	}
@@ -1342,7 +1701,7 @@ vtdtr_destroy_prov_priv(void *xsc, struct uuid *uuid)
 
 static void
 vtdtr_advertise_probe_priv(void *xsc, const char *mod, const char *func,
-    const char *name, struct uuid *uuid)
+						   const char *name, struct uuid *uuid)
 {
 	struct vtdtr_softc *sc;
 	struct vtdtr_ctrl_entry *ctrl_entry;
@@ -1354,9 +1713,10 @@ vtdtr_advertise_probe_priv(void *xsc, const char *mod, const char *func,
 	dev = sc->vtdtr_dev;
 
 	ctrl_entry = malloc(sizeof(struct vtdtr_ctrl_entry),
-	    M_DEVBUF, M_NOWAIT | M_ZERO);
+						M_DEVBUF, M_NOWAIT | M_ZERO);
 
-	if (ctrl_entry == NULL) {
+	if (ctrl_entry == NULL)
+	{
 		device_printf(dev, "no memory to allocate a control entry");
 		return;
 	}
diff --git a/sys/dev/virtio/dtrace/virtio_dtrace.h b/sys/dev/virtio/dtrace/virtio_dtrace.h
index d6190811fdc..249914db196 100644
--- a/sys/dev/virtio/dtrace/virtio_dtrace.h
+++ b/sys/dev/virtio/dtrace/virtio_dtrace.h
@@ -31,6 +31,7 @@
 
 #include <sys/queue.h>
 #include <sys/dtrace_bsd.h>
+#include <sys/dtrace.h>
 
 /*
  * The events related to probe installation and uninstallation are presently
@@ -52,6 +53,27 @@
 #define	VIRTIO_DTRACE_EOF             0x07 /* EOF Signal */
 #define	VIRTIO_DTRACE_GO              0x08 /* Start tracing */
 #define	VIRTIO_DTRACE_STOP            0x09 /* Start tracing */
+#define VIRTIO_DTRACE_SCRIPT 	      0x10 /* Receive script from host */
+#define VIRTIO_DTRACE_TRACE           0x11 /* Send trace data to host */
+#define VIRTIO_DTRACE_METADATA		  0x12 /* Send metadata to host */
+
+/*
+ * Events related to the type of metadata being sent.
+ */
+#define NFORMAT				        0x00
+#define FORMAT_STRING 				0x01
+#define NPROBES						0x02
+#define NPDESC						0x03
+#define PROBE_DESCRIPTION			0x04
+#define	EPROBE_DESCRIPTION 			0x05
+
+/**
+ *	Type of data put in the trace queue 
+ */
+#define DDTRACE_TRACE	        	0x00
+#define DDTRACE_METADATA			0x01
+
+#define FRAGMENTSZ            		4000
 
 struct vtdtr_softc;
 struct uuid;
@@ -81,15 +103,90 @@ struct vtdtr_ctrl_provevent {
 	struct uuid uuid;
 }__attribute__((packed));
 
+struct vtdtr_ctrl_scriptevent {
+	int last;
+	char d_script[FRAGMENTSZ];
+	struct uuid uuid;
+}__attribute__((packed));
+
+struct vtdtr_ctrl_trcevent {
+	int first_chunk;
+	int last_chunk;
+	uint64_t chunk_sz;
+	uint64_t dtbd_size;
+	uint32_t dtbd_cpu;
+	uint32_t dtbd_errors;
+	uint32_t dtbd_drops;
+	char dtbd_chunk[FRAGMENTSZ];
+	uint64_t dtbd_oldest;
+	uint64_t dtbd_timestamp;
+	struct uuid uuid;
+}__attribute__((packed));
+
+
+struct vtdtr_ctrl_metaevent {
+	uint32_t type;
+
+	union {
+		int dts_nformats;
+		char dts_fmtstr[FRAGMENTSZ];
+		int dtrace_nprobes;
+		int dt_npdescs;
+		struct {
+			size_t buf_size;
+			char buf[FRAGMENTSZ];
+		} dt_pdesc;
+		struct {
+			size_t buf_size;
+			char buf[FRAGMENTSZ];
+		} dt_epdesc;
+	} umtd;
+	struct uuid uuid;
+}__attribute__((packed));
+
 struct virtio_dtrace_control {
 	uint32_t event;
 
 	union {
 		struct vtdtr_ctrl_pbevent   probe_ev;
 		struct vtdtr_ctrl_provevent prov_ev;
+		struct vtdtr_ctrl_scriptevent script_ev;
+		struct vtdtr_ctrl_trcevent trace_ev;
+		struct vtdtr_ctrl_metaevent meta_ev;
 	} uctrl;
 }__attribute__((packed));
 
+struct virtio_dtrace_trace {
+	uint64_t dtbd_size;
+	uint32_t dtbd_cpu;
+	uint32_t dtbd_errors;
+	uint32_t dtbd_drops;
+	char *dtbd_data;
+	uint64_t dtbd_oldest;
+	uint64_t dtbd_timestamp;
+
+}__attribute__((packed));
+
+struct virtio_dtrace_metadata {
+	uint32_t type;
+
+	union {
+		int dts_nformats; /* number of format strings */
+		char *dts_fmtstr; /* format string */
+		int dtrace_nprobes; /* number of probes */
+		int dt_npdescs;
+		struct {
+			size_t buf_size;
+			char *buf; /* probe description buffer */
+		} dt_pdesc;
+		struct{
+			size_t buf_size;
+			char *buf; /* enabled probe description buffer */
+		} dt_epdesc;
+	} umtd;
+
+}__attribute__((packed));
+
 struct virtio_dtrace_queue {
 	struct mtx           vtdq_mtx;
 	struct vtdtr_softc  *vtdq_sc;
@@ -113,6 +210,31 @@ struct vtdtr_ctrlq {
 	size_t                               n_entries;
 };
 
+struct vtdtr_trace_entry {
+	uint32_t type;
+	
+	union {
+		struct virtio_dtrace_trace trace;
+		struct virtio_dtrace_metadata metadata;
+	} uentry;
+	STAILQ_ENTRY(vtdtr_trace_entry) entries;
+};
+
+
+struct vtdtr_traceq {
+	STAILQ_HEAD(, vtdtr_trace_entry) head;
+	struct mtx mtx;
+	size_t n_entries;
+};
+
+
+// return trace queue pointer (used for communicating with ddtrace)
+struct vtdtr_traceq *virtio_dtrace_device_register(void);
+
+// enqueue trace elements
+void vtdtr_tq_enqueue(struct vtdtr_traceq *, struct vtdtr_trace_entry *);
+
+
 // name only to be used by stdl start with _
 #define	VTDTR_QUEUE_LOCK(__q)   mtx_lock(&((__q)->vtdq_mtx))
 #define	VTDTR_QUEUE_UNLOCK(__q) mtx_unlock(&((__q)->vtdq_mtx))
diff --git a/sys/modules/ddtrace/Makefile b/sys/modules/ddtrace/Makefile
index 0b0d1047995..78e5716a36b 100644
--- a/sys/modules/ddtrace/Makefile
+++ b/sys/modules/ddtrace/Makefile
@@ -1,3 +1,4 @@
+  
 #-
 # Copyright (c) 2019 (Graeme Jenkinson)
 # All rights reserved.
@@ -39,4 +40,4 @@ CFLAGS+=-I${SRCTOP}/sys/cddl/contrib/opensolaris/uts/common/sys
 CFLAGS+=-I${SRCTOP}/sys
 CFLAGS+=-I${SRCTOP}/contrib/dlog/src
 
-.include <bsd.kmod.mk>
+.include <bsd.kmod.mk>
\ No newline at end of file
diff --git a/sys/modules/ddtrace/ddtrace.c b/sys/modules/ddtrace/ddtrace.c
index 8f1098e7adf..45b893be66a 100644
--- a/sys/modules/ddtrace/ddtrace.c
+++ b/sys/modules/ddtrace/ddtrace.c
@@ -56,6 +56,8 @@
 #include <sys/sysctl.h>
 #include <fs/devfs/devfs_int.h>
 #include <sys/eventhandler.h>
+#include <sys/time.h>
+#include <dev/virtio/dtrace/virtio_dtrace.h>
 
 #include <dtrace.h>
 #include <dtrace_impl.h>
@@ -66,10 +68,12 @@
 #include "dl_protocol.h"
 #include "dl_utils.h"
 
-extern hrtime_t dtrace_gethrtime(void);
+// extern hrtime_t dtrace_gethrtime(void);
 
-struct client {
-	LIST_ENTRY(client) client_entries;
+struct client
+{
+	LIST_ENTRY(client)
+	client_entries;
 	struct cv ddtrace_cv;
 	struct mtx ddtrace_mtx;
 	struct proc *ddtrace_pid;
@@ -89,7 +93,7 @@ static void ddtrace_thread(void *);
 static void ddtrace_buffer_switch(dtrace_state_t *, struct dlog_handle *);
 static int ddtrace_persist_metadata(dtrace_state_t *, struct dlog_handle *);
 static void ddtrace_persist_trace(dtrace_state_t *, struct dlog_handle *,
-    dtrace_bufdesc_t *);
+								  dtrace_bufdesc_t *);
 
 static void ddtrace_open(void *, struct dtrace_state *);
 static void ddtrace_close(void *, struct dtrace_state *);
@@ -102,26 +106,26 @@ static dtrace_dops_t dops = {
 static dtrace_dist_id_t did;
 
 extern kmutex_t dtrace_lock;
-extern dtrace_probe_t **dtrace_probes;	/* array of all probes */
-extern int dtrace_nprobes;		/* number of probes */
+extern dtrace_probe_t **dtrace_probes; /* array of all probes */
+extern int dtrace_nprobes;			   /* number of probes */
 
-static char const * const DDTRACE_NAME = "ddtrace";
-static char * DDTRACE_KEY = "ddtrace";
-static char * DDTRACE_EPROBE_KEY = "eprobe";
-static char * DDTRACE_FORMAT_KEY = "format";
-static char * DDTRACE_PROBE_KEY = "probe";
-static char * DDTRACE_NFORMAT_KEY = "nformat";
-static char * DDTRACE_NPROBE_KEY = "nprobe";
+static char const *const DDTRACE_NAME = "ddtrace";
+static char *DDTRACE_KEY = "ddtrace";
+static char *DDTRACE_EPROBE_KEY = "eprobe";
+static char *DDTRACE_FORMAT_KEY = "format";
+static char *DDTRACE_PROBE_KEY = "probe";
+static char *DDTRACE_NFORMAT_KEY = "nformat";
+static char *DDTRACE_NPROBE_KEY = "nprobe";
 
 static moduledata_t ddtrace_conf = {
 	DDTRACE_NAME,
 	ddtrace_event_handler,
-	NULL
-};
+	NULL};
 
 static const int DDTRACE_NHASH_BUCKETS = 16;
 static struct clients *ddtrace_hashtbl = NULL;
 static u_long ddtrace_hashmask;
+static struct timeval tval;
 
 SYSCTL_NODE(_kern, OID_AUTO, ddtrace, CTLFLAG_RW, 0, "DDTrace");
 
@@ -131,15 +135,15 @@ SYSCTL_NODE(_kern, OID_AUTO, ddtrace, CTLFLAG_RW, 0, "DDTrace");
  */
 static uint32_t ddtrace_poll_ms = 1000;
 SYSCTL_U32(_kern_ddtrace, OID_AUTO, poll_period_ms, CTLFLAG_RW,
-    &ddtrace_poll_ms, 0, "DDTrace poll period (ms)");
+		   &ddtrace_poll_ms, 0, "DDTrace poll period (ms)");
 
 /* Maximum record size before compression; the default value is a heurstic
  * based on the level of compression seen in DTrace buffers.
  */
-static uint32_t ddtrace_record_bound = 1024*1024;
+static uint32_t ddtrace_record_bound = 1024 * 1024;
 SYSCTL_U32(_kern_ddtrace, OID_AUTO, record_bound, CTLFLAG_RW,
-    &ddtrace_record_bound, 0,
-    "DDTrace maximum record size (before compression)");
+		   &ddtrace_record_bound, 0,
+		   "DDTrace maximum record size (before compression)");
 
 static eventhandler_tag ddtrace_pre_sync = NULL;
 
@@ -147,13 +151,13 @@ static inline void
 ddtrace_assert_integrity(const char *func, struct client *self)
 {
 
-	DL_ASSERT(self != NULL, ("%s client instance is NULL", func)); 
+	DL_ASSERT(self != NULL, ("%s client instance is NULL", func));
 	DL_ASSERT(self->ddtrace_dlog_handle != NULL,
-	    ("%s client instance Dlog handle field is NULL", func)); 
+			  ("%s client instance Dlog handle field is NULL", func));
 	DL_ASSERT(self->ddtrace_state != NULL,
-	    ("%s client instance DTrace state field is NULL", func)); 
+			  ("%s client instance DTrace state field is NULL", func));
 	DL_ASSERT(self->ddtrace_pid != NULL,
-	    ("%s client instance proc is field NULL", func)); 
+			  ("%s client instance proc is field NULL", func));
 }
 
 static int
@@ -161,42 +165,46 @@ ddtrace_event_handler(struct module *module, int event, void *arg)
 {
 	int e = 0;
 
-	switch(event) {
+	switch (event)
+	{
 	case MOD_LOAD:
 		DLOGTR0(PRIO_LOW, "Loading DDTrace kernel module\n");
 
 		/* Initialise the hash table of client instances. */
 		ddtrace_hashtbl = hashinit(DDTRACE_NHASH_BUCKETS, M_DDTRACE,
-		    &ddtrace_hashmask);
+								   &ddtrace_hashmask);
 		DL_ASSERT(ddtrace_hashtbl != NULL,
-		    ("Failed to allocate new client hash table instance."));
+				  ("Failed to allocate new client hash table instance."));
 
 		/* Register with DTrace. After successfully
 		 * registering the client with be informed of lifecycle
 		 * events (open/close) that result from DTrace consumers.
-		 */ 
+		 */
 		if (dtrace_dist_register(DDTRACE_NAME, &dops, NULL,
-		    &did) == 0) {
+								 &did) == 0)
+		{
 
 			DLOGTR0(PRIO_NORMAL,
-			    "Successfully registered with DTrace\n");
+					"Successfully registered with DTrace\n");
 
 			ddtrace_pre_sync = EVENTHANDLER_REGISTER(
-			    shutdown_pre_sync, ddtrace_stop, ddtrace_hashtbl,
-			    SHUTDOWN_PRI_DEFAULT);
-		} else {
+				shutdown_pre_sync, ddtrace_stop, ddtrace_hashtbl,
+				SHUTDOWN_PRI_DEFAULT);
+		}
+		else
+		{
 
 			DLOGTR0(PRIO_HIGH,
-			    "Failed to register with DTrace\n");
+					"Failed to register with DTrace\n");
 			e = -1;
 		}
 		break;
 	case MOD_UNLOAD:
 		DLOGTR0(PRIO_LOW, "Unloading DDTrace kernel module\n");
 
-		if (ddtrace_pre_sync != NULL)	
-		    EVENTHANDLER_DEREGISTER(shutdown_pre_sync, ddtrace_pre_sync);
-		
+		if (ddtrace_pre_sync != NULL)
+			EVENTHANDLER_DEREGISTER(shutdown_pre_sync, ddtrace_pre_sync);
+
 		ddtrace_stop(ddtrace_hashtbl);
 		break;
 	default:
@@ -212,42 +220,44 @@ ddtrace_stop(struct clients *ddtrace_hashtbl)
 {
 	struct client *k, *k_tmp;
 	int i, rc;
-	
-	/* Unregister and stop any client threads. */ 
-	for (i = 0; i < DDTRACE_NHASH_BUCKETS; i++) {	
+
+	/* Unregister and stop any client threads. */
+	for (i = 0; i < DDTRACE_NHASH_BUCKETS; i++)
+	{
 		LIST_FOREACH_SAFE(k, &ddtrace_hashtbl[i],
-		    client_entries, k_tmp) {
+						  client_entries, k_tmp)
+		{
 
 			DLOGTR1(PRIO_LOW,
-			    "Stopping client thread %p..\n", k);
+					"Stopping client thread %p..\n", k);
 			/* Signal client and wait for completion. */
 			mtx_lock(&k->ddtrace_mtx);
 			k->ddtrace_exit = 1;
 			mtx_unlock(&k->ddtrace_mtx);
 			cv_broadcast(&k->ddtrace_cv);
 			rc = tsleep(k->ddtrace_pid, 0,
-			    "Waiting for client process to stop",
-			    60 * (10 * hz / 9));
+						"Waiting for client process to stop",
+						60 * (10 * hz / 9));
 			DL_ASSERT(rc == 0,
-			   ("Failed to stop client thread"));
+					  ("Failed to stop client thread"));
 
 			/* Remove the client and destroy. */
 			DLOGTR0(PRIO_LOW,
-			    "DDTrace thread stoppped successfully\n");
+					"DDTrace thread stoppped successfully\n");
 			LIST_REMOVE(k, client_entries);
 			mtx_destroy(&k->ddtrace_mtx);
 			cv_destroy(&k->ddtrace_cv);
 			free(k, M_DDTRACE);
 		}
 	}
-	
+
 	/* Destroy the hash table of client instances. */
 	hashdestroy(ddtrace_hashtbl, M_DDTRACE, ddtrace_hashmask);
 
 	/* Unregister with DTrace.
 	 * Note that dtrace_lock must be held to manipulate the mutable dtrace
 	 * state (the list of in-kernel clients).
-	 */	
+	 */
 	dtrace_dist_unregister(&did);
 }
 
@@ -268,7 +278,8 @@ ddtrace_buffer_switch(dtrace_state_t *state, struct dlog_handle *handle)
 	 * Persisting the buffer may involving splitting into portions portions
 	 * on a record boundary.
 	 */
-	for (int cpu = 0; cpu < mp_ncpus; cpu++) {
+	for (int cpu = 0; cpu < mp_ncpus; cpu++)
+	{
 
 		/* NOTE:
 		 * Unlike in the BUFSNAP ioctl it is unnecessary to acquire
@@ -277,30 +288,31 @@ ddtrace_buffer_switch(dtrace_state_t *state, struct dlog_handle *handle)
 
 		buf = &state->dts_buffer[cpu];
 		DL_ASSERT(
-		    (buf->dtb_flags & (DTRACEBUF_RING | DTRACEBUF_FILL)) == 0,
-		    ("DTrace ring/fill buffer policy is not supported"));
+			(buf->dtb_flags & (DTRACEBUF_RING | DTRACEBUF_FILL)) == 0,
+			("DTrace ring/fill buffer policy is not supported"));
 
 		if (buf->dtb_tomax == NULL)
 			break;
 
 		cached = buf->dtb_tomax;
 		DL_ASSERT(!(buf->dtb_flags & DTRACEBUF_NOSWITCH),
-		    ("DTrace buffer no switch flag set."));
+				  ("DTrace buffer no switch flag set."));
 
 		/* Perform xcall to swap the CPU's DTrace buffers. */
-		dtrace_xcall(cpu, (dtrace_xcall_t) dtrace_buffer_switch, buf);
+		dtrace_xcall(cpu, (dtrace_xcall_t)dtrace_buffer_switch, buf);
 
 		/* Check that xcall of dtrace_buffer_switch succeeded. */
-		if (buf->dtb_tomax == cached) {
+		if (buf->dtb_tomax == cached)
+		{
 
 			DL_ASSERT(buf->dtb_xamot != cached,
-			   ("DTrace buffers pointers are inconsistent"));
+					  ("DTrace buffers pointers are inconsistent"));
 			continue;
 		}
 
 		DL_ASSERT(cached == buf->dtb_xamot,
-			("DTrace buffers pointers are inconsistent"));
-		
+				  ("DTrace buffers pointers are inconsistent"));
+
 		state->dts_errors += buf->dtb_xamot_errors;
 
 		desc.dtbd_data = buf->dtb_xamot;
@@ -313,8 +325,12 @@ ddtrace_buffer_switch(dtrace_state_t *state, struct dlog_handle *handle)
 		/* If the buffer contains records persist them to the
 		 * distributed log.
 		 */
+
 		if (desc.dtbd_size != 0)
+		{
+			DLOGTR0(PRIO_LOW, "About to persist trace data");
 			ddtrace_persist_trace(state, handle, &desc);
+		}
 	}
 }
 
@@ -330,22 +346,25 @@ ddtrace_thread(void *arg)
 	 * buffers.
 	 */
 	if (ddtrace_persist_metadata(k->ddtrace_state,
-	    k->ddtrace_dlog_handle)) {
+								 k->ddtrace_dlog_handle))
+	{
 
 		DLOGTR0(PRIO_HIGH, "Failed persisting metadata.\n");
 		return;
 	}
 
 	/* Process the trace buffers. */
-	for (;;) {
+	for (;;)
+	{
 
 		mtx_lock(&k->ddtrace_mtx);
 		cv_timedwait_sbt(&k->ddtrace_cv, &k->ddtrace_mtx,
-		    SBT_1MS * ddtrace_poll_ms, SBT_1MS, 0);
-		if (k->ddtrace_exit)  {
+						 SBT_1MS * ddtrace_poll_ms, SBT_1MS, 0);
+		if (k->ddtrace_exit)
+		{
 
 			mtx_unlock(&k->ddtrace_mtx);
-	 		DLOGTR0(PRIO_LOW, "Stopping client thread...\n");
+			DLOGTR0(PRIO_LOW, "Stopping client thread...\n");
 			break;
 		}
 		mtx_unlock(&k->ddtrace_mtx);
@@ -357,37 +376,41 @@ ddtrace_thread(void *arg)
 		nanouptime(&curtime);
 		k->ddtrace_state->dts_alive = INT64_MAX;
 		dtrace_membar_producer();
-		k->ddtrace_state->dts_alive = dtrace_gethrtime();
+		// TODO(MARA): solve this hack
+		k->ddtrace_state->dts_alive = (hrtime_t)dtrace_gethrtime();
 
-		/* Switch the buffer and write the contents to DLog. */ 
+		/* Switch the buffer and write the contents to DLog. */
 		ddtrace_buffer_switch(k->ddtrace_state,
-		    k->ddtrace_dlog_handle);
+							  k->ddtrace_dlog_handle);
 	}
 
 	/* Switch the buffer and write the contetnts to DLog before exiting.
 	 * This ensure that the userspace DTrace process recieves an
 	 * empty buffer on termination.
-	 */ 
+	 */
 	ddtrace_buffer_switch(k->ddtrace_state,
-	     k->ddtrace_dlog_handle);
+						  k->ddtrace_dlog_handle);
 
 	DLOGTR0(PRIO_NORMAL, "DDTrace thread exited successfully.\n");
 	kthread_exit();
 }
 
-static int 
+static int
 ddtrace_persist_metadata(dtrace_state_t *state, struct dlog_handle *hdl)
 {
+	struct vtdtr_traceq *tq;
+	struct vtdtr_trace_entry *trc_entry;
+	struct virtio_dtrace_metadata *mtd;
 	dtrace_action_t *act;
 	dtrace_ecb_t *ecb;
-	dtrace_eprobedesc_t epdesc;
+	dtrace_eprobedesc_t *epdesc;
 	dtrace_probe_t *probe;
-	dtrace_probedesc_t pdesc;
+	dtrace_probedesc_t *pdesc;
 	char *fmt_str;
 	size_t size;
 	uintptr_t dest;
 	void *buf;
-	int fmt_len, nrecs;
+	int fmt_len, nrecs, npdesc = 0;
 
 	DL_ASSERT(state != NULL, ("DTrace state cannot be NULL."));
 	DL_ASSERT(hdl != NULL, ("DLog handle cannot be NULL."));
@@ -397,16 +420,37 @@ ddtrace_persist_metadata(dtrace_state_t *state, struct dlog_handle *hdl)
 	 */
 	DLOGTR0(PRIO_LOW, "Persisting dtrace format string metadata\n");
 
+	tq = virtio_dtrace_device_register();
+	DL_ASSERT(tq != NULL, ("vtdtr_traceq was not initialised."));
 	mutex_enter(&dtrace_lock);
+
+	trc_entry = malloc(sizeof(struct vtdtr_trace_entry), M_DEVBUF, M_NOWAIT | M_ZERO);
+	DL_ASSERT(trc_entry != NULL, "Failed allocating memory for trace entry");
+	trc_entry->type = DDTRACE_METADATA;
+
+	mtd = &trc_entry->uentry.metadata;
+	mtd->type = NFORMAT;
+	mtd->umtd.dts_nformats = state->dts_nformats;
+	DLOGTR1("Make sure they're there: %d %d", mtd->umtd.dts_nformats, state->dts_nformats);
+	mtx_lock(&tq->mtx);
+	vtdtr_tq_enqueue(tq, trc_entry);
+	mtx_unlock(&tq->mtx);
+
+
+#if 0
 	if (dlog_produce(hdl, DDTRACE_NFORMAT_KEY,
-	    (unsigned char *)&state->dts_nformats, sizeof(int)) != 0) {
+					 (unsigned char *)&state->dts_nformats, sizeof(int)) != 0)
+	{
 
 		DLOGTR0(PRIO_HIGH,
-		    "Error producing format metadata to DLog\n");
+				"Error producing format metadata to DLog\n");
 		return -1;
 	}
+#endif
+	
 
-	for (int fmt = 1; fmt <= state->dts_nformats; fmt++) {
+	for (int fmt = 1; fmt <= state->dts_nformats; fmt++)
+	{
 		/*
 		 * Format strings are allocated contiguously and they are
 		 * never freed; if a format index is less than the number
@@ -414,19 +458,36 @@ ddtrace_persist_metadata(dtrace_state_t *state, struct dlog_handle *hdl)
 		 * and that the format for the specified index is non-NULL.
 		 */
 		DL_ASSERT(state->dts_formats != NULL,
-		    ("Format array cannot be NULL"));
+				  ("Format array cannot be NULL"));
 		fmt_str = state->dts_formats[fmt - 1];
-		DL_ASSERT(fmt_str != NULL, ("Format string cannor be NULL"));
+		DL_ASSERT(fmt_str != NULL, ("Format string cannot be NULL"));
 		fmt_len = strlen(fmt_str) + 1;
+		trc_entry = malloc(sizeof(struct vtdtr_trace_entry), M_DEVBUF, M_NOWAIT | M_ZERO);
+		DL_ASSERT(trc_entry != NULL, "Failed allocating memory for the trace entry");
+		trc_entry->type = DDTRACE_METADATA;
 
-		/* Persit the format string to dlog. */	
-		if (dlog_produce(hdl, DDTRACE_FORMAT_KEY, fmt_str, fmt_len) != 0) {
+		
+		mtd = &trc_entry->uentry.metadata;
+		mtd->type = FORMAT_STRING;
+		mtd->umtd.dts_fmtstr = fmt_str;
+
+		mtx_lock(&tq->mtx);
+		vtdtr_tq_enqueue(tq, trc_entry);
+		mtx_unlock(&tq->mtx);
+
+#if 0
+		/* Persit the format string to dlog. */
+		if (dlog_produce(hdl, DDTRACE_FORMAT_KEY, fmt_str, fmt_len) != 0)
+		{
 
 			DLOGTR0(PRIO_HIGH,
-			    "Error producing format metadata to DLog\n");
+					"Error producing format metadata to DLog\n");
 			return -1;
 		}
-	} 
+
+#endif
+	}
+
 	mutex_exit(&dtrace_lock);
 
 	/* Write the eprobedesc to the log: this duplicates the
@@ -439,26 +500,87 @@ ddtrace_persist_metadata(dtrace_state_t *state, struct dlog_handle *hdl)
 	 * I truth I only what to send the epids, can these be rescaled
 	 * to monotonical increase for 1?
 	 */
+
+#if 0
 	if (dlog_produce(hdl, DDTRACE_NPROBE_KEY,
-	    (unsigned char *) &dtrace_nprobes, sizeof(int)) != 0) {
+					 (unsigned char *)&dtrace_nprobes, sizeof(int)) != 0)
+	{
 
 		DLOGTR0(PRIO_HIGH,
-		    "Error producing format metadata to DLog\n");
+				"Error producing format metadata to DLog\n");
 		return -1;
 	}
-
+#endif
+	trc_entry = malloc(sizeof(struct vtdtr_trace_entry), M_DEVBUF, M_NOWAIT | M_ZERO);
+	DL_ASSERT(trc_entry != NULL, "Failed allocating memory for trace entry");
+	trc_entry->type = DDTRACE_METADATA;
+
+	mtd = &trc_entry->uentry.metadata;
+	mtd->type = NPROBES;
+	mtd->umtd.dtrace_nprobes = dtrace_nprobes;
+	
+	mtx_lock(&tq->mtx);
+	vtdtr_tq_enqueue(tq, trc_entry);
+	mtx_unlock(&tq->mtx);
+	
+		
 	mutex_enter(&dtrace_lock);
 	DL_ASSERT(state->dts_necbs > 0 && state->dts_ecbs != NULL,
-	    ("dtrace ecb state is invalid"));
-	for (dtrace_epid_t epid = 1; epid <= state->dts_epid; epid++) {
+			  ("dtrace ecb state is invalid"));
+
+	npdesc = 0;
+	for (dtrace_epid_t epid = 1; epid <= state->dts_epid; epid++)
+	{
+
+		DLOGTR1(PRIO_LOW, "Persisting dtrace eprobe (%d) metadata\n",
+				epid);
+
+		DL_ASSERT(state->dts_necbs > 0 && state != NULL,
+				  ("DTace ECB state is invalid"));
+		DL_ASSERT((ecb = state->dts_ecbs[epid - 1]) == NULL ||
+					  ecb->dte_epid == epid,
+				  ("DTrace ECBS state is inconsistent"));
+
+		ecb = state->dts_ecbs[epid - 1];
+		if (ecb == NULL || ecb->dte_probe == NULL)
+			continue;
+
+		if ((probe = dtrace_probes[ecb->dte_probe->dtpr_id - 1]) != NULL)
+		{
+			npdesc ++;
+		}
+	}
+
+	printf("Calculated number of enabled probes: %d", npdesc);
+
+	trc_entry = malloc(sizeof(struct vtdtr_trace_entry), M_DEVBUF, M_NOWAIT | M_ZERO);
+	DL_ASSERT(trc_entry != NULL, "Failed allocating memory for trace entry");
+	trc_entry->type = DDTRACE_METADATA;
+	
+	mtd = &trc_entry->uentry.metadata;
+	mtd->type = NPDESC;
+	mtd->umtd.dt_npdescs = npdesc;
+
+
+	printf(" Number of probes description is: %d", mtd->umtd.dt_npdescs);
+	
+
+	mtx_lock(&tq->mtx);
+	vtdtr_tq_enqueue(tq, trc_entry);
+	mtx_unlock(&tq->mtx);
+
+
+	for (dtrace_epid_t epid = 1; epid <= state->dts_epid; epid++)
+	{
 
 		DLOGTR1(PRIO_LOW, "Persisting dtrace eprobe (%d) metadata\n",
-		    epid);
+				epid);
 
 		DL_ASSERT(state->dts_necbs > 0 && state != NULL,
-		    ("DTace ECB state is invalid"));
+				  ("DTace ECB state is invalid"));
 		DL_ASSERT((ecb = state->dts_ecbs[epid - 1]) == NULL ||
-		    ecb->dte_epid == epid, ("DTrace ECBS state is inconsistent"));
+					  ecb->dte_epid == epid,
+				  ("DTrace ECBS state is inconsistent"));
 
 		ecb = state->dts_ecbs[epid - 1];
 		if (ecb == NULL || ecb->dte_probe == NULL)
@@ -468,50 +590,69 @@ ddtrace_persist_metadata(dtrace_state_t *state, struct dlog_handle *hdl)
 		 * for the current zone; see the DTRACEIOC_PROBES/_PROBEMATCH ioctl
 		 * implementation.
 		 */
-		if ((probe = dtrace_probes[ecb->dte_probe->dtpr_id - 1]) != NULL) {
-
-			bzero(&pdesc, sizeof(dtrace_probedesc_t));
-			pdesc.dtpd_provider[DTRACE_PROVNAMELEN - 1] = '\0';
-			pdesc.dtpd_mod[DTRACE_MODNAMELEN - 1] = '\0';
-			pdesc.dtpd_func[DTRACE_FUNCNAMELEN - 1] = '\0';
-			pdesc.dtpd_name[DTRACE_NAMELEN - 1] = '\0';
+		if ((probe = dtrace_probes[ecb->dte_probe->dtpr_id - 1]) != NULL)
+		{   
+			pdesc = malloc(sizeof(dtrace_probedesc_t), M_DEVBUF, M_NOWAIT | M_ZERO);
+			memset(pdesc, 0, sizeof(dtrace_probedesc_t));
+			pdesc->dtpd_provider[DTRACE_PROVNAMELEN - 1] = '\0';
+			pdesc->dtpd_mod[DTRACE_MODNAMELEN - 1] = '\0';
+			pdesc->dtpd_func[DTRACE_FUNCNAMELEN - 1] = '\0';
+			pdesc->dtpd_name[DTRACE_NAMELEN - 1] = '\0';
 
 			/* Construct the probe description and
 			 * persist the metadata to dlog.
 			 */
-			pdesc.dtpd_id = epid;// TODO: temporary fix
-			(void) strncpy(pdesc.dtpd_provider,
-			    probe->dtpr_provider->dtpv_name,
-			    DTRACE_PROVNAMELEN - 1);
-			(void) strncpy(pdesc.dtpd_mod, probe->dtpr_mod,
-			    DTRACE_MODNAMELEN - 1);
-			(void) strncpy(pdesc.dtpd_func, probe->dtpr_func,
-			    DTRACE_FUNCNAMELEN - 1);
-			(void) strncpy(pdesc.dtpd_name, probe->dtpr_name,
-			    DTRACE_NAMELEN - 1);
+			pdesc->dtpd_id = epid; // TODO: temporary fix
+			(void)strncpy(pdesc->dtpd_provider,
+						  probe->dtpr_provider->dtpv_name,
+						  DTRACE_PROVNAMELEN - 1);
+			(void)strncpy(pdesc->dtpd_mod, probe->dtpr_mod,
+						  DTRACE_MODNAMELEN - 1);
+			(void)strncpy(pdesc->dtpd_func, probe->dtpr_func,
+						  DTRACE_FUNCNAMELEN - 1);
+			(void)strncpy(pdesc->dtpd_name, probe->dtpr_name,
+						  DTRACE_NAMELEN - 1);
+
+			trc_entry = malloc(sizeof(struct vtdtr_trace_entry), M_DEVBUF, M_NOWAIT | M_ZERO);
+			DL_ASSERT(trc_entry != NULL, "Failed allocating memory for trace entry");
+			trc_entry->type = DDTRACE_METADATA;
+		
+			mtd = &trc_entry->uentry.metadata;
+			mtd->type = PROBE_DESCRIPTION;
+			mtd->umtd.dt_pdesc.buf = pdesc;
+			mtd->umtd.dt_pdesc.buf_size = sizeof(dtrace_probedesc_t);
+
+			mtx_lock(&tq->mtx);
+			vtdtr_tq_enqueue(tq, trc_entry);
+			mtx_unlock(&tq->mtx);
 
+#if 0
 			if (dlog_produce(hdl, DDTRACE_PROBE_KEY,
-			    (unsigned char *) &pdesc,
-		    	    sizeof(dtrace_probedesc_t)) != 0) {
+							 (unsigned char *)&pdesc,
+							 sizeof(dtrace_probedesc_t)) != 0)
+			{
 
 				DLOGTR0(PRIO_HIGH,
-			    	    "Error producing format probe metadata "
-				    "to DLog\n");
+						"Error producing format probe metadata "
+						"to DLog\n");
 				return -1;
 			}
-	
-			epdesc.dtepd_epid = epid;
-			epdesc.dtepd_probeid = ecb->dte_probe->dtpr_id;
-			epdesc.dtepd_uarg = ecb->dte_uarg;
-			epdesc.dtepd_size = ecb->dte_size;
-			epdesc.dtepd_nrecs = 0;
-			for (act = ecb->dte_action; act != NULL; act = act->dta_next) {
+#endif
+
+			epdesc = malloc(sizeof(dtrace_eprobedesc_t), M_DEVBUF, M_NOWAIT | M_ZERO);
+			epdesc->dtepd_epid = epid;
+			epdesc->dtepd_probeid = ecb->dte_probe->dtpr_id;
+			epdesc->dtepd_uarg = ecb->dte_uarg;
+			epdesc->dtepd_size = ecb->dte_size;
+			epdesc->dtepd_nrecs = 0;
+			for (act = ecb->dte_action; act != NULL; act = act->dta_next)
+			{
 				if (DTRACEACT_ISAGG(act->dta_kind) || act->dta_intuple)
 					continue;
 
-				epdesc.dtepd_nrecs++;
+				epdesc->dtepd_nrecs++;
 			}
-			nrecs = epdesc.dtepd_nrecs;
+			nrecs = epdesc->dtepd_nrecs;
 
 			/*
 			 * now that we have the size, we need to allocate a temporary
@@ -520,36 +661,55 @@ ddtrace_persist_metadata(dtrace_state_t *state, struct dlog_handle *hdl)
 			 * across the copyout(), below.
 			 */
 			size = sizeof(dtrace_eprobedesc_t) +
-			    (epdesc.dtepd_nrecs * sizeof(dtrace_recdesc_t));
+				   (epdesc->dtepd_nrecs * sizeof(dtrace_recdesc_t));
 
-			buf = malloc(size, M_DDTRACE, M_NOWAIT);
+			buf = malloc(size, M_DEVBUF, M_NOWAIT | M_ZERO);
 			dest = (uintptr_t)buf;
 
-			bcopy(&epdesc, (void *)dest, sizeof(epdesc));
+			// bcopy(&epdesc, (void *)dest, sizeof(epdesc));
+			memcpy((void *)dest, epdesc, sizeof(dtrace_eprobedesc_t));
 			dest += offsetof(dtrace_eprobedesc_t, dtepd_rec[0]);
 
-			for (act = ecb->dte_action; act != NULL; act = act->dta_next) {
+			for (act = ecb->dte_action; act != NULL; act = act->dta_next)
+			{
 				if (DTRACEACT_ISAGG(act->dta_kind) || act->dta_intuple)
 					continue;
 
 				if (nrecs-- == 0)
 					break;
 
-				bcopy(&act->dta_rec, (void *)dest,
-				    sizeof(dtrace_recdesc_t));
+				// bcopy(&act->dta_rec, (void *)dest,
+				// 	  sizeof(dtrace_recdesc_t));
+				memcpy((void *)dest, &act->dta_rec, sizeof(dtrace_recdesc_t));
 				dest += sizeof(dtrace_recdesc_t);
 			}
-
+#if 0
 			/* Persist the EPROBE metadata to dlog. */
-			if (dlog_produce(hdl, DDTRACE_EPROBE_KEY, buf, size) != 0) {
+			if (dlog_produce(hdl, DDTRACE_EPROBE_KEY, buf, size) != 0)
+			{
 
 				DLOGTR0(PRIO_HIGH,
-				    "Error producing format eprobe metadata to DLog\n");
+						"Error producing format eprobe metadata to DLog\n");
 				free(buf, M_DDTRACE);
 				return -1;
 			}
+#endif
 
-			free(buf, M_DDTRACE);
+			trc_entry = malloc(sizeof(struct vtdtr_trace_entry), M_DEVBUF, M_NOWAIT | M_ZERO);
+			DL_ASSERT(trc_entry != NULL, "Failed allocating memory for trace entry");
+			trc_entry->type = DDTRACE_METADATA;
+		
+			mtd = &trc_entry->uentry.metadata;
+			mtd->type = EPROBE_DESCRIPTION;
+			mtd->umtd.dt_epdesc.buf_size = size;
+			mtd->umtd.dt_epdesc.buf = buf;
+
+			mtx_lock(&tq->mtx);
+			vtdtr_tq_enqueue(tq, trc_entry);
+			mtx_unlock(&tq->mtx);
+
+			free(epdesc, M_DEVBUF);
+			// free(buf, M_DEVBUF);
 		}
 	}
 	mutex_exit(&dtrace_lock);
@@ -559,37 +719,72 @@ ddtrace_persist_metadata(dtrace_state_t *state, struct dlog_handle *hdl)
 
 static void
 ddtrace_persist_trace(dtrace_state_t *state, struct dlog_handle *hdl,
-    dtrace_bufdesc_t *desc)
+					  dtrace_bufdesc_t *desc)
 {
 	dtrace_epid_t epid;
+	struct vtdtr_traceq *tq;
+	struct vtdtr_trace_entry *trc_entry;
+	struct virtio_dtrace_trace *trc;
 	size_t msg_start = 0, msg_size = 0, size = 0;
-	
+
+	tq = virtio_dtrace_device_register();
+
 	DL_ASSERT(state != NULL, ("DTrace state cannot be NULL."));
 	DL_ASSERT(hdl != NULL, ("DLog handle cannot be NULL."));
 	DL_ASSERT(desc != NULL,
-	    ("DTrace buffer description cannot be NULL."));
+			  ("DTrace buffer description cannot be NULL."));
 	DL_ASSERT(desc->dtbd_data != NULL,
-	    ("ddtrace_persist_trace called with NULL buffer."));
+			  ("ddtrace_persist_trace called with NULL buffer."));
 	DL_ASSERT(desc->dtbd_size != 0,
-	    ("ddtrace_persist_trace called with empty buffer."));
+			  ("ddtrace_persist_trace called with empty buffer."));
 
-	while (size < desc->dtbd_size) {
+	DLOGTR0(PRIO_LOW, "Persisting trace data. \n");
 
-		epid = *(dtrace_epid_t *) ((uintptr_t) desc->dtbd_data + size);
-		if (epid == DTRACE_EPIDNONE) {
+	DL_ASSERT(tq != NULL, ("vtdtr_traceq was not initialised."));
+
+	trc_entry = malloc(sizeof(struct vtdtr_trace_entry), M_DEVBUF, M_NOWAIT | M_ZERO);
+	DL_ASSERT(trc_entry != NULL, "Failed allocating memory for trace entry.");
+	trc_entry->type = DDTRACE_TRACE;
+
+	trc = &trc_entry->uentry.trace;
+	trc->dtbd_size = desc->dtbd_size;
+	trc->dtbd_cpu = desc->dtbd_cpu;
+	trc->dtbd_errors = desc->dtbd_errors;
+	trc->dtbd_drops = desc->dtbd_drops;
+	trc->dtbd_data = desc->dtbd_data;
+	trc->dtbd_oldest = desc->dtbd_oldest;
+	trc->dtbd_timestamp = desc->dtbd_timestamp;
+
+	DLOGTR2(PRIO_LOW, "Trace ddata size is: %zu. Copied trace data size: %zu. \n", desc->dtbd_size, trc->dtbd_size);
+	
+	// printf("%s", trc->dtbd_data);
+
+	mtx_lock(&tq->mtx);
+	vtdtr_tq_enqueue(tq, trc_entry);
+
+	DL_ASSERT(tq->n_entries != 0, "Failed enqueueing, number of entries cannot be 0.");
+	mtx_unlock(&tq->mtx);
+
+#if 0
+	while (size < desc->dtbd_size)
+	{
+
+		epid = *(dtrace_epid_t *)((uintptr_t)desc->dtbd_data + size);
+		if (epid == DTRACE_EPIDNONE)
+		{
 
 			size += sizeof(epid);
 			continue;
 		}
 
-		if (dtrace_epid2size(state, epid) == 0) {
+		if (dtrace_epid2size(state, epid) == 0)
+		{
 
 			DLOGTR1(PRIO_HIGH,
-			    "Error payload size is 0 for epid = %u\n", epid);
+					"Error payload size is 0 for epid = %u\n", epid);
 			break;
 		}
 
-
 		/* Check whether the record would take the msg_size
 		 * over the MTU configured for the distributed log.
 		 */
@@ -601,7 +796,8 @@ ddtrace_persist_trace(dtrace_state_t *state, struct dlog_handle *hdl,
 		 * Therefore, I am using a configurable parameter.
 		 */
 		if (msg_size + dtrace_epid2size(state, epid) >
-		    ddtrace_record_bound) {
+			ddtrace_record_bound)
+		{
 
 			/* The umsg_size is zero this occurs when the
 			 * DTrace record size is greater than the log
@@ -609,17 +805,20 @@ ddtrace_persist_trace(dtrace_state_t *state, struct dlog_handle *hdl,
 			 * ddtrace_open().
 			 */
 			DL_ASSERT(msg_size != 0,
-			    ("Error DTrace record size %zu is greater "
-			     "than log MTU %d\n",
-			     dtrace_epid2size(state, epid), DL_MTU));
+					  ("Error DTrace record size %zu is greater "
+					   "than log MTU %d\n",
+					   dtrace_epid2size(state, epid), DL_MTU));
 
-			if (dlog_produce(hdl, 
-			    DDTRACE_KEY,
-			    &desc->dtbd_data[msg_start], msg_size) != 0) {
+#if 0
+			if (dlog_produce(hdl,
+							 DDTRACE_KEY,
+							 &desc->dtbd_data[msg_start], msg_size) != 0)
+			{
 
 				DLOGTR0(PRIO_HIGH,
-				    "Error producing message to DLog\n");
+						"Error producing message to DLog\n");
 			}
+#endif
 
 			/* Reset the msg_size and set the msg_start
 			 * to the location in the buffer at which the
@@ -627,7 +826,9 @@ ddtrace_persist_trace(dtrace_state_t *state, struct dlog_handle *hdl,
 			 */
 			msg_start += msg_size;
 			msg_size = 0;
-		} else {
+		}
+		else
+		{
 
 			/* Increment the message and total size by the
 			 * payload of the current record.
@@ -638,15 +839,19 @@ ddtrace_persist_trace(dtrace_state_t *state, struct dlog_handle *hdl,
 			/* Check whether the record is the last in the
 			 * buffer.
 			 */
-			if (msg_size == desc->dtbd_size) {
-				if (dlog_produce(hdl, 
-			    	    DDTRACE_KEY,
-				    &desc->dtbd_data[msg_start],
-				    msg_size) != 0) {
+			if (msg_size == desc->dtbd_size)
+			{
+#if 0
+				if (dlog_produce(hdl,
+								 DDTRACE_KEY,
+								 &desc->dtbd_data[msg_start],
+								 msg_size) != 0)
+				{
 
 					DLOGTR0(PRIO_HIGH,
-					    "Error producing message to DLog\n");
+							"Error producing message to DLog\n");
 				}
+#endif
 
 				/* Reset the msg_size and set the msg_start
 				 * to the location in the buffer at which
@@ -657,6 +862,7 @@ ddtrace_persist_trace(dtrace_state_t *state, struct dlog_handle *hdl,
 			}
 		}
 	}
+#endif
 }
 
 static void
@@ -671,82 +877,92 @@ ddtrace_open(void *arg, struct dtrace_state *state)
 	dtrace_dist_t *dist = (dtrace_dist_t *)arg;
 	uint32_t hash;
 	int rc;
-	
+
 	DL_ASSERT(state != NULL, ("DTrace state cannot be NULL."));
 	DL_ASSERT(dist != NULL, ("DTrace client instance cannot be NULL."));
 
 	DLOGTR0(PRIO_LOW, "ddtrace_open\n");
 
-       	/* Check the the payload of the enabled probes is less than the
+	/* Check the the payload of the enabled probes is less than the
 	 * configured MTU of the distributed log.
 	 */
-	for (epid  = 1; epid < state->dts_epid; epid++) {
-		if (dtrace_epid2size(state, epid) > DL_MTU) {
+	for (epid = 1; epid < state->dts_epid; epid++)
+	{
+		if (dtrace_epid2size(state, epid) > DL_MTU)
+		{
 			DLOGTR3(PRIO_HIGH,
-			    "DDTrace (%s) rendezvous with DLog state "
-			    "DTrace record size %zu is greater "
-			    "than log MTU %d\n",
-			    dist->dtd_name,
-			    dtrace_epid2size(state, epid), DL_MTU);
+					"DDTrace (%s) rendezvous with DLog state "
+					"DTrace record size %zu is greater "
+					"than log MTU %d\n",
+					dist->dtd_name,
+					dtrace_epid2size(state, epid), DL_MTU);
 			return;
 		}
 	}
 
 	/* Confirm that the DTrace buffer policy is "switch". */
 	if (state->dts_options[DTRACEOPT_BUFPOLICY] !=
-	    DTRACEOPT_BUFPOLICY_SWITCH) {
-	
+		DTRACEOPT_BUFPOLICY_SWITCH)
+	{
+
 		DLOGTR1(PRIO_HIGH,
-		    "DDTrace (%s) rendezvous with DLog state failed "
-		    "DTrace bufpolicy must be switch\n",
-		    dist->dtd_name);
+				"DDTrace (%s) rendezvous with DLog state failed "
+				"DTrace bufpolicy must be switch\n",
+				dist->dtd_name);
 		return;
 	}
 
 	/* Convert the DLog file descriptor into a struct dlog_handle */
-	if (state->dts_options[DTRACEOPT_DDTRACEARG] == DTRACEOPT_UNSET) {
+	if (state->dts_options[DTRACEOPT_DDTRACEARG] == DTRACEOPT_UNSET)
+	{
 
 		DLOGTR1(PRIO_HIGH,
-		    "DDTrace (%s) rendezvous with DLog state failed "
-		    "DTrace ddtracearg option is unset\n", dist->dtd_name);
+				"DDTrace (%s) rendezvous with DLog state failed "
+				"DTrace ddtracearg option is unset\n",
+				dist->dtd_name);
 		return;
 	}
-	
+
 	FILEDESC_SLOCK(fdp);
 	fp = fget_locked(fdp, state->dts_options[DTRACEOPT_DDTRACEARG]);
 	FILEDESC_SUNLOCK(fdp);
-	if (fp == NULL) {
+	if (fp == NULL)
+	{
 
 		DLOGTR1(PRIO_HIGH,
-		    "DDTrace (%s) rendezvous with DLog state failed "
-		    "DTrace ddtracearg is not a valid file decriptor\n",
-		    dist->dtd_name);
+				"DDTrace (%s) rendezvous with DLog state failed "
+				"DTrace ddtracearg is not a valid file decriptor\n",
+				dist->dtd_name);
 		return;
 	}
 
 	p = fp->f_cdevpriv;
-	if (p == NULL) {
+	if (p == NULL)
+	{
 
 		DLOGTR1(PRIO_HIGH,
-		    "DDTrace (%s) rendezvous with DLog state failed "
-		    "DTrace ddtracearg file descriptor is not associated with "
-		    "dlog handle\n", dist->dtd_name);
+				"DDTrace (%s) rendezvous with DLog state failed "
+				"DTrace ddtracearg file descriptor is not associated with "
+				"dlog handle\n",
+				dist->dtd_name);
 		return;
 	}
 
 	handle = (struct dlog_handle *)p->cdpd_data;
-	if (handle == NULL) {
+	if (handle == NULL)
+	{
 
 		DLOGTR1(PRIO_HIGH,
-		    "DDTrace (%s) rendezvous with DLog state failed "
-		    "DTrace ddtracearg file secriptor is not associated with "
-		    "dlog handle\n", dist->dtd_name);
+				"DDTrace (%s) rendezvous with DLog state failed "
+				"DTrace ddtracearg file secriptor is not associated with "
+				"dlog handle\n",
+				dist->dtd_name);
 		return;
 	}
 
 	/* ALlocate a new DDTrace instance. */
-	k = (struct client *) malloc(sizeof(struct client), M_DDTRACE,
-	    M_NOWAIT);
+	k = (struct client *)malloc(sizeof(struct client), M_DDTRACE,
+								M_NOWAIT);
 	DL_ASSERT(k != NULL, ("Failed to allocate new client instance."));
 
 	bzero(k, sizeof(struct client));
@@ -756,9 +972,9 @@ ddtrace_open(void *arg, struct dtrace_state *state)
 	k->ddtrace_exit = 0;
 	k->ddtrace_dlog_handle = handle;
 	rc = kproc_kthread_add(ddtrace_thread, k, &k->ddtrace_pid, NULL, 0, 0,
-	    NULL, NULL);
+						   NULL, NULL);
 	DL_ASSERT(rc == 0, ("DDTrace open kproc_kthread_add failed %d\n", rc));
-	
+
 	ddtrace_assert_integrity(__func__, k);
 
 	/* Added the new client instance into the hashmap, index by the
@@ -766,7 +982,7 @@ ddtrace_open(void *arg, struct dtrace_state *state)
 	 * changes over the execution).
 	 */
 	hash = murmur3_32_hash(&state, sizeof(struct dtrace_state *), 0) &
-	    ddtrace_hashmask;
+		   ddtrace_hashmask;
 	LIST_INSERT_HEAD(&ddtrace_hashtbl[hash], k, client_entries);
 }
 
@@ -775,20 +991,22 @@ ddtrace_close(void *arg, struct dtrace_state *state)
 {
 	struct client *k, *k_tmp;
 	uint32_t hash;
-	
+
 	DL_ASSERT(state != NULL, ("DTrace state cannot be NULL"));
 	DL_ASSERT(MUTEX_HELD(&dtrace_lock),
-	    ("dtrace_lock should be held in dtrace_state_stop()"));
+			  ("dtrace_lock should be held in dtrace_state_stop()"));
 
 	/* Lookup the DDTrace instance based on the DTrace state passed into
 	 * ddtrace_close.
 	 */
 	hash = murmur3_32_hash(&state, sizeof(struct dtrace_state *), 0) &
-	    ddtrace_hashmask;
-	LIST_FOREACH_SAFE(k, &ddtrace_hashtbl[hash], client_entries, k_tmp) {
-	
+		   ddtrace_hashmask;
+	LIST_FOREACH_SAFE(k, &ddtrace_hashtbl[hash], client_entries, k_tmp)
+	{
+
 		ddtrace_assert_integrity(__func__, k);
-		if (state == k->ddtrace_state) {
+		if (state == k->ddtrace_state)
+		{
 
 			/* Stop the client thread and wait until it has
 			 * persisted all oustanding DTrace records to DLog.
@@ -798,14 +1016,14 @@ ddtrace_close(void *arg, struct dtrace_state *state)
 			mtx_unlock(&k->ddtrace_mtx);
 			cv_broadcast(&k->ddtrace_cv);
 			tsleep(k->ddtrace_pid, 0,
-			    "Waiting for client thread to stop",
-			    60 * (10 * hz / 9));
+				   "Waiting for client thread to stop",
+				   60 * (10 * hz / 9));
 
 			/* Remove the client instance from the hash map
 			 * and destroy it.
 			 */
 			DLOGTR0(PRIO_NORMAL,
-			    "DDTrace thread stoppped successfully\n");
+					"DDTrace thread stoppped successfully\n");
 			LIST_REMOVE(k, client_entries);
 			mtx_destroy(&k->ddtrace_mtx);
 			cv_destroy(&k->ddtrace_cv);
diff --git a/sys/modules/dtrace/Makefile b/sys/modules/dtrace/Makefile
index 2cc29b43786..73a9b5977a6 100644
--- a/sys/modules/dtrace/Makefile
+++ b/sys/modules/dtrace/Makefile
@@ -14,6 +14,7 @@ SUBDIR=		dtaudit		\
 		prototype	\
 		sdt		\
 		systrace	\
+		vtdtr     \
 
 .if ${MK_VTDTR} != "no"
 SUBDIR+=	vtdtr
diff --git a/sys/modules/dtrace/vtdtr/Makefile b/sys/modules/dtrace/vtdtr/Makefile
index beb26787244..453bf5b1c89 100644
--- a/sys/modules/dtrace/vtdtr/Makefile
+++ b/sys/modules/dtrace/vtdtr/Makefile
@@ -10,7 +10,8 @@ KMOD=		vtdtr
 SRCS=		vtdtr.c	\
 		vnode_if.h
 
-CFLAGS+=	-I${SYSDIR}/cddl/compat/opensolaris \
+CFLAGS+= -I${SYSDIR}/cddl/dev/vtdtr \
+		-I${SYSDIR}/cddl/compat/opensolaris \
 		-I${SYSDIR}/cddl/contrib/opensolaris/uts/common \
 		-I${SYSDIR}/cddl/contrib/opensolaris/uts/common/dtrace \
 		-I${SYSDIR}
diff --git a/sys/modules/virtio/dtrace/Makefile b/sys/modules/virtio/dtrace/Makefile
index f745a5cad17..a05d1637b30 100644
--- a/sys/modules/virtio/dtrace/Makefile
+++ b/sys/modules/virtio/dtrace/Makefile
@@ -27,6 +27,8 @@
 
 SYSDIR?=	${SRCTOP}/sys
 
+CFLAGS+= -I${SRCTOP}/sys/cddl/dev/vtdtr
+
 .PATH: ${SYSDIR}/dev/virtio/dtrace
 
 KMOD=	virtio_dtrace
@@ -35,12 +37,15 @@ SRCS+=	vnode_if.h
 SRCS+=	virtio_bus_if.h virtio_if.h
 SRCS+=	bus_if.h device_if.h
 
-CFLAGS+=	-I${SYSDIR}/cddl/compat/opensolaris \
+CFLAGS+= -I${SYSDIR}/cddl/compat/opensolaris \
 		-I${SYSDIR}/cddl/contrib/opensolaris/uts/common \
 		-I${SYSDIR} \
 		-nostdinc
 
+
+
 .include <bsd.kmod.mk>
 
 CFLAGS+=	-include ${SYSDIR}/cddl/compat/opensolaris/sys/debug_compat.h
 
+
diff --git a/sys/modules/virtio/dtrace/backend/Makefile b/sys/modules/virtio/dtrace/backend/Makefile
index 3c01b64a40f..b872480fdd9 100644
--- a/sys/modules/virtio/dtrace/backend/Makefile
+++ b/sys/modules/virtio/dtrace/backend/Makefile
@@ -27,8 +27,12 @@
 
 SYSDIR?=	${SRCTOP}/sys
 
+CFLAGS+= -I${SRCTOP}/sys/cddl/dev/vtdtr
+
 .PATH: ${SYSDIR}/dev/virtio/dtrace/backend
 
+
+
 KMOD=	virtio_dtrace
 SRCS=	virtio_dtrace.c
 SRCS+=	vnode_if.h
@@ -40,7 +44,8 @@ CFLAGS+=	-I${SYSDIR}/cddl/compat/opensolaris \
 		-I${SYSDIR} \
 		-nostdinc
 
-.include <bsd.kmod.mk>
 
-CFLAGS+=	-include ${SYSDIR}/cddl/compat/opensolaris/sys/debug_compat.h
 
+.include <bsd.kmod.mk>
+
+CFLAGS+=	-include ${SYSDIR}/cddl/compat/opensolaris/sys/debug_compat.h \
diff --git a/sys/modules/virtio/dtrace/frontend/Makefile b/sys/modules/virtio/dtrace/frontend/Makefile
index c05ae3cd339..a17e448d1e2 100644
--- a/sys/modules/virtio/dtrace/frontend/Makefile
+++ b/sys/modules/virtio/dtrace/frontend/Makefile
@@ -27,6 +27,8 @@
 
 SYSDIR?=	${SRCTOP}/sys
 
+CFLAGS+= -I${SRCTOP}/sys/cddl/dev/vtdtr
+
 .PATH: ${SYSDIR}/dev/virtio/dtrace/frontend
 
 KMOD=	virtio_dtrace
@@ -40,7 +42,9 @@ CFLAGS+=	-I${SYSDIR}/cddl/compat/opensolaris \
 		-I${SYSDIR} \
 		-nostdinc
 
+
+
 .include <bsd.kmod.mk>
 
-CFLAGS+=	-include ${SYSDIR}/cddl/compat/opensolaris/sys/debug_compat.h
+CFLAGS+=	-include ${SYSDIR}/cddl/compat/opensolaris/sys/debug_compat.h \
 
diff --git a/sys/sys/vtdtr.h b/sys/sys/vtdtr.h
index 91cf7460bb2..23714b95e2d 100644
--- a/sys/sys/vtdtr.h
+++ b/sys/sys/vtdtr.h
@@ -2,42 +2,57 @@
 #define _SYS_VTDTR_H_
 
 //#include <sys/dtrace.h>
+#include <sys/types.h>
 
-#define VTDTR_MAXVMS       16
-#define VTDTR_VMNAMEMAX    256
+#define VTDTR_MAXVMS 16
+#define VTDTR_VMNAMEMAX 256
 
-#define VTDTR_EV_INSTALL   0x01
+#define VTDTR_EV_INSTALL 0x01
 #define VTDTR_EV_UNINSTALL 0x02
-#define VTDTR_EV_GO        0x03
-#define VTDTR_EV_STOP      0x04
-#define VTDTR_EV_RECONF    0x05
+#define VTDTR_EV_GO 0x03
+#define VTDTR_EV_STOP 0x04
+#define VTDTR_EV_RECONF 0x05
+#define VTDTR_EV_SCRIPT 0x06
 
 /*
  * We only have one event at the moment -- possibly others in the future.
  */
-struct vtdtr_event {
+struct vtdtr_event
+{
 	size_t type;
 
 	union {
-		struct {
+		struct
+		{
 			int probeid;
 		} p_toggle;
 
-		struct {
+		struct
+		{
+			int last;
+			char script[512];
+		} d_script;
+
+		struct
+		{
 			char vms[VTDTR_MAXVMS][VTDTR_VMNAMEMAX];
 			size_t count;
 		} d_config;
+
 	} args;
 };
 
-
-
-struct vtdtr_conf {
+struct vtdtr_conf
+{
 	sbintime_t timeout;
 	size_t max_size;
 	size_t event_flags;
 };
 
-#define VTDTRIOC_CONF _IOW('v',1,struct vtdtr_conf)
+// makes sure ioctl is unique
+
+#define VTDTRIOC_CONF _IOW('v', 1, struct vtdtr_conf)
+
+
 
-#endif
+#endif
\ No newline at end of file
diff --git a/usr.sbin/bhyve/Makefile b/usr.sbin/bhyve/Makefile
index 357b6966eb9..2c77f272fc8 100644
--- a/usr.sbin/bhyve/Makefile
+++ b/usr.sbin/bhyve/Makefile
@@ -87,13 +87,17 @@ CFLAGS+=-DINET6
 .if ${MK_OPENSSL} == "no"
 CFLAGS+=-DNO_OPENSSL
 .else
-LIBADD+=	crypto
+LIBADD+=	crypto dtrace
 .endif
 
 CFLAGS+= -I${BHYVE_SYSDIR}/sys/dev/e1000
 CFLAGS+= -I${BHYVE_SYSDIR}/sys/dev/mii
 CFLAGS+= -I${BHYVE_SYSDIR}/sys/dev/usb/controller
 CFLAGS+= -I${BHYVE_SYSDIR}/sys/dev/virtio/dtrace
+CFLAGS+=-I${BHYVE_SYSDIR}/cddl/contrib/opensolaris/lib/libctf/common
+CFLAGS+=-I${BHYVE_SYSDIR}/sys/cddl/compat/opensolaris
+CFLAGS+=-I${BHYVE_SYSDIR}/sys/cddl/contrib/opensolaris/uts/common
+CFLAGS+=-I${BHYVE_SYSDIR}/cddl/contrib/opensolaris/lib/libdtrace/common
 
 .ifdef GDB_LOG
 CFLAGS+=-DGDB_LOG
diff --git a/usr.sbin/bhyve/bhyverun.c b/usr.sbin/bhyve/bhyverun.c
index 17bbc71a62d..402a1deea25 100644
--- a/usr.sbin/bhyve/bhyverun.c
+++ b/usr.sbin/bhyve/bhyverun.c
@@ -164,6 +164,7 @@ extern int vmexit_task_switch(struct vmctx *, struct vm_exit *, int *vcpu);
 
 char *vmname;
 
+int dir_fd;
 int guest_ncpus;
 uint16_t cores, maxcpus, sockets, threads;
 
@@ -952,7 +953,7 @@ do_open(const char *vmname)
 	}
 
 #ifndef WITHOUT_CAPSICUM
-	cap_rights_init(&rights, CAP_IOCTL, CAP_MMAP_RW);
+	cap_rights_init(&rights, CAP_IOCTL, CAP_MMAP_RW, CAP_READ, CAP_WRITE, CAP_FEXECVE);
 	if (cap_rights_limit(vm_get_device_fd(ctx), &rights) == -1 &&
 	    errno != ENOSYS)
 		errx(EX_OSERR, "Unable to apply rights for sandbox");
@@ -1120,8 +1121,12 @@ main(int argc, char *argv[])
 	vmname = argv[0];
 
 #ifndef VTDTR
-	if (trace)
+	if (trace) {
 		dthyve_init(vmname);
+		dir_fd = open("/tmp/", O_RDONLY);
+		printf("%s", strerror(errno));
+		assert(dir_fd != -1);
+	}
 #endif
 
 	ctx = do_open(vmname);
diff --git a/usr.sbin/bhyve/bhyverun.h b/usr.sbin/bhyve/bhyverun.h
index fe4508ed072..aca4b45186f 100644
--- a/usr.sbin/bhyve/bhyverun.h
+++ b/usr.sbin/bhyve/bhyverun.h
@@ -35,6 +35,11 @@
 #define	VMEXIT_ABORT		(-1)
 
 struct vmctx;
+
+#ifndef VTDTR
+    extern int dir_fd;
+#endif
+
 extern int guest_ncpus;
 extern char *guest_uuid_str;
 extern char *vmname;
diff --git a/usr.sbin/bhyve/pci_virtio_dtrace.c b/usr.sbin/bhyve/pci_virtio_dtrace.c
index e8a69df0182..3e39eb419e3 100644
--- a/usr.sbin/bhyve/pci_virtio_dtrace.c
+++ b/usr.sbin/bhyve/pci_virtio_dtrace.c
@@ -41,7 +41,7 @@ __FBSDID("$FreeBSD$");
 #include <sys/ucred.h>
 #include <sys/dtrace_bsd.h>
 #include <sys/vtdtr.h>
-
+#include <sys/stat.h>
 #include <machine/vmm.h>
 
 #include <stdio.h>
@@ -51,6 +51,8 @@ __FBSDID("$FreeBSD$");
 #include <assert.h>
 #include <pthread.h>
 #include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
 
 #include <vmmapi.h>
 
@@ -59,8 +61,10 @@ __FBSDID("$FreeBSD$");
 #include "pci_emul.h"
 #include "virtio.h"
 
-#define	VTDTR_RINGSZ 512
-#define	VTDTR_MAXQ     2
+#define VTDTR_RINGSZ 8192
+#define FRAGMENTSZ 4000
+#define SCRIPTSZ 512
+#define VTDTR_MAXQ 2
 
 /*
  * As already documented in virtio_dtrace.h, probe installation/uninstallation
@@ -74,118 +78,203 @@ __FBSDID("$FreeBSD$");
  * READY and EOF are used for synchronization purposes, while CLEANUP is meant
  * to be sent to the guest in order to clean up the TX virtqueue.
  */
-#define	VTDTR_DEVICE_READY           0x00
-#define	VTDTR_DEVICE_REGISTER        0x01
-#define	VTDTR_DEVICE_UNREGISTER      0x02
-#define	VTDTR_DEVICE_DESTROY         0x03
-#define	VTDTR_DEVICE_PROBE_CREATE    0x04
-#define	VTDTR_DEVICE_PROBE_INSTALL   0x05
-#define	VTDTR_DEVICE_PROBE_UNINSTALL 0x06
-#define	VTDTR_DEVICE_EOF             0x07
-#define VTDTR_DEVICE_GO              0x08
-#define VTDTR_DEVICE_STOP            0x09
-
-static int pci_vtdtr_debug;
-#define	DPRINTF(params) if (pci_vtdtr_debug) printf params
-#define	WPRINTF(params) printf params
-
-struct pci_vtdtr_probe_create_event {
-	char        mod[DTRACE_MODNAMELEN];
-	char        func[DTRACE_FUNCNAMELEN];
-	char        name[DTRACE_NAMELEN];
+#define VTDTR_DEVICE_READY 0x00
+#define VTDTR_DEVICE_REGISTER 0x01
+#define VTDTR_DEVICE_UNREGISTER 0x02
+#define VTDTR_DEVICE_DESTROY 0x03
+#define VTDTR_DEVICE_PROBE_CREATE 0x04
+#define VTDTR_DEVICE_PROBE_INSTALL 0x05
+#define VTDTR_DEVICE_PROBE_UNINSTALL 0x06
+#define VTDTR_DEVICE_EOF 0x07
+#define VTDTR_DEVICE_GO 0x08
+#define VTDTR_DEVICE_STOP 0x09
+#define VTDTR_DEVICE_SCRIPT 0x10
+#define VTDTR_DEVICE_TRACE 0x11
+#define VTDTR_DEVICE_METADATA 0x12
+
+#define NFORMAT 0x00
+#define FORMAT_STRING 0x01
+#define NPROBES 0x02
+#define NPDESC 0x03
+#define PROBE_DESCRIPTION 0x04
+#define EPROBE_DESCRIPTION 0x05
+
+static FILE *fp, *meta_stream, *trace_stream;
+
+/*
+* Debug printf
+*/
+static int pci_vtdtr_debug = 0;
+#define DPRINTF(params)  if (pci_vtdtr_debug) printf params
+#define WPRINTF(params) printf params
+
+struct pci_vtdtr_reader_args
+{
+	struct pci_vtdtr_softc *sc;
+	int fd;
+};
+
+struct pci_vtdtr_probe_create_event
+{
+	char mod[DTRACE_MODNAMELEN];
+	char func[DTRACE_FUNCNAMELEN];
+	char name[DTRACE_NAMELEN];
 	struct uuid uuid;
-}__attribute__((packed));
+} __attribute__((packed));
 
-struct pci_vtdtr_probe_toggle_event {
+struct pci_vtdtr_probe_toggle_event
+{
 	char *dif; /* TODO */
-}__attribute__((packed));
+} __attribute__((packed));
 
-struct pci_vtdtr_ctrl_pbevent {
+struct pci_vtdtr_ctrl_pbevent
+{
 	uint32_t probe;
 
 	union {
 		struct pci_vtdtr_probe_create_event probe_evcreate;
 		struct pci_vtdtr_probe_toggle_event probe_evtoggle;
 	} upbev;
-}__attribute__((packed));
+} __attribute__((packed));
+
+struct pci_vtdtr_ctrl_provevent
+{
+	char name[DTRACE_PROVNAMELEN];
+	struct uuid uuid;
+} __attribute__((packed));
+
+struct pci_vtdtr_ctrl_scriptevent
+{
+	int last;
+	char d_script[SCRIPTSZ];
+	struct uuid uuid;
+} __attribute__((packed));
 
-struct pci_vtdtr_ctrl_provevent {
-	char        name[DTRACE_PROVNAMELEN];
+struct pci_vtdtr_ctrl_trcevent
+{
+	int first_chunk;
+	int last_chunk;
+	uint64_t chunk_sz;
+	uint64_t dtbd_size;
+	uint32_t dtbd_cpu;
+	uint32_t dtbd_errors;
+	uint32_t dtbd_drops;
+	char dtbd_chunk[FRAGMENTSZ];
+	uint64_t dtbd_oldest;
+	uint64_t dtbd_timestamp;
 	struct uuid uuid;
-}__attribute__((packed));
+} __attribute__((packed));
+
+struct pci_vtdtr_ctrl_metaevent
+{
+	uint32_t type;
 
-struct pci_vtdtr_control {
+	union {
+		int dts_nformats;
+		char dts_fmtstr[FRAGMENTSZ];
+		int dt_nprobes;
+		int dt_npdescs;
+		struct
+		{
+			size_t buf_size;
+			char buf[FRAGMENTSZ];
+		} dt_pdesc;
+		struct
+		{
+			size_t buf_size;
+			char buf[FRAGMENTSZ];
+		} dt_epdesc;
+	} umtd;
+	struct uuid uuid;
+} __attribute__((packed));
+
+/** These are the types of elements that can be in the control queue, 
+ * which is drained by putting it's content into the virtual queue and
+ * sending events.
+*/
+struct pci_vtdtr_control
+{
 	uint32_t event;
 
 	union {
-		struct pci_vtdtr_ctrl_pbevent   probe_ev;
+		struct pci_vtdtr_ctrl_pbevent probe_ev;
 		struct pci_vtdtr_ctrl_provevent prov_ev;
+		struct pci_vtdtr_ctrl_scriptevent script_ev;
+		struct pci_vtdtr_ctrl_trcevent trc_ev;
+		struct pci_vtdtr_ctrl_metaevent mtd_ev;
 	} uctrl;
-}__attribute__((packed));
+} __attribute__((packed));
 
-struct pci_vtdtr_ctrl_entry {
-	struct pci_vtdtr_control           ctrl;
-	STAILQ_ENTRY(pci_vtdtr_ctrl_entry) entries;
+struct pci_vtdtr_ctrl_entry
+{
+	struct pci_vtdtr_control ctrl;
+	//make each element be a queue element
+	STAILQ_ENTRY(pci_vtdtr_ctrl_entry)
+	entries;
 };
 
-struct pci_vtdtr_ctrlq {
-	STAILQ_HEAD(, pci_vtdtr_ctrl_entry) head;
-	pthread_mutex_t                          mtx;
+struct pci_vtdtr_ctrlq
+{
+	STAILQ_HEAD(, pci_vtdtr_ctrl_entry)
+	head;
+	pthread_mutex_t mtx;
 };
 
-struct pci_vtdtr_softc {
-	struct virtio_softc     vsd_vs;
-	struct vqueue_info      vsd_queues[VTDTR_MAXQ];
-	struct vmctx           *vsd_vmctx;
+struct pci_vtdtr_softc
+{
+	struct virtio_softc vsd_vs;
+	struct vqueue_info vsd_queues[VTDTR_MAXQ];
+	struct vmctx *vsd_vmctx;
 	struct pci_vtdtr_ctrlq *vsd_ctrlq;
-	pthread_mutex_t         vsd_condmtx;
-	pthread_cond_t          vsd_cond;
-	pthread_mutex_t         vsd_mtx;
-	uint64_t                vsd_cfg;
-	int                     vsd_guest_ready;
-	int                     vsd_ready;
+	pthread_mutex_t vsd_condmtx;
+	pthread_cond_t vsd_cond;
+	pthread_mutex_t vsd_mtx;
+	uint64_t vsd_cfg;
+	int vsd_guest_ready;
+	int vsd_ready;
 };
 
 static void pci_vtdtr_reset(void *);
 static void pci_vtdtr_control_tx(struct pci_vtdtr_softc *,
-    struct iovec *, int);
+								 struct iovec *, int);
 static int pci_vtdtr_control_rx(struct pci_vtdtr_softc *,
-    struct iovec *, int);
+								struct iovec *, int);
 static void pci_vtdtr_process_prov_evt(struct pci_vtdtr_softc *,
-    struct pci_vtdtr_control *);
+									   struct pci_vtdtr_control *);
 static void pci_vtdtr_process_probe_evt(struct pci_vtdtr_softc *,
-    struct pci_vtdtr_control *);
+										struct pci_vtdtr_control *);
 static void pci_vtdtr_notify_tx(void *, struct vqueue_info *);
 static void pci_vtdtr_notify_rx(void *, struct vqueue_info *);
 static void pci_vtdtr_cq_enqueue(struct pci_vtdtr_ctrlq *,
-    struct pci_vtdtr_ctrl_entry *);
+								 struct pci_vtdtr_ctrl_entry *);
 static void pci_vtdtr_cq_enqueue_front(struct pci_vtdtr_ctrlq *,
-    struct pci_vtdtr_ctrl_entry *);
+									   struct pci_vtdtr_ctrl_entry *);
 static int pci_vtdtr_cq_empty(struct pci_vtdtr_ctrlq *);
 static struct pci_vtdtr_ctrl_entry *pci_vtdtr_cq_dequeue(
-    struct pci_vtdtr_ctrlq *);
-static void pci_vtdtr_fill_desc(struct vqueue_info *,
-    struct pci_vtdtr_control *);
+	struct pci_vtdtr_ctrlq *);
+static int pci_vtdtr_fill_desc(struct vqueue_info *,
+							   struct pci_vtdtr_control *);
 static void pci_vtdtr_poll(struct vqueue_info *, int);
 static void pci_vtdtr_notify_ready(struct pci_vtdtr_softc *);
 static void pci_vtdtr_fill_eof_desc(struct vqueue_info *);
-static void * pci_vtdtr_run(void *);
+static void *pci_vtdtr_run(void *);
 #if 0
 static void pci_vtdtr_handle_mev(int, enum ev_type, int, void *);
 #endif
 static void pci_vtdtr_reset_queue(struct pci_vtdtr_softc *);
 static int pci_vtdtr_init(struct vmctx *, struct pci_devinst *, char *);
+static void *pci_vtdtr_read_script(void *);
 
 static struct virtio_consts vtdtr_vi_consts = {
-	"vtdtr",			/* name */
-	VTDTR_MAXQ,			/* maximum virtqueues */
-	0,				/* config reg size */
-	pci_vtdtr_reset,		/* reset */
-	NULL,				/* device-wide qnotify */
-	NULL,				/* read virtio config */
-	NULL,				/* write virtio config */
-	NULL,				/* apply negotiated features */
-	0,				/* capabilities */
+	"vtdtr",		 /* name */
+	VTDTR_MAXQ,		 /* maximum virtqueues */
+	0,				 /* config reg size */
+	pci_vtdtr_reset, /* reset */
+	NULL,			 /* device-wide qnotify */
+	NULL,			 /* read virtio config */
+	NULL,			 /* write virtio config */
+	NULL,			 /* apply negotiated features */
+	0,				 /* capabilities */
 };
 
 static void
@@ -219,15 +308,23 @@ static int
 pci_vtdtr_control_rx(struct pci_vtdtr_softc *sc, struct iovec *iov, int niov)
 {
 	struct pci_vtdtr_control *ctrl;
+	struct pci_vtdtr_ctrl_trcevent *trc_ev;
+	struct pci_vtdtr_ctrl_metaevent *mtd_ev;
+	char *data;
+	uintptr_t dest;
+
 	//struct pci_vtdtr_ctrl_provevent *pv_ev;
 	//struct pci_vtdtr_ctrl_pbevent *pb_ev;
-	int retval;// error;
+	int fd, npdesc, retval; // error;
+	size_t sz, fmt_len, pdesc_len, epdesc_len;
+	uint64_t data_sz;
 
 	assert(niov == 1);
 	retval = 0;
 
 	ctrl = (struct pci_vtdtr_control *)iov->iov_base;
-	switch (ctrl->event) {
+	switch (ctrl->event)
+	{
 	case VTDTR_DEVICE_READY:
 		pthread_mutex_lock(&sc->vsd_mtx);
 		sc->vsd_guest_ready = 1;
@@ -280,6 +377,93 @@ pci_vtdtr_control_rx(struct pci_vtdtr_softc *sc, struct iovec *iov, int niov)
 	case VTDTR_DEVICE_PROBE_UNINSTALL:
 		break;
 #endif
+	case VTDTR_DEVICE_TRACE:
+		pthread_mutex_lock(&sc->vsd_mtx);
+		sc->vsd_ready = 0;
+		pthread_mutex_unlock(&sc->vsd_mtx);
+		DPRINTF(("I've received trace data. Trace data size is: %zu. \n", ctrl->uctrl.trc_ev.dtbd_size));
+		trc_ev = &ctrl->uctrl.trc_ev;
+		DPRINTF(("First chunk is: %d, last chunk is:%d", trc_ev->first_chunk, trc_ev->last_chunk));
+		if (trc_ev->first_chunk == 1)
+		{
+			sz = fwrite(&trc_ev->dtbd_size, sizeof(uint64_t), 1, trace_stream);
+			assert(sz > 0);
+			sz = fwrite(&trc_ev->dtbd_cpu, sizeof(uint32_t), 1, trace_stream);
+			assert(sz > 0);
+			sz = fwrite(&trc_ev->dtbd_errors, sizeof(uint32_t), 1, trace_stream);
+			assert(sz > 0);
+			sz = fwrite(&trc_ev->dtbd_drops, sizeof(uint64_t), 1, trace_stream);
+			assert(sz > 0);
+			sz = fwrite(&trc_ev->dtbd_oldest, sizeof(uint64_t), 1, trace_stream);
+			assert(sz > 0);
+			sz = fwrite(&trc_ev->dtbd_timestamp, sizeof(uint64_t), 1, trace_stream);
+			assert(sz > 0);
+		}
+
+		sz = fwrite(&trc_ev->dtbd_chunk, 1, trc_ev->chunk_sz, trace_stream);
+		fwrite(&trc_ev->dtbd_chunk, 1, trc_ev->chunk_sz, fp);
+		fflush(fp);
+		DPRINTF(("I've written: %d. \n", sz));
+		assert(sz == trc_ev->chunk_sz);
+		fflush(trace_stream);
+		break;
+	case VTDTR_DEVICE_METADATA:
+		pthread_mutex_lock(&sc->vsd_mtx);
+		sc->vsd_ready = 0;
+		pthread_mutex_unlock(&sc->vsd_mtx);
+		DPRINTF(("I've received metadata. \n"));
+		mtd_ev = &ctrl->uctrl.mtd_ev;
+
+		switch (mtd_ev->type)
+		{
+		case NFORMAT:
+			DPRINTF(("Got NFORMAT: %d. \n", mtd_ev->umtd.dts_nformats));
+			sz = fwrite(&mtd_ev->umtd.dts_nformats, sizeof(int), 1, meta_stream);
+			assert(sz > 0);
+			break;
+		case FORMAT_STRING:
+			DPRINTF(("Got FORMAT_STRING. \n"));
+			fmt_len = strlen(mtd_ev->umtd.dts_fmtstr);
+			sz = fwrite(&fmt_len, sizeof(size_t), 1, meta_stream);
+			assert(sz > 0);
+			sz = fwrite(&mtd_ev->umtd.dts_fmtstr, 1, fmt_len, meta_stream);
+			assert(sz == fmt_len);
+			break;
+		case NPROBES:
+			DPRINTF(("Got NPROBES: %d. \n", mtd_ev->umtd.dt_nprobes));
+			sz = fwrite(&mtd_ev->umtd.dt_nprobes, sizeof(int), 1, meta_stream);
+			assert(sz > 0);
+			break;
+		case NPDESC:
+			DPRINTF(("GOT NPDESC: %d. \n", mtd_ev->umtd.dt_npdescs));
+			sz = fwrite(&mtd_ev->umtd.dt_npdescs, sizeof(mtd_ev->umtd.dt_npdescs), 1, meta_stream);
+			DPRINTF(("I've written: %d", sz));
+			assert(sz > 0);
+			break;
+		case PROBE_DESCRIPTION:
+			pdesc_len = mtd_ev->umtd.dt_pdesc.buf_size;
+			assert(pdesc_len > 0);
+			DPRINTF(("Got PROBE_DESCRIPTION: %d. \n", pdesc_len));
+			sz = fwrite(&mtd_ev->umtd.dt_pdesc.buf, 1, pdesc_len, meta_stream);
+			assert(sz == pdesc_len);
+			break;
+		case EPROBE_DESCRIPTION:
+			epdesc_len = mtd_ev->umtd.dt_epdesc.buf_size;
+			assert(epdesc_len > 0);
+			DPRINTF(("Got EPROBE_DESCRIPTION: %d. \n", epdesc_len));
+			sz = fwrite(&mtd_ev->umtd.dt_epdesc.buf_size, sizeof(size_t), 1, meta_stream);
+			assert(sz > 0);
+			sz = fwrite(&mtd_ev->umtd.dt_epdesc.buf, 1, epdesc_len, meta_stream);
+			fwrite(&mtd_ev->umtd.dt_epdesc.buf, 1, epdesc_len, fp);
+			fflush(fp);
+			assert(sz == epdesc_len);
+			break;
+		default:
+			WPRINTF(("WARNING: Wrong metadata event. "));
+			break;
+		}
+		fflush(meta_stream);
+		break;
 	case VTDTR_DEVICE_EOF:
 		retval = 1;
 		break;
@@ -293,7 +477,7 @@ pci_vtdtr_control_rx(struct pci_vtdtr_softc *sc, struct iovec *iov, int niov)
 
 static void
 pci_vtdtr_process_prov_evt(struct pci_vtdtr_softc *sc,
-    struct pci_vtdtr_control *ctrl)
+						   struct pci_vtdtr_control *ctrl)
 {
 	/*
 	 * XXX: The processing functions... are the actually
@@ -304,9 +488,8 @@ pci_vtdtr_process_prov_evt(struct pci_vtdtr_softc *sc,
 
 static void
 pci_vtdtr_process_probe_evt(struct pci_vtdtr_softc *sc,
-    struct pci_vtdtr_control *ctrl)
+							struct pci_vtdtr_control *ctrl)
 {
-
 }
 
 static void
@@ -322,16 +505,71 @@ static void
 pci_vtdtr_notify_rx(void *xsc, struct vqueue_info *vq)
 {
 	struct pci_vtdtr_softc *sc;
+	struct pci_vtdtr_control *ctrl;
 	struct iovec iov[1];
 	uint16_t idx;
 	uint16_t flags[8];
 	int n;
 	int retval;
+	int fd, meta_open = 0, trace_open = 0;
 
 	sc = xsc;
 
-	while (vq_has_descs(vq)) {
+	while (vq_has_descs(vq))
+	{
 		n = vq_getchain(vq, &idx, iov, 1, flags);
+		ctrl = (struct pci_vtdtr_control *)iov->iov_base;
+		if (ctrl->event == VTDTR_DEVICE_METADATA && !meta_open)
+		{
+			if (trace_open)
+			{
+				fflush(trace_stream);
+				fclose(trace_stream);
+				close(fd);
+				trace_open = 0;
+			}
+
+			if (!meta_open)
+			{
+				if ((fd = openat(dir_fd, "meta_fifo", O_WRONLY)) == -1)
+				{
+					WPRINTF(("Failed to open metadata write pipe: %s. \n", strerror(errno)));
+					exit(1);
+				}
+
+				if ((meta_stream = fdopen(fd, "w")) == NULL)
+				{
+					WPRINTF(("Failed opening metadata stream: %s. \n", strerror(errno)));
+					exit(1);
+				}
+				meta_open = 1;
+			}
+		}
+		else if (ctrl->event == VTDTR_DEVICE_TRACE)
+		{
+
+			if (meta_open)
+			{
+				fflush(meta_stream);
+				fclose(meta_stream);
+				close(fd);
+				meta_open = 0;
+			}
+
+			if (!trace_open)
+			{
+				if ((fd = openat(dir_fd, "trace_fifo", O_WRONLY)) == -1)
+				{
+					DPRINTF(("Failed to open metadata write pipe: %s. \n", strerror(errno)));
+				}
+
+				if ((trace_stream = fdopen(fd, "w")) == NULL)
+				{
+					DPRINTF(("Failed opening metadata stream: %s. \n", strerror(errno)));
+				}
+				trace_open = 1;
+			}
+		}
 		retval = pci_vtdtr_control_rx(sc, iov, 1);
 		vq_relchain(vq, idx, sizeof(struct pci_vtdtr_control));
 		if (retval == 1)
@@ -348,7 +586,6 @@ pci_vtdtr_notify_rx(void *xsc, struct vqueue_info *vq)
 	pthread_mutex_lock(&sc->vsd_condmtx);
 	pthread_cond_signal(&sc->vsd_cond);
 	pthread_mutex_unlock(&sc->vsd_condmtx);
-
 }
 
 #if 0
@@ -399,24 +636,21 @@ pci_vtdtr_handle_mev(int fd __unused, enum ev_type et __unused, int ne,
 
 static __inline void
 pci_vtdtr_cq_enqueue(struct pci_vtdtr_ctrlq *cq,
-    struct pci_vtdtr_ctrl_entry *ctrl_entry)
+					 struct pci_vtdtr_ctrl_entry *ctrl_entry)
 {
-
 	STAILQ_INSERT_TAIL(&cq->head, ctrl_entry, entries);
 }
 
 static __inline void
 pci_vtdtr_cq_enqueue_front(struct pci_vtdtr_ctrlq *cq,
-    struct pci_vtdtr_ctrl_entry *ctrl_entry)
+						   struct pci_vtdtr_ctrl_entry *ctrl_entry)
 {
-
 	STAILQ_INSERT_HEAD(&cq->head, ctrl_entry, entries);
 }
 
 static __inline int
 pci_vtdtr_cq_empty(struct pci_vtdtr_ctrlq *cq)
 {
-
 	return (STAILQ_EMPTY(&cq->head));
 }
 
@@ -425,10 +659,11 @@ pci_vtdtr_cq_dequeue(struct pci_vtdtr_ctrlq *cq)
 {
 	struct pci_vtdtr_ctrl_entry *ctrl_entry;
 	ctrl_entry = STAILQ_FIRST(&cq->head);
-	if (ctrl_entry != NULL) {
+	if (ctrl_entry != NULL)
+	{
 		STAILQ_REMOVE_HEAD(&cq->head, entries);
 	}
-
+	
 	return (ctrl_entry);
 }
 
@@ -436,7 +671,7 @@ pci_vtdtr_cq_dequeue(struct pci_vtdtr_ctrlq *cq)
  * In this function we fill the descriptor that was provided to us by the guest.
  * No allocation is needed, since we memcpy everything.
  */
-static void
+static int
 pci_vtdtr_fill_desc(struct vqueue_info *vq, struct pci_vtdtr_control *ctrl)
 {
 	struct iovec iov;
@@ -448,9 +683,18 @@ pci_vtdtr_fill_desc(struct vqueue_info *vq, struct pci_vtdtr_control *ctrl)
 	assert(n == 1);
 
 	len = sizeof(struct pci_vtdtr_control);
-	memcpy(iov.iov_base, ctrl, len);
 
+	/* 
+	* Since each iovec has a different length we need to check we
+	* can copy the control queue element in the current iovec. Otherwise, 
+	* we return -1 and the element will be enqueued again in the control queue.
+	*/
+	if (iov.iov_len < len)
+		return -1;
+
+	memcpy(iov.iov_base, ctrl, len);
 	vq_relchain(vq, idx, len);
+	return 0;
 }
 
 static void
@@ -481,7 +725,6 @@ pci_vtdtr_notify_ready(struct pci_vtdtr_softc *sc)
 
 	ctrl->event = VTDTR_DEVICE_READY;
 
-
 	pthread_mutex_lock(&sc->vsd_ctrlq->mtx);
 	pci_vtdtr_cq_enqueue_front(sc->vsd_ctrlq, ctrl_entry);
 	pthread_mutex_unlock(&sc->vsd_ctrlq->mtx);
@@ -500,6 +743,7 @@ pci_vtdtr_fill_eof_desc(struct vqueue_info *vq)
  * serves the purpose of draining the control queue of messages and filling the
  * guest memory with the descriptors.
  */
+/*Mara's note: See if you can avoid touching this.*/
 static void *
 pci_vtdtr_run(void *xsc)
 {
@@ -513,13 +757,15 @@ pci_vtdtr_run(void *xsc)
 	sc = xsc;
 	vq = &sc->vsd_queues[0];
 
-	for (;;) {
+	for (;;)
+	{
 		nent = 0;
 		error = 0;
 		ready_flag = 1;
 
 		error = pthread_mutex_lock(&sc->vsd_condmtx);
 		assert(error == 0);
+
 		/*
 		 * We are safe to proceed if the following conditions are
 		 * satisfied:
@@ -527,7 +773,8 @@ pci_vtdtr_run(void *xsc)
 		 * (2) The guest is ready
 		 */
 		while (!sc->vsd_guest_ready ||
-		    pci_vtdtr_cq_empty(sc->vsd_ctrlq)) {
+			   pci_vtdtr_cq_empty(sc->vsd_ctrlq))
+		{
 			error = pthread_cond_wait(&sc->vsd_cond, &sc->vsd_condmtx);
 			assert(error == 0);
 		}
@@ -543,18 +790,37 @@ pci_vtdtr_run(void *xsc)
 		 * While dealing with the entires, we will fill every single
 		 * entry as long as we have space or entries in the queue.
 		 */
-		while (vq_has_descs(vq) && !pci_vtdtr_cq_empty(sc->vsd_ctrlq)) {
+		while (vq_has_descs(vq) && !pci_vtdtr_cq_empty(sc->vsd_ctrlq))
+		{
 			ctrl_entry = pci_vtdtr_cq_dequeue(sc->vsd_ctrlq);
-			error = pthread_mutex_unlock(&sc->vsd_ctrlq->mtx);
-			assert(error == 0);
+			// error = pthread_mutex_unlock(&sc->vsd_ctrlq->mtx);
+			// assert(error == 0);
 
 			if (ready_flag &&
-			    ctrl_entry->ctrl.event != VTDTR_DEVICE_READY)
+				ctrl_entry->ctrl.event != VTDTR_DEVICE_READY)
 				ready_flag = 0;
 
-			pci_vtdtr_fill_desc(vq, &ctrl_entry->ctrl);
-			free(ctrl_entry);
-			nent++;
+			error = pci_vtdtr_fill_desc(vq, &ctrl_entry->ctrl);
+
+			/*
+			* If the size of the iovec element is not large enough to enqueue
+			* the control queue entry in the virtual queue, enqueue back to
+			* front of control queue and try again.
+			*/
+			if (!error)
+			{
+				free(ctrl_entry);
+				nent++;
+			}
+			else
+			{
+				WPRINTF(("Warning: not enough space to enqueue event in virtual queue, trying again."));
+				pci_vtdtr_cq_enqueue_front(sc->vsd_ctrlq, ctrl_entry);
+			}
+
+			error = pthread_mutex_unlock(&sc->vsd_ctrlq->mtx);
+			assert(error == 0);
+
 			error = pthread_mutex_lock(&sc->vsd_ctrlq->mtx);
 			assert(error == 0);
 		}
@@ -565,9 +831,11 @@ pci_vtdtr_run(void *xsc)
 		 * EOF descriptor to send to the guest. Following that, we end
 		 * the chains and force an interrupt in the guest
 		 */
-		if (nent) {
+		if (nent)
+		{
 			if (pci_vtdtr_cq_empty(sc->vsd_ctrlq) &&
-			    vq_has_descs(vq)) {
+				vq_has_descs(vq))
+			{
 				pci_vtdtr_fill_eof_desc(vq);
 			}
 			pthread_mutex_lock(&sc->vsd_mtx);
@@ -577,7 +845,6 @@ pci_vtdtr_run(void *xsc)
 		}
 
 		error = pthread_mutex_unlock(&sc->vsd_ctrlq->mtx);
-
 	}
 
 	pthread_exit(NULL);
@@ -596,7 +863,8 @@ pci_vtdtr_reset_queue(struct pci_vtdtr_softc *sc)
 
 	pthread_mutex_lock(&q->mtx);
 	n1 = STAILQ_FIRST(&q->head);
-	while (n1 != NULL) {
+	while (n1 != NULL)
+	{
 		n2 = STAILQ_NEXT(n1, entries);
 		free(n1);
 		n1 = n2;
@@ -608,11 +876,12 @@ pci_vtdtr_reset_queue(struct pci_vtdtr_softc *sc)
 
 static int
 pci_vtdtr_find(const char *vm,
-    char vms[VTDTR_MAXVMS][VTDTR_VMNAMEMAX], size_t count)
+			   char vms[VTDTR_MAXVMS][VTDTR_VMNAMEMAX], size_t count)
 {
 	size_t i;
 
-	for (i = 0; i < count; i++) {
+	for (i = 0; i < count; i++)
+	{
 		if (strcmp(vm, vms[i]) == 0)
 			return (0);
 	}
@@ -620,7 +889,7 @@ pci_vtdtr_find(const char *vm,
 	return (-1);
 }
 
-static void *
+static void
 pci_vtdtr_events(void *xsc)
 {
 	struct pci_vtdtr_softc *sc;
@@ -634,27 +903,31 @@ pci_vtdtr_events(void *xsc)
 	/*
 	 * We listen for events indefinitely.
 	 */
-	for (;;) {
+	for (;;)
+	{
 		struct vtdtr_event ev;
 		struct pci_vtdtr_ctrl_entry *ctrl_entry;
 		struct pci_vtdtr_control *ctrl;
 
 		error = dthyve_read(&ev, 1);
-		if (error) {
+		if (error)
+		{
 			fprintf(stderr, "Error: '%s' reading.\n",
-			    strerror(error));
+					strerror(error));
 			if (errno == EINTR)
-			        exit(1);
+				exit(1);
 
 			continue;
 		}
 
+		// assigns block of memory to a control queue entry
 		ctrl_entry = malloc(sizeof(struct pci_vtdtr_ctrl_entry));
 		assert(ctrl_entry != NULL);
 		ctrl = &ctrl_entry->ctrl;
 
 		DPRINTF(("event read: %zu\n", ev.type));
-		switch (ev.type) {
+		switch (ev.type)
+		{
 		case VTDTR_EV_INSTALL:
 			ctrl->event = VTDTR_DEVICE_PROBE_INSTALL;
 			break;
@@ -674,10 +947,11 @@ pci_vtdtr_events(void *xsc)
 			char *vm = vm_get_name(sc->vsd_vmctx);
 
 			if (pci_vtdtr_find(vm, ev.args.d_config.vms,
-			    ev.args.d_config.count) == 0) {
+							   ev.args.d_config.count) == 0)
+			{
 				flags |= (1 << VTDTR_EV_INSTALL) |
-				    (1 << VTDTR_EV_STOP)         |
-				    (1 << VTDTR_EV_GO);
+						 (1 << VTDTR_EV_STOP) |
+						 (1 << VTDTR_EV_GO);
 			}
 
 			error = dthyve_conf(flags, 0);
@@ -702,6 +976,144 @@ pci_vtdtr_events(void *xsc)
 	}
 }
 
+/*
+ * Listen for scripts sent from dtrace indefinitely.
+ */
+static void *pci_vtdtr_listen(void *xsc)
+{
+	struct pci_vtdtr_reader_args *args;
+	pthread_t reader;
+	char *fifo;
+	int error, fd;
+
+	fifo = "/tmp/fifo";
+	error = mkfifo(fifo, 0666);
+
+	if (error)
+	{
+		WPRINTF(("Failed to make fifo: %s", strerror(errno)));
+	}
+
+	for (;;)
+	{
+
+		if ((fd = openat(dir_fd, "fifo", O_RDONLY)) == -1)
+		{
+			WPRINTF(("Failed to open pipe: %s. \n", strerror(errno)));
+			exit(1);
+		}
+
+		args = malloc(sizeof(struct pci_vtdtr_reader_args));
+		args->sc = xsc;
+		args->fd = fd;
+
+		error = pthread_create(&reader, NULL, pci_vtdtr_read_script, (void *)args);
+		assert(error == 0);
+		error = pthread_join(reader, NULL);
+		assert(error == 0);
+
+		free(args);
+		close(fd);
+		//unlink(fifo);
+	}
+}
+
+/**
+	Reads scripts provided by the user from the named pipe and puts it in the
+	control queue.
+*/
+static void *pci_vtdtr_read_script(void *xargs)
+{
+	FILE *reader_stream;
+	struct pci_vtdtr_reader_args *args;
+	struct pci_vtdtr_softc *sc;
+	struct pci_vtdtr_ctrl_entry *ctrl_entry;
+	struct pci_vtdtr_control *ctrl;
+	char *d_script, *fifo, *content;
+	size_t d_script_length;
+	int copied, done, fd, i, sz, fragment_length;
+
+	args = xargs;
+	sc = args->sc;
+	fd = args->fd;
+
+	if ((reader_stream = fdopen(fd, "r")) == NULL)
+	{
+		WPRINTF(("Failed opening read stream: %s. \n", strerror(errno)));
+		exit(1);
+	}
+
+	sz = fread(&d_script_length, sizeof(long), 1, reader_stream);
+	if (sz <= 0)
+	{
+		WPRINTF(("Failed reading size of script from the named pipe: %s. \n", strerror(errno)));
+		exit(1);
+	}
+	DPRINTF(("Size of script is: %zu. \n", d_script_length));
+
+	while (!done)
+	{
+		if (d_script_length > SCRIPTSZ - 1)
+		{
+			fragment_length = SCRIPTSZ - 1;
+			d_script_length -= fragment_length;
+		}
+		else
+		{
+			fragment_length = d_script_length;
+			done = 1;
+		}
+		DPRINTF(("Iteration: %d. Done is: %d.\n", ++i, done));
+
+		d_script = malloc(fragment_length + 1);
+		if ((fread(d_script, 1, fragment_length, reader_stream)) != fragment_length)
+		{
+			DPRINTF(("Failed reading script from the named pipe.\n"));
+			if (ferror(reader_stream))
+			{
+				DPRINTF(("Error is:%s.\n", strerror(errno)));
+			}
+
+			exit(1);
+		}
+		d_script[fragment_length + 1] = '\0';
+
+		if (done)
+		{
+			fclose(reader_stream);
+			// close(fd);
+			// unlink(fifo);
+		}
+
+
+		ctrl_entry = malloc(sizeof(struct pci_vtdtr_ctrl_entry));
+		assert(ctrl_entry != NULL);
+		memset(ctrl_entry, 0, sizeof(struct pci_vtdtr_ctrl_entry));
+		ctrl = &ctrl_entry->ctrl;
+
+		ctrl->event = VTDTR_DEVICE_SCRIPT;
+
+		if (strlcpy(ctrl->uctrl.script_ev.d_script, d_script, fragment_length + 1) >= fragment_length + 1)
+		{
+			DPRINTF(("Failed copying script in control element:\n%s. \n", strerror(errno)));
+			exit(1);
+		}
+		ctrl->uctrl.script_ev.last = done;
+
+		pthread_mutex_lock(&sc->vsd_ctrlq->mtx);
+		pci_vtdtr_cq_enqueue(sc->vsd_ctrlq, ctrl_entry);
+		pthread_mutex_unlock(&sc->vsd_ctrlq->mtx);
+
+		free(d_script);
+	}
+
+	pthread_mutex_lock(&sc->vsd_condmtx);
+	pthread_cond_signal(&sc->vsd_cond);
+	pthread_mutex_unlock(&sc->vsd_condmtx);
+	
+	pthread_exit(NULL);
+}
+
 /*
  * Mostly boilerplate, we initialize everything required for the correct
  * operation of the emulated PCI device, do error checking and finally dispatch
@@ -711,7 +1123,7 @@ static int
 pci_vtdtr_init(struct vmctx *ctx, struct pci_devinst *pci_inst, char *opts)
 {
 	struct pci_vtdtr_softc *sc;
-	pthread_t communicator, reader;
+	pthread_t communicator, listener; // reader;
 	int error;
 
 	error = 0;
@@ -722,7 +1134,7 @@ pci_vtdtr_init(struct vmctx *ctx, struct pci_devinst *pci_inst, char *opts)
 	STAILQ_INIT(&sc->vsd_ctrlq->head);
 
 	vi_softc_linkup(&sc->vsd_vs, &vtdtr_vi_consts,
-	    sc, pci_inst, sc->vsd_queues);
+					sc, pci_inst, sc->vsd_queues);
 	sc->vsd_vs.vs_mtx = &sc->vsd_mtx;
 	sc->vsd_vmctx = ctx;
 	sc->vsd_ready = 0;
@@ -744,8 +1156,19 @@ pci_vtdtr_init(struct vmctx *ctx, struct pci_devinst *pci_inst, char *opts)
 	assert(error == 0);
 	error = pthread_create(&communicator, NULL, pci_vtdtr_run, sc);
 	assert(error == 0);
-	if (dthyve_configured()) {
-		error = pthread_create(&reader, NULL, pci_vtdtr_events, sc);
+
+	if ((fp = fopen("/tmp/data.txt", "w+")) == NULL)
+	{
+		printf("%s \n", strerror(errno));
+		exit(1);
+	}
+	assert(fp != NULL);
+
+	if (dthyve_configured())
+	{
+		// error = pthread_create(&reader, NULL, pci_vtdtr_events, sc);
+		DPRINTF(("Creating thread in pci_virtio to read script. \n"));
+		error = pthread_create(&listener, NULL, pci_vtdtr_listen, sc);
 		assert(error == 0);
 	}
 
@@ -757,9 +1180,8 @@ pci_vtdtr_init(struct vmctx *ctx, struct pci_devinst *pci_inst, char *opts)
 }
 
 struct pci_devemu pci_de_vdtr = {
-	.pe_emu      = "virtio-dtrace",
-	.pe_init     = pci_vtdtr_init,
+	.pe_emu = "virtio-dtrace",
+	.pe_init = pci_vtdtr_init,
 	.pe_barwrite = vi_pci_write,
-	.pe_barread  = vi_pci_read
-};
-PCI_EMUL_SET(pci_de_vdtr);
+	.pe_barread = vi_pci_read};
+PCI_EMUL_SET(pci_de_vdtr);
\ No newline at end of file
diff --git a/usr.sbin/bhyve/pci_virtio_net.c b/usr.sbin/bhyve/pci_virtio_net.c
index bbb928f1044..9fca43a1860 100644
--- a/usr.sbin/bhyve/pci_virtio_net.c
+++ b/usr.sbin/bhyve/pci_virtio_net.c
@@ -648,7 +648,7 @@ pci_vtnet_proctx(struct pci_vtnet_softc *sc, struct vqueue_info *vq)
 		tlen += iov[i].iov_len;
 	}
 
-	DPRINTF(("virtio: packet send, %d bytes, %d segs\n\r", plen, n));
+	// DPRINTF(("virtio: packet send, %d bytes, %d segs\n\r", plen, n));
 	sc->pci_vtnet_tx(sc, &iov[1], n - 1, plen);
 
 
diff --git a/usr.sbin/ddtrace/Makefile b/usr.sbin/ddtrace/Makefile
index 8e68a4b05d4..ed6dd61e805 100644
--- a/usr.sbin/ddtrace/Makefile
+++ b/usr.sbin/ddtrace/Makefile
@@ -29,6 +29,6 @@
 # SUCH DAMAGE.
 #
 
-SUBDIR= ddtrace_consumer ddtrace_producer ddtrace_producer_anon
+SUBDIR= ddtrace_consumer ddtrace_producer ddtrace_producer_anon vm_ddtrace_consumer
 
 .include <bsd.subdir.mk>
diff --git a/usr.sbin/ddtrace/vm_ddtrace_consumer/Makefile b/usr.sbin/ddtrace/vm_ddtrace_consumer/Makefile
new file mode 100644
index 00000000000..5be00ad5754
--- /dev/null
+++ b/usr.sbin/ddtrace/vm_ddtrace_consumer/Makefile
@@ -0,0 +1,57 @@
+#-
+# Copyright (c) 2019 (Mara Mihali)
+# All rights reserved.
+#
+# This software was developed by BAE Systems, the University of Cambridge
+# Computer Laboratory, and Memorial University under DARPA/AFRL contract
+# FA8650-15-C-7558 ("CADETS"), as part of the DARPA Transparent Computing
+# (TC) research program.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+
+.PATH : ${SRCTOP}/contrib/ddtrace
+
+PROG= vm_ddtrace_consumer
+BINDIR= /usr/sbin
+
+SRCS= vm_ddtrace_consumer.c
+MAN=
+
+LIBADD+=dtrace
+LIBADD+=nv
+
+
+CFLAGS+=-I${SRCTOP}/sys/cddl/dev/vtdtr \
+		-I${SRCTOP}/sys/cddl/compat/opensolaris \
+		-I${SRCTOP}/sys/cddl/contrib/opensolaris/uts/common \
+		-I${SRCTOP}/sys/cddl/contrib/opensolaris/uts/common/dtrace \
+		-I${SRCTOP}/cddl/compat/opensolaris/include \
+		-I${SRCTOP}/cddl/lib/libdtrace \
+		-I${SRCTOP}/cddl/contrib/opensolaris/lib/libdtrace/common \
+		-I${SRCTOP}/cddl/contrib/opensolaris/lib/libctf/common \
+		-I${SRCTOP}/sys \
+		-I${SRCTOP}/contrib/dlog/src \
+		-I${SRCTOP}/sys/dev/dlog \
+		-I${SRCTOP}
+
+.include <bsd.prog.mk>
\ No newline at end of file
diff --git a/vm_test_scripts/Untitled-1 b/vm_test_scripts/Untitled-1
new file mode 100644
index 00000000000..2dcd96a4bc6
--- /dev/null
+++ b/vm_test_scripts/Untitled-1
@@ -0,0 +1,14 @@
+#!/bin/csh
+
+setenv WERROR
+setenv NO_WERROR
+setenv KERNCONF CADETS
+setenv MAKEOBJDIRPREFIX /obj
+
+cd /usr/src
+2>&1
+
+make -j4 cleanuniverse
+TIMEFORMAT=%R # Just real time
+
+/usr/bin/time -p make -j4 buildkernel 
diff --git a/vm_test_scripts/start_tmux.py b/vm_test_scripts/start_tmux.py
new file mode 100644
index 00000000000..c0f4fc92179
--- /dev/null
+++ b/vm_test_scripts/start_tmux.py
@@ -0,0 +1,20 @@
+#!/usr/bin/env python
+from os import system
+
+def tmux(command):
+    system('tmux %s' % command)
+
+def tmux_shell(command):
+    tmux('send-keys "%s" "C-m"' % command)
+
+# first tab - host
+# second tab - start guest
+tmux('select-window -t 0')
+tmux_shell('cd %s' % "path to D script")
+tmux('rename-window "host"')
+
+tmux('new-window')
+tmux('select-window -t 1')
+tmux('%s' % "./starvm.sh")
+tmux('rename-window "guest"')
+
diff --git a/vm_test_scripts/testvm.sh b/vm_test_scripts/testvm.sh
new file mode 100644
index 00000000000..e57e65fcb13
--- /dev/null
+++ b/vm_test_scripts/testvm.sh
@@ -0,0 +1,6 @@
+#!/bin/sh
+
+bhyvectl --destroy --vm=test
+
+bhyveload -d test.img -m 10g test
+bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 -s 3:0,virtio-blk,./test.img -s 4:0,virtio-dtrace -l com1,stdio -c 6 -m 10g -t test
\ No newline at end of file
diff --git a/vm_test_scripts/vmmake.sh b/vm_test_scripts/vmmake.sh
new file mode 100644
index 00000000000..7849b1c2e08
--- /dev/null
+++ b/vm_test_scripts/vmmake.sh
@@ -0,0 +1,269 @@
+#!/bin/sh
+#
+# Copyright (c) 2015-2018 Mark Johnston <markj@FreeBSD.org>
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+#
+# todo:
+#   - support for incremental rebuilds of images
+#   - ssh keys
+#   - i386 images
+#
+
+usage()
+{
+    cat >&2 <<__EOF__
+usage: $(basename $0) [-tkx] [-a <arch>] [-c <kernconf>] [-f <numfree>] [-p <pkgs>] [-s <size>] <img>
+__EOF__
+    exit 1
+}
+
+# Bootstrap packages.
+bootstrap()
+{
+    local md mdir pfile pkgs
+
+    pfile=$1
+    pkgs=$2
+
+    md=$(mdconfig -S $SECTORSIZE -f $pfile)
+    mdir=$(mktemp -d)
+
+    mount /dev/$md $mdir
+
+    # Set up to install packages.
+    #cp -f /etc/resolv.conf ${mdir}/etc/resolv.conf
+    echo 'nameserver 8.8.8.8.' ${mdir}/etc/resolv.conf
+    chroot ${mdir} env ASSUME_ALWAYS_YES=yes /usr/sbin/pkg -O OSVERSION=1200057 bootstrap -y
+
+    # Do the thing.
+    echo "$pkgs" | tr ',' ' ' | xargs chroot $mdir env ASSUME_ALWAYS_YES=yes \
+        /usr/local/sbin/pkg -o OSVERSION=1200057 install
+
+    # Clean up, clean up.
+    umount $mdir
+    rmdir $mdir
+    mdconfig -d -u ${md#md}
+}
+
+cleanup()
+{
+    if [ $TMPFS ]; then
+        umount $DESTDIR
+    else
+        rm -rf $DESTDIR || :
+        chflags -R 0 $DESTDIR || :
+        rm -rf $DESTDIR
+    fi
+
+    rm -f $PARTFILE
+}
+
+# Manually add a file to the image.
+logfile()
+{
+    local file root size
+
+    file=$1
+    root=$2
+
+    size=$(stat -f '%z' ${root}/${file})
+    echo "./$file type=file uname=root gname=wheel mode=0644 size=$size" >> ${root}/METALOG
+}
+
+# Create custom system configuration files.
+install_config()
+{
+    #local destdir fstab localtime rcconf srcconf
+    local destdir fstab rcconf srcconf
+
+    destdir=$1
+    kernconfig=$2
+    srcdir=$3
+
+    fstab=etc/fstab
+    cat > ${destdir}/$fstab <<__EOF__
+/dev/gpt/rootfs / ufs rw 1 1
+/dev/gpt/swapfs none swap sw 0 0
+none /proc procfs rw 0 0
+none /dev/fd fdescfs rw 0 0
+__EOF__
+
+    if [ $NONET -eq 0 ]; then
+        cat >> ${destdir}/$fstab <<__EOF__
+${IPADDR}:$(pwd) /usr/src nfs ro 0 0
+__EOF__
+    fi
+
+    #localtime=etc/localtime
+    #cp -f /$localtime ${destdir}/$localtime
+
+    rcconf=etc/rc.conf
+    cat > ${destdir}/$rcconf <<__EOF__
+ifconfig_vtnet0="DHCP"
+ipv6_activate_all_interfaces="YES"
+ipv6_cpe_wanif="vtnet0"
+sendmail_enable="NONE"
+sshd_enable="YES"
+__EOF__
+
+    srcconf=etc/src.conf
+    cat > ${destdir}/$srcconf <<__EOF__
+KERNCONF?= $kernconfig
+__EOF__
+
+    wallcmosclock=etc/wall_cmos_clock
+    touch ${destdir}/$wallcmosclock
+
+    logfile $fstab $destdir
+    #logfile $localtime $destdir
+    logfile $rcconf $destdir
+    logfile $srcconf $destdir
+    logfile $wallcmosclock $destdir
+    echo 'ums_load="YES"' >> ${destdir}/boot/loader.conf
+    echo 'fdescfs_load="YES"' >> ${destdir}/boot/loader.conf
+    echo 'vmm_load="YES"' >> ${destdir}/boot/loader.conf
+    echo 'dtraceall_load="YES"' >> ${destdir}/boot/loader.conf
+    echo 'dlog_load="YES"' >> ${destdir}/boot/loader.conf
+    echo 'ddtrace_load="YES"' >> ${destdir}/boot/loader.conf
+
+    echo "${srcdir}"
+    cp -R ${srcdir}/* ${destdir}/usr/src
+}
+
+#
+# Execution begins here.
+#
+
+set -e
+
+ARCH=$(uname -m)
+IPADDR=
+KERNCONFIG=
+MKSRC=0
+NONET=0
+NUMFILES=
+PARTSIZE=10g
+PACKAGES=
+SECTORSIZE=512
+TMPFS=
+while getopts a:c:f:i:k:p:S:s:tx o; do
+    case "$o" in
+    a)
+        ARCH=$OPTARG
+        ;;
+    c)
+        KERNCONFIG=$OPTARG
+        ;;
+    f)
+        NUMFILES=$OPTARG
+        ;;
+    i)
+        IPADDR=$OPTARG
+        ;;
+    k)
+        MKSRC=1
+	SRCDIR=$OPTARG
+        ;;
+    p)
+        PACKAGES=$OPTARG
+        ;;
+    s)
+        PARTSIZE=$OPTARG
+        ;;
+    S)
+        SECTORSIZE=$OPTARG
+        ;;
+    t)
+        TMPFS=1
+        ;;
+    x)
+        NONET=1
+	;;
+    ?)
+        usage
+        ;;
+    esac
+    shift $((OPTIND-1))
+done
+
+if [ -n "$PACKAGES" -a $(id -u) -ne 0 ]; then
+    echo "$(basename $0): must be root to install packages" >&2
+    exit 1
+elif [ "$TMPFS" -a $(id -u) -ne 0 ]; then
+    echo "$(basename $0): must be root to use tmpfs" >&2
+    exit 1
+fi
+
+if [ -z "$KERNCONFIG" ]; then
+    KERNCONFIG=BHYVE
+fi
+
+if [ $NONET -eq 0 ]; then
+    if [ -z "$IPADDR" ]; then
+        ifconfig bridge0 >/dev/null || exit 1
+        IPADDR=$(ifconfig bridge0 | grep -E '^[[:space:]]*inet' | head -n 1 | \
+            awk '{print $2}')
+    fi
+fi
+
+IMAGE=${1:-/tmp/vm.raw}
+PARTFILE=$(mktemp)
+
+DESTDIR=$(mktemp -d)
+if [ $TMPFS ]; then
+    mount -t tmpfs tmpfs $DESTDIR
+fi
+
+trap "cleanup; exit 1" EXIT SIGINT SIGHUP SIGTERM
+
+make -j $(sysctl -n hw.ncpu) -s -DNO_ROOT DESTDIR=$DESTDIR KERNCONF=$KERNCONFIG \
+    MACHINE=$ARCH TARGET_ARCH=$ARCH \
+    DISTDIR= installworld installkernel distribution
+
+install_config $DESTDIR $KERNCONFIG $SRCDIR
+
+if [ -z "$NUMFILES" ]; then
+    NUMFILES=$(cat ${DESTDIR}/METALOG | wc -l)
+fi
+
+if [ $MKSRC -eq 1 ]; then
+    echo "Installing source..."
+    # cp -R $SRCDIR/* $DESTDIR/usr/src/
+fi
+
+makefs -B little -f $NUMFILES -o label=VM -M $PARTSIZE -S $SECTORSIZE \
+    -F ${DESTDIR}/METALOG $PARTFILE $DESTDIR
+
+if [ -n "$PACKAGES" ]; then
+    bootstrap $PARTFILE $PACKAGES
+fi
+
+mkimg -s gpt -f raw -S $SECTORSIZE -b ${DESTDIR}/boot/pmbr \
+    -p freebsd-boot/bootfs:=${DESTDIR}/boot/gptboot \
+    -p freebsd-swap/swapfs::2G \
+    -p freebsd-ufs/rootfs:=${PARTFILE} \
+    -o $IMAGE
+
+rm -f $PARTFILE
