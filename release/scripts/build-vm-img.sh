#!/usr/bin/env bash

# DEFINE_SCRIPT_DIR([])
# INCLUDE_PARSING_CODE([build-vm-img-parsing.sh])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.8.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

# OTHER STUFF GENERATED BY Argbash
script_dir="$(cd "$(dirname "$(readlink "${BASH_SOURCE[0]}")")" && pwd)" || die "Couldn't determine the script's running directory, which probably matters, bailing out" 2
. "$script_dir/build-vm-img-parsing.sh"  # '.' means 'source'


### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

set -euo pipefail    # stop on error, unset variables or pipe failures
trap "cleanup" EXIT INT QUIT TRAP ABRT TERM

KOBJ_DIR=${OBJ_DIR}/${TARGET}.${TARGET_ARCH}

cleanup() {
  echo "build-vm-img.sh error; running cleanup..."
  return 0
}

local_vm_create_disk() {
  if [ -z "${NOSWAP}" ]; then
    SWAPOPT="-p freebsd-swap/swapfs::${SWAPSIZE}"
  fi

  BOOTFILES="$(env TARGET=${TARGET} TARGET_ARCH=${TARGET_ARCH} \
    WITH_UNIFIED_OBJDIR=yes \
    make -C ${WORLDDIR}/stand -V .OBJDIR)"
  BOOTFILES="$(realpath ${BOOTFILES})"

  case "${TARGET}:${TARGET_ARCH}" in
    amd64:amd64 | i386:i386)
      mkimg -s gpt -f ${VMFORMAT} \
        -b ${BOOTFILES}/i386/pmbr/pmbr \
        -p freebsd-boot/gpboot:=${BOOTFILES}/i386/gptboot/gptboot \
        -p efi/gpefiboot:=${BOOTFILES}/efi/boot1/boot1.efifat \
        ${SWAPOPT} \
        -p freebsd-ufs/gprootfs:=${VMBASE} \
        -o ${VMIMAGE}
      ;;
    *)
      # ENOTSUPP
      return 1
      ;;
  esac

  return 0

}

local_vm_install_base() {
	# Installs the FreeBSD userland/kernel to the virtual machine disk.

	cd ${WORLDDIR} && \
		make DESTDIR=${DESTDIR} KERNCONF=${KERNCONF} \
		installworld installkernel distribution || \
		err "\n\nCannot install the base system to ${DESTDIR}."

	# Bootstrap etcupdate(8) and mergemaster(8) databases.
	mkdir -p ${DESTDIR}/var/db/etcupdate
	etcupdate extract -B \
		-M "TARGET=${TARGET} TARGET_ARCH=${TARGET_ARCH}" \
		-s ${WORLDDIR} -d ${DESTDIR}/var/db/etcupdate
	sh ${WORLDDIR}/release/scripts/mm-mtree.sh -m ${WORLDDIR} \
		-F "TARGET=${TARGET} TARGET_ARCH=${TARGET_ARCH}" \
		-D ${DESTDIR}

	echo '# Custom /etc/fstab for FreeBSD VM images' \
		> ${DESTDIR}/etc/fstab
	echo "/dev/${ROOTLABEL}/gprootfs   /       ufs     rw      1       1" \
		>> ${DESTDIR}/etc/fstab
	if [ -z "${NOSWAP}" ]; then
		echo '/dev/gpt/swapfs  none    swap    sw      0       0' \
			>> ${DESTDIR}/etc/fstab
	fi

	echo "hostname=\"${_arg_vm_name}\"" >> ${DESTDIR}/etc/rc.conf

	mkdir -p ${DESTDIR}/dev
	mount -t devfs devfs ${DESTDIR}/dev
	chroot ${DESTDIR} /usr/bin/newaliases
	chroot ${DESTDIR} /etc/rc.d/ldconfig forcestart
	umount_loop ${DESTDIR}/dev

	cp /etc/resolv.conf ${DESTDIR}/etc/resolv.conf

	return 0
}


if [ ! -d ${VM_IMG_DEST} ]; then
  mkdir -p ${VM_IMG_DEST}
fi

cd /usr/src

if [ ${_arg_world} = on ]; then
  rm ${KOBJ_DIR}/worldwasbuilt || true
fi
if [ ${_arg_kernel} = on ]; then
  rm ${KOBJ_DIR}/kernelwasbuilt || true
fi

if [ ! -f ${KOBJ_DIR}/worldwasbuilt ]; then
  make -j${MAKE_NUMCPUS} buildworld -s
  touch ${KOBJ_DIR}/worldwasbuilt
fi

if [ ! -f ${KOBJ_DIR}/kernelwasbuilt ]; then
  make -j${MAKE_NUMCPUS} buildkernel -s KERNCONF=${KERNCONF}
  touch ${KOBJ_DIR}/kernelwasbuilt
fi

# hijack the same components used by make -C release vm-release
WORLDDIR="/usr/src"
VMBUILDCONF="${WORLDDIR}/release/tools/vmimage.subr"
TARGET_DIR="${KOBJ_DIR}/release/vm-image"
if [ ! -d ${TARGET_DIR} ]; then
  mkdir -p ${TARGET_DIR}
fi
if [ ${SWAP_ON} = true ]; then
  NOSWAP=""
else
  NOSWAP="noswap"
fi
VMFORMAT="raw"
DESTDIR="${TARGET_DIR}"
VMSIZE="${VM_ROOT_SIZE}"
SWAPSIZE="${VM_SWAP_SIZE}"
VMBASE="${KOBJ_DIR}/release/raw.img"
VMIMAGE="${KOBJ_DIR}/release/vm.raw"
VMCONFIG=""
KERNCONF=${KERNCONF}

. "${VMBUILDCONF}"

ROOTLABEL="gpt"

echo "Creating base VM image ..."
vm_create_base

echo "Installing world & kernel into base VM image ..."
# replace call to vm_install_base to customize KERNCONF
local_vm_install_base

echo "Customizing VM image ..."
vm_extra_install_base
# further customise VM base img for CADETS purposes
#
#sed -i "s/hostname=\".*\"/hostname=\"${_arg_vm_name}\"/" ${DESTDIR}/etc/rc.conf
echo 'ums_load="YES"' >> ${DESTDIR}/boot/loader.conf
echo 'fdescfs_load="YES"' >> ${DESTDIR}/boot/loader.conf
echo 'vmm_load="YES"' >> ${DESTDIR}/boot/loader.conf
echo 'dtraceall_load="YES"' >> ${DESTDIR}/boot/loader.conf
echo 'varmfs="YES"' >> ${DESTDIR}/etc/rc.conf
echo 'ifconfig_ixl0="DHCP inet6 accept_rtadv"' >> ${DESTDIR}/etc/rc.conf

echo "  \ installing packages ..."
VM_EXTRA_PACKAGES="bash python27 curl wget sudo git htop rsync vim"

#workaround for pkg in FreeBSD13
if [ ! -f ${DESTDIR}/usr/lib/libssl.so.111 ]; then
  cp /usr/lib/libssl.so.111 ${DESTDIR}/usr/lib/libssl.so.111
fi
if [ ! -f ${DESTDIR}/lib/libcrypto.so.111 ]; then
  cp /lib/libcrypto.so.111 ${DESTDIR}/lib/libcrypto.so.111
fi
vm_extra_install_packages
vm_extra_install_ports

echo "  \ enabling services ..."
VM_RC_LIST[0]="sshd"
VM_RC_LIST[1]="ums"
VM_RC_LIST[2]="fdescfs"
vm_extra_enable_services

echo "  \ cleaning base VM image ..."
vm_extra_pre_umount
vm_extra_pkg_rmcache
cleanup

echo "Creating bootable VM disk (format: raw) ..."
vm_copy_base

# replace call to vm_create_disk with local function
# to also make the VM efi-bootable
echo "  \ creating partitions ..."
local_vm_create_disk

vm_extra_create_disk

echo "Finalizing VM image install into ${VM_IMG_DEST}"
make -C release vm-install \
  WITH_VMIMAGES="YES" \
  VMFORMATS="raw" \
  VMSIZE=${VM_ROOT_SIZE} \
  KERNCONF=${KERNCONF} \
  DESTDIR=${VM_IMG_DEST}


trap - EXIT INT QUIT TRAP ABRT TERM
echo "Done"

# ] <-- needed because of Argbash
